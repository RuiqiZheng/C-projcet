        -:    0:Source:/usr/local/Cellar/opencv/4.3.0_4/include/opencv4/opencv2/core/mat.hpp
        -:    0:Graph:/Users/bytedance/CLionProjects/C-projcet/cmake-build-debug/CMakeFiles/cppProject.dir/code/main.cpp.gcno
        -:    0:Data:/Users/bytedance/CLionProjects/C-projcet/cmake-build-debug/CMakeFiles/cppProject.dir/code/main.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*M///////////////////////////////////////////////////////////////////////////////////////
        -:    2://
        -:    3://  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
        -:    4://
        -:    5://  By downloading, copying, installing or using the software you agree to this license.
        -:    6://  If you do not agree to this license, do not download, install,
        -:    7://  copy or use the software.
        -:    8://
        -:    9://
        -:   10://                          License Agreement
        -:   11://                For Open Source Computer Vision Library
        -:   12://
        -:   13:// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.
        -:   14:// Copyright (C) 2009, Willow Garage Inc., all rights reserved.
        -:   15:// Copyright (C) 2013, OpenCV Foundation, all rights reserved.
        -:   16:// Third party copyrights are property of their respective owners.
        -:   17://
        -:   18:// Redistribution and use in source and binary forms, with or without modification,
        -:   19:// are permitted provided that the following conditions are met:
        -:   20://
        -:   21://   * Redistribution's of source code must retain the above copyright notice,
        -:   22://     this list of conditions and the following disclaimer.
        -:   23://
        -:   24://   * Redistribution's in binary form must reproduce the above copyright notice,
        -:   25://     this list of conditions and the following disclaimer in the documentation
        -:   26://     and/or other materials provided with the distribution.
        -:   27://
        -:   28://   * The name of the copyright holders may not be used to endorse or promote products
        -:   29://     derived from this software without specific prior written permission.
        -:   30://
        -:   31:// This software is provided by the copyright holders and contributors "as is" and
        -:   32:// any express or implied warranties, including, but not limited to, the implied
        -:   33:// warranties of merchantability and fitness for a particular purpose are disclaimed.
        -:   34:// In no event shall the Intel Corporation or contributors be liable for any direct,
        -:   35:// indirect, incidental, special, exemplary, or consequential damages
        -:   36:// (including, but not limited to, procurement of substitute goods or services;
        -:   37:// loss of use, data, or profits; or business interruption) however caused
        -:   38:// and on any theory of liability, whether in contract, strict liability,
        -:   39:// or tort (including negligence or otherwise) arising in any way out of
        -:   40:// the use of this software, even if advised of the possibility of such damage.
        -:   41://
        -:   42://M*/
        -:   43:
        -:   44:#ifndef OPENCV_CORE_MAT_HPP
        -:   45:#define OPENCV_CORE_MAT_HPP
        -:   46:
        -:   47:#ifndef __cplusplus
        -:   48:#  error mat.hpp header must be compiled as C++
        -:   49:#endif
        -:   50:
        -:   51:#include "opencv2/core/matx.hpp"
        -:   52:#include "opencv2/core/types.hpp"
        -:   53:
        -:   54:#include "opencv2/core/bufferpool.hpp"
        -:   55:
        -:   56:#include <type_traits>
        -:   57:
        -:   58:namespace cv
        -:   59:{
        -:   60:
        -:   61://! @addtogroup core_basic
        -:   62://! @{
        -:   63:
        -:   64:enum AccessFlag { ACCESS_READ=1<<24, ACCESS_WRITE=1<<25,
        -:   65:    ACCESS_RW=3<<24, ACCESS_MASK=ACCESS_RW, ACCESS_FAST=1<<26 };
        -:   66:CV_ENUM_FLAGS(AccessFlag)
        -:   67:__CV_ENUM_FLAGS_BITWISE_AND(AccessFlag, int, AccessFlag)
        -:   68:
        -:   69:CV__DEBUG_NS_BEGIN
        -:   70:
        -:   71:class CV_EXPORTS _OutputArray;
        -:   72:
        -:   73://////////////////////// Input/Output Array Arguments /////////////////////////////////
        -:   74:
        -:   75:/** @brief This is the proxy class for passing read-only input arrays into OpenCV functions.
        -:   76:
        -:   77:It is defined as:
        -:   78:@code
        -:   79:    typedef const _InputArray& InputArray;
        -:   80:@endcode
        -:   81:where _InputArray is a class that can be constructed from `Mat`, `Mat_<T>`, `Matx<T, m, n>`,
        -:   82:`std::vector<T>`, `std::vector<std::vector<T> >`, `std::vector<Mat>`, `std::vector<Mat_<T> >`,
        -:   83:`UMat`, `std::vector<UMat>` or `double`. It can also be constructed from a matrix expression.
        -:   84:
        -:   85:Since this is mostly implementation-level class, and its interface may change in future versions, we
        -:   86:do not describe it in details. There are a few key things, though, that should be kept in mind:
        -:   87:
        -:   88:-   When you see in the reference manual or in OpenCV source code a function that takes
        -:   89:    InputArray, it means that you can actually pass `Mat`, `Matx`, `vector<T>` etc. (see above the
        -:   90:    complete list).
        -:   91:-   Optional input arguments: If some of the input arrays may be empty, pass cv::noArray() (or
        -:   92:    simply cv::Mat() as you probably did before).
        -:   93:-   The class is designed solely for passing parameters. That is, normally you *should not*
        -:   94:    declare class members, local and global variables of this type.
        -:   95:-   If you want to design your own function or a class method that can operate of arrays of
        -:   96:    multiple types, you can use InputArray (or OutputArray) for the respective parameters. Inside
        -:   97:    a function you should use _InputArray::getMat() method to construct a matrix header for the
        -:   98:    array (without copying data). _InputArray::kind() can be used to distinguish Mat from
        -:   99:    `vector<>` etc., but normally it is not needed.
        -:  100:
        -:  101:Here is how you can use a function that takes InputArray :
        -:  102:@code
        -:  103:    std::vector<Point2f> vec;
        -:  104:    // points or a circle
        -:  105:    for( int i = 0; i < 30; i++ )
        -:  106:        vec.push_back(Point2f((float)(100 + 30*cos(i*CV_PI*2/5)),
        -:  107:                              (float)(100 - 30*sin(i*CV_PI*2/5))));
        -:  108:    cv::transform(vec, vec, cv::Matx23f(0.707, -0.707, 10, 0.707, 0.707, 20));
        -:  109:@endcode
        -:  110:That is, we form an STL vector containing points, and apply in-place affine transformation to the
        -:  111:vector using the 2x3 matrix created inline as `Matx<float, 2, 3>` instance.
        -:  112:
        -:  113:Here is how such a function can be implemented (for simplicity, we implement a very specific case of
        -:  114:it, according to the assertion statement inside) :
        -:  115:@code
        -:  116:    void myAffineTransform(InputArray _src, OutputArray _dst, InputArray _m)
        -:  117:    {
        -:  118:        // get Mat headers for input arrays. This is O(1) operation,
        -:  119:        // unless _src and/or _m are matrix expressions.
        -:  120:        Mat src = _src.getMat(), m = _m.getMat();
        -:  121:        CV_Assert( src.type() == CV_32FC2 && m.type() == CV_32F && m.size() == Size(3, 2) );
        -:  122:
        -:  123:        // [re]create the output array so that it has the proper size and type.
        -:  124:        // In case of Mat it calls Mat::create, in case of STL vector it calls vector::resize.
        -:  125:        _dst.create(src.size(), src.type());
        -:  126:        Mat dst = _dst.getMat();
        -:  127:
        -:  128:        for( int i = 0; i < src.rows; i++ )
        -:  129:            for( int j = 0; j < src.cols; j++ )
        -:  130:            {
        -:  131:                Point2f pt = src.at<Point2f>(i, j);
        -:  132:                dst.at<Point2f>(i, j) = Point2f(m.at<float>(0, 0)*pt.x +
        -:  133:                                                m.at<float>(0, 1)*pt.y +
        -:  134:                                                m.at<float>(0, 2),
        -:  135:                                                m.at<float>(1, 0)*pt.x +
        -:  136:                                                m.at<float>(1, 1)*pt.y +
        -:  137:                                                m.at<float>(1, 2));
        -:  138:            }
        -:  139:    }
        -:  140:@endcode
        -:  141:There is another related type, InputArrayOfArrays, which is currently defined as a synonym for
        -:  142:InputArray:
        -:  143:@code
        -:  144:    typedef InputArray InputArrayOfArrays;
        -:  145:@endcode
        -:  146:It denotes function arguments that are either vectors of vectors or vectors of matrices. A separate
        -:  147:synonym is needed to generate Python/Java etc. wrappers properly. At the function implementation
        -:  148:level their use is similar, but _InputArray::getMat(idx) should be used to get header for the
        -:  149:idx-th component of the outer vector and _InputArray::size().area() should be used to find the
        -:  150:number of components (vectors/matrices) of the outer vector.
        -:  151:
        -:  152:In general, type support is limited to cv::Mat types. Other types are forbidden.
        -:  153:But in some cases we need to support passing of custom non-general Mat types, like arrays of cv::KeyPoint, cv::DMatch, etc.
        -:  154:This data is not intended to be interpreted as an image data, or processed somehow like regular cv::Mat.
        -:  155:To pass such custom type use rawIn() / rawOut() / rawInOut() wrappers.
        -:  156:Custom type is wrapped as Mat-compatible `CV_8UC<N>` values (N = sizeof(T), N <= CV_CN_MAX).
        -:  157: */
        -:  158:class CV_EXPORTS _InputArray
        -:  159:{
        -:  160:public:
        -:  161:    enum KindFlag {
        -:  162:        KIND_SHIFT = 16,
        -:  163:        FIXED_TYPE = 0x8000 << KIND_SHIFT,
        -:  164:        FIXED_SIZE = 0x4000 << KIND_SHIFT,
        -:  165:        KIND_MASK = 31 << KIND_SHIFT,
        -:  166:
        -:  167:        NONE              = 0 << KIND_SHIFT,
        -:  168:        MAT               = 1 << KIND_SHIFT,
        -:  169:        MATX              = 2 << KIND_SHIFT,
        -:  170:        STD_VECTOR        = 3 << KIND_SHIFT,
        -:  171:        STD_VECTOR_VECTOR = 4 << KIND_SHIFT,
        -:  172:        STD_VECTOR_MAT    = 5 << KIND_SHIFT,
        -:  173:        EXPR              = 6 << KIND_SHIFT,
        -:  174:        OPENGL_BUFFER     = 7 << KIND_SHIFT,
        -:  175:        CUDA_HOST_MEM     = 8 << KIND_SHIFT,
        -:  176:        CUDA_GPU_MAT      = 9 << KIND_SHIFT,
        -:  177:        UMAT              =10 << KIND_SHIFT,
        -:  178:        STD_VECTOR_UMAT   =11 << KIND_SHIFT,
        -:  179:        STD_BOOL_VECTOR   =12 << KIND_SHIFT,
        -:  180:        STD_VECTOR_CUDA_GPU_MAT = 13 << KIND_SHIFT,
        -:  181:        STD_ARRAY         =14 << KIND_SHIFT,
        -:  182:        STD_ARRAY_MAT     =15 << KIND_SHIFT
        -:  183:    };
        -:  184:
        -:  185:    _InputArray();
        -:  186:    _InputArray(int _flags, void* _obj);
        -:  187:    _InputArray(const Mat& m);
        -:  188:    _InputArray(const MatExpr& expr);
        -:  189:    _InputArray(const std::vector<Mat>& vec);
        -:  190:    template<typename _Tp> _InputArray(const Mat_<_Tp>& m);
        -:  191:    template<typename _Tp> _InputArray(const std::vector<_Tp>& vec);
        -:  192:    _InputArray(const std::vector<bool>& vec);
        -:  193:    template<typename _Tp> _InputArray(const std::vector<std::vector<_Tp> >& vec);
        -:  194:    _InputArray(const std::vector<std::vector<bool> >&) = delete;  // not supported
        -:  195:    template<typename _Tp> _InputArray(const std::vector<Mat_<_Tp> >& vec);
        -:  196:    template<typename _Tp> _InputArray(const _Tp* vec, int n);
        -:  197:    template<typename _Tp, int m, int n> _InputArray(const Matx<_Tp, m, n>& matx);
        -:  198:    _InputArray(const double& val);
        -:  199:    _InputArray(const cuda::GpuMat& d_mat);
        -:  200:    _InputArray(const std::vector<cuda::GpuMat>& d_mat_array);
        -:  201:    _InputArray(const ogl::Buffer& buf);
        -:  202:    _InputArray(const cuda::HostMem& cuda_mem);
        -:  203:    template<typename _Tp> _InputArray(const cudev::GpuMat_<_Tp>& m);
        -:  204:    _InputArray(const UMat& um);
        -:  205:    _InputArray(const std::vector<UMat>& umv);
        -:  206:
        -:  207:    template<typename _Tp, std::size_t _Nm> _InputArray(const std::array<_Tp, _Nm>& arr);
        -:  208:    template<std::size_t _Nm> _InputArray(const std::array<Mat, _Nm>& arr);
        -:  209:
        -:  210:    template<typename _Tp> static _InputArray rawIn(const std::vector<_Tp>& vec);
        -:  211:    template<typename _Tp, std::size_t _Nm> static _InputArray rawIn(const std::array<_Tp, _Nm>& arr);
        -:  212:
        -:  213:    Mat getMat(int idx=-1) const;
        -:  214:    Mat getMat_(int idx=-1) const;
        -:  215:    UMat getUMat(int idx=-1) const;
        -:  216:    void getMatVector(std::vector<Mat>& mv) const;
        -:  217:    void getUMatVector(std::vector<UMat>& umv) const;
        -:  218:    void getGpuMatVector(std::vector<cuda::GpuMat>& gpumv) const;
        -:  219:    cuda::GpuMat getGpuMat() const;
        -:  220:    ogl::Buffer getOGlBuffer() const;
        -:  221:
        -:  222:    int getFlags() const;
        -:  223:    void* getObj() const;
        -:  224:    Size getSz() const;
        -:  225:
        -:  226:    _InputArray::KindFlag kind() const;
        -:  227:    int dims(int i=-1) const;
        -:  228:    int cols(int i=-1) const;
        -:  229:    int rows(int i=-1) const;
        -:  230:    Size size(int i=-1) const;
        -:  231:    int sizend(int* sz, int i=-1) const;
        -:  232:    bool sameSize(const _InputArray& arr) const;
        -:  233:    size_t total(int i=-1) const;
        -:  234:    int type(int i=-1) const;
        -:  235:    int depth(int i=-1) const;
        -:  236:    int channels(int i=-1) const;
        -:  237:    bool isContinuous(int i=-1) const;
        -:  238:    bool isSubmatrix(int i=-1) const;
        -:  239:    bool empty() const;
        -:  240:    void copyTo(const _OutputArray& arr) const;
        -:  241:    void copyTo(const _OutputArray& arr, const _InputArray & mask) const;
        -:  242:    size_t offset(int i=-1) const;
        -:  243:    size_t step(int i=-1) const;
        -:  244:    bool isMat() const;
        -:  245:    bool isUMat() const;
        -:  246:    bool isMatVector() const;
        -:  247:    bool isUMatVector() const;
        -:  248:    bool isMatx() const;
        -:  249:    bool isVector() const;
        -:  250:    bool isGpuMat() const;
        -:  251:    bool isGpuMatVector() const;
        -:  252:    ~_InputArray();
        -:  253:
        -:  254:protected:
        -:  255:    int flags;
        -:  256:    void* obj;
        -:  257:    Size sz;
        -:  258:
        -:  259:    void init(int _flags, const void* _obj);
        -:  260:    void init(int _flags, const void* _obj, Size _sz);
        -:  261:};
        -:  262:CV_ENUM_FLAGS(_InputArray::KindFlag)
        -:  263:__CV_ENUM_FLAGS_BITWISE_AND(_InputArray::KindFlag, int, _InputArray::KindFlag)
        -:  264:
        -:  265:/** @brief This type is very similar to InputArray except that it is used for input/output and output function
        -:  266:parameters.
        -:  267:
        -:  268:Just like with InputArray, OpenCV users should not care about OutputArray, they just pass `Mat`,
        -:  269:`vector<T>` etc. to the functions. The same limitation as for `InputArray`: *Do not explicitly
        -:  270:create OutputArray instances* applies here too.
        -:  271:
        -:  272:If you want to make your function polymorphic (i.e. accept different arrays as output parameters),
        -:  273:it is also not very difficult. Take the sample above as the reference. Note that
        -:  274:_OutputArray::create() needs to be called before _OutputArray::getMat(). This way you guarantee
        -:  275:that the output array is properly allocated.
        -:  276:
        -:  277:Optional output parameters. If you do not need certain output array to be computed and returned to
        -:  278:you, pass cv::noArray(), just like you would in the case of optional input array. At the
        -:  279:implementation level, use _OutputArray::needed() to check if certain output array needs to be
        -:  280:computed or not.
        -:  281:
        -:  282:There are several synonyms for OutputArray that are used to assist automatic Python/Java/... wrapper
        -:  283:generators:
        -:  284:@code
        -:  285:    typedef OutputArray OutputArrayOfArrays;
        -:  286:    typedef OutputArray InputOutputArray;
        -:  287:    typedef OutputArray InputOutputArrayOfArrays;
        -:  288:@endcode
        -:  289: */
        -:  290:class CV_EXPORTS _OutputArray : public _InputArray
        -:  291:{
        -:  292:public:
        -:  293:    enum DepthMask
        -:  294:    {
        -:  295:        DEPTH_MASK_8U = 1 << CV_8U,
        -:  296:        DEPTH_MASK_8S = 1 << CV_8S,
        -:  297:        DEPTH_MASK_16U = 1 << CV_16U,
        -:  298:        DEPTH_MASK_16S = 1 << CV_16S,
        -:  299:        DEPTH_MASK_32S = 1 << CV_32S,
        -:  300:        DEPTH_MASK_32F = 1 << CV_32F,
        -:  301:        DEPTH_MASK_64F = 1 << CV_64F,
        -:  302:        DEPTH_MASK_16F = 1 << CV_16F,
        -:  303:        DEPTH_MASK_ALL = (DEPTH_MASK_64F<<1)-1,
        -:  304:        DEPTH_MASK_ALL_BUT_8S = DEPTH_MASK_ALL & ~DEPTH_MASK_8S,
        -:  305:        DEPTH_MASK_ALL_16F = (DEPTH_MASK_16F<<1)-1,
        -:  306:        DEPTH_MASK_FLT = DEPTH_MASK_32F + DEPTH_MASK_64F
        -:  307:    };
        -:  308:
        -:  309:    _OutputArray();
        -:  310:    _OutputArray(int _flags, void* _obj);
        -:  311:    _OutputArray(Mat& m);
        -:  312:    _OutputArray(std::vector<Mat>& vec);
        -:  313:    _OutputArray(cuda::GpuMat& d_mat);
        -:  314:    _OutputArray(std::vector<cuda::GpuMat>& d_mat);
        -:  315:    _OutputArray(ogl::Buffer& buf);
        -:  316:    _OutputArray(cuda::HostMem& cuda_mem);
        -:  317:    template<typename _Tp> _OutputArray(cudev::GpuMat_<_Tp>& m);
        -:  318:    template<typename _Tp> _OutputArray(std::vector<_Tp>& vec);
        -:  319:    _OutputArray(std::vector<bool>& vec) = delete;  // not supported
        -:  320:    template<typename _Tp> _OutputArray(std::vector<std::vector<_Tp> >& vec);
        -:  321:    _OutputArray(std::vector<std::vector<bool> >&) = delete;  // not supported
        -:  322:    template<typename _Tp> _OutputArray(std::vector<Mat_<_Tp> >& vec);
        -:  323:    template<typename _Tp> _OutputArray(Mat_<_Tp>& m);
        -:  324:    template<typename _Tp> _OutputArray(_Tp* vec, int n);
        -:  325:    template<typename _Tp, int m, int n> _OutputArray(Matx<_Tp, m, n>& matx);
        -:  326:    _OutputArray(UMat& m);
        -:  327:    _OutputArray(std::vector<UMat>& vec);
        -:  328:
        -:  329:    _OutputArray(const Mat& m);
        -:  330:    _OutputArray(const std::vector<Mat>& vec);
        -:  331:    _OutputArray(const cuda::GpuMat& d_mat);
        -:  332:    _OutputArray(const std::vector<cuda::GpuMat>& d_mat);
        -:  333:    _OutputArray(const ogl::Buffer& buf);
        -:  334:    _OutputArray(const cuda::HostMem& cuda_mem);
        -:  335:    template<typename _Tp> _OutputArray(const cudev::GpuMat_<_Tp>& m);
        -:  336:    template<typename _Tp> _OutputArray(const std::vector<_Tp>& vec);
        -:  337:    template<typename _Tp> _OutputArray(const std::vector<std::vector<_Tp> >& vec);
        -:  338:    template<typename _Tp> _OutputArray(const std::vector<Mat_<_Tp> >& vec);
        -:  339:    template<typename _Tp> _OutputArray(const Mat_<_Tp>& m);
        -:  340:    template<typename _Tp> _OutputArray(const _Tp* vec, int n);
        -:  341:    template<typename _Tp, int m, int n> _OutputArray(const Matx<_Tp, m, n>& matx);
        -:  342:    _OutputArray(const UMat& m);
        -:  343:    _OutputArray(const std::vector<UMat>& vec);
        -:  344:
        -:  345:    template<typename _Tp, std::size_t _Nm> _OutputArray(std::array<_Tp, _Nm>& arr);
        -:  346:    template<typename _Tp, std::size_t _Nm> _OutputArray(const std::array<_Tp, _Nm>& arr);
        -:  347:    template<std::size_t _Nm> _OutputArray(std::array<Mat, _Nm>& arr);
        -:  348:    template<std::size_t _Nm> _OutputArray(const std::array<Mat, _Nm>& arr);
        -:  349:
        -:  350:    template<typename _Tp> static _OutputArray rawOut(std::vector<_Tp>& vec);
        -:  351:    template<typename _Tp, std::size_t _Nm> static _OutputArray rawOut(std::array<_Tp, _Nm>& arr);
        -:  352:
        -:  353:    bool fixedSize() const;
        -:  354:    bool fixedType() const;
        -:  355:    bool needed() const;
        -:  356:    Mat& getMatRef(int i=-1) const;
        -:  357:    UMat& getUMatRef(int i=-1) const;
        -:  358:    cuda::GpuMat& getGpuMatRef() const;
        -:  359:    std::vector<cuda::GpuMat>& getGpuMatVecRef() const;
        -:  360:    ogl::Buffer& getOGlBufferRef() const;
        -:  361:    cuda::HostMem& getHostMemRef() const;
        -:  362:    void create(Size sz, int type, int i=-1, bool allowTransposed=false, _OutputArray::DepthMask fixedDepthMask=static_cast<_OutputArray::DepthMask>(0)) const;
        -:  363:    void create(int rows, int cols, int type, int i=-1, bool allowTransposed=false, _OutputArray::DepthMask fixedDepthMask=static_cast<_OutputArray::DepthMask>(0)) const;
        -:  364:    void create(int dims, const int* size, int type, int i=-1, bool allowTransposed=false, _OutputArray::DepthMask fixedDepthMask=static_cast<_OutputArray::DepthMask>(0)) const;
        -:  365:    void createSameSize(const _InputArray& arr, int mtype) const;
        -:  366:    void release() const;
        -:  367:    void clear() const;
        -:  368:    void setTo(const _InputArray& value, const _InputArray & mask = _InputArray()) const;
        -:  369:
        -:  370:    void assign(const UMat& u) const;
        -:  371:    void assign(const Mat& m) const;
        -:  372:
        -:  373:    void assign(const std::vector<UMat>& v) const;
        -:  374:    void assign(const std::vector<Mat>& v) const;
        -:  375:
        -:  376:    void move(UMat& u) const;
        -:  377:    void move(Mat& m) const;
        -:  378:};
        -:  379:
        -:  380:
        -:  381:class CV_EXPORTS _InputOutputArray : public _OutputArray
        -:  382:{
        -:  383:public:
        -:  384:    _InputOutputArray();
        -:  385:    _InputOutputArray(int _flags, void* _obj);
        -:  386:    _InputOutputArray(Mat& m);
        -:  387:    _InputOutputArray(std::vector<Mat>& vec);
        -:  388:    _InputOutputArray(cuda::GpuMat& d_mat);
        -:  389:    _InputOutputArray(ogl::Buffer& buf);
        -:  390:    _InputOutputArray(cuda::HostMem& cuda_mem);
        -:  391:    template<typename _Tp> _InputOutputArray(cudev::GpuMat_<_Tp>& m);
        -:  392:    template<typename _Tp> _InputOutputArray(std::vector<_Tp>& vec);
        -:  393:    _InputOutputArray(std::vector<bool>& vec) = delete;  // not supported
        -:  394:    template<typename _Tp> _InputOutputArray(std::vector<std::vector<_Tp> >& vec);
        -:  395:    template<typename _Tp> _InputOutputArray(std::vector<Mat_<_Tp> >& vec);
        -:  396:    template<typename _Tp> _InputOutputArray(Mat_<_Tp>& m);
        -:  397:    template<typename _Tp> _InputOutputArray(_Tp* vec, int n);
        -:  398:    template<typename _Tp, int m, int n> _InputOutputArray(Matx<_Tp, m, n>& matx);
        -:  399:    _InputOutputArray(UMat& m);
        -:  400:    _InputOutputArray(std::vector<UMat>& vec);
        -:  401:
        -:  402:    _InputOutputArray(const Mat& m);
        -:  403:    _InputOutputArray(const std::vector<Mat>& vec);
        -:  404:    _InputOutputArray(const cuda::GpuMat& d_mat);
        -:  405:    _InputOutputArray(const std::vector<cuda::GpuMat>& d_mat);
        -:  406:    _InputOutputArray(const ogl::Buffer& buf);
        -:  407:    _InputOutputArray(const cuda::HostMem& cuda_mem);
        -:  408:    template<typename _Tp> _InputOutputArray(const cudev::GpuMat_<_Tp>& m);
        -:  409:    template<typename _Tp> _InputOutputArray(const std::vector<_Tp>& vec);
        -:  410:    template<typename _Tp> _InputOutputArray(const std::vector<std::vector<_Tp> >& vec);
        -:  411:    template<typename _Tp> _InputOutputArray(const std::vector<Mat_<_Tp> >& vec);
        -:  412:    template<typename _Tp> _InputOutputArray(const Mat_<_Tp>& m);
        -:  413:    template<typename _Tp> _InputOutputArray(const _Tp* vec, int n);
        -:  414:    template<typename _Tp, int m, int n> _InputOutputArray(const Matx<_Tp, m, n>& matx);
        -:  415:    _InputOutputArray(const UMat& m);
        -:  416:    _InputOutputArray(const std::vector<UMat>& vec);
        -:  417:
        -:  418:    template<typename _Tp, std::size_t _Nm> _InputOutputArray(std::array<_Tp, _Nm>& arr);
        -:  419:    template<typename _Tp, std::size_t _Nm> _InputOutputArray(const std::array<_Tp, _Nm>& arr);
        -:  420:    template<std::size_t _Nm> _InputOutputArray(std::array<Mat, _Nm>& arr);
        -:  421:    template<std::size_t _Nm> _InputOutputArray(const std::array<Mat, _Nm>& arr);
        -:  422:
        -:  423:    template<typename _Tp> static _InputOutputArray rawInOut(std::vector<_Tp>& vec);
        -:  424:    template<typename _Tp, std::size_t _Nm> _InputOutputArray rawInOut(std::array<_Tp, _Nm>& arr);
        -:  425:
        -:  426:};
        -:  427:
        -:  428:/** Helper to wrap custom types. @see InputArray */
        -:  429:template<typename _Tp> static inline _InputArray rawIn(_Tp& v);
        -:  430:/** Helper to wrap custom types. @see InputArray */
        -:  431:template<typename _Tp> static inline _OutputArray rawOut(_Tp& v);
        -:  432:/** Helper to wrap custom types. @see InputArray */
        -:  433:template<typename _Tp> static inline _InputOutputArray rawInOut(_Tp& v);
        -:  434:
        -:  435:CV__DEBUG_NS_END
        -:  436:
        -:  437:typedef const _InputArray& InputArray;
        -:  438:typedef InputArray InputArrayOfArrays;
        -:  439:typedef const _OutputArray& OutputArray;
        -:  440:typedef OutputArray OutputArrayOfArrays;
        -:  441:typedef const _InputOutputArray& InputOutputArray;
        -:  442:typedef InputOutputArray InputOutputArrayOfArrays;
        -:  443:
        -:  444:CV_EXPORTS InputOutputArray noArray();
        -:  445:
        -:  446://///////////////////////////////// MatAllocator //////////////////////////////////////
        -:  447:
        -:  448://! Usage flags for allocator
        -:  449:enum UMatUsageFlags
        -:  450:{
        -:  451:    USAGE_DEFAULT = 0,
        -:  452:
        -:  453:    // buffer allocation policy is platform and usage specific
        -:  454:    USAGE_ALLOCATE_HOST_MEMORY = 1 << 0,
        -:  455:    USAGE_ALLOCATE_DEVICE_MEMORY = 1 << 1,
        -:  456:    USAGE_ALLOCATE_SHARED_MEMORY = 1 << 2, // It is not equal to: USAGE_ALLOCATE_HOST_MEMORY | USAGE_ALLOCATE_DEVICE_MEMORY
        -:  457:
        -:  458:    __UMAT_USAGE_FLAGS_32BIT = 0x7fffffff // Binary compatibility hint
        -:  459:};
        -:  460:
        -:  461:struct CV_EXPORTS UMatData;
        -:  462:
        -:  463:/** @brief  Custom array allocator
        -:  464:*/
        -:  465:class CV_EXPORTS MatAllocator
        -:  466:{
        -:  467:public:
        -:  468:    MatAllocator() {}
        -:  469:    virtual ~MatAllocator() {}
        -:  470:
        -:  471:    // let's comment it off for now to detect and fix all the uses of allocator
        -:  472:    //virtual void allocate(int dims, const int* sizes, int type, int*& refcount,
        -:  473:    //                      uchar*& datastart, uchar*& data, size_t* step) = 0;
        -:  474:    //virtual void deallocate(int* refcount, uchar* datastart, uchar* data) = 0;
        -:  475:    virtual UMatData* allocate(int dims, const int* sizes, int type,
        -:  476:                               void* data, size_t* step, AccessFlag flags, UMatUsageFlags usageFlags) const = 0;
        -:  477:    virtual bool allocate(UMatData* data, AccessFlag accessflags, UMatUsageFlags usageFlags) const = 0;
        -:  478:    virtual void deallocate(UMatData* data) const = 0;
        -:  479:    virtual void map(UMatData* data, AccessFlag accessflags) const;
        -:  480:    virtual void unmap(UMatData* data) const;
        -:  481:    virtual void download(UMatData* data, void* dst, int dims, const size_t sz[],
        -:  482:                          const size_t srcofs[], const size_t srcstep[],
        -:  483:                          const size_t dststep[]) const;
        -:  484:    virtual void upload(UMatData* data, const void* src, int dims, const size_t sz[],
        -:  485:                        const size_t dstofs[], const size_t dststep[],
        -:  486:                        const size_t srcstep[]) const;
        -:  487:    virtual void copy(UMatData* srcdata, UMatData* dstdata, int dims, const size_t sz[],
        -:  488:                      const size_t srcofs[], const size_t srcstep[],
        -:  489:                      const size_t dstofs[], const size_t dststep[], bool sync) const;
        -:  490:
        -:  491:    // default implementation returns DummyBufferPoolController
        -:  492:    virtual BufferPoolController* getBufferPoolController(const char* id = NULL) const;
        -:  493:};
        -:  494:
        -:  495:
        -:  496://////////////////////////////// MatCommaInitializer //////////////////////////////////
        -:  497:
        -:  498:/** @brief  Comma-separated Matrix Initializer
        -:  499:
        -:  500: The class instances are usually not created explicitly.
        -:  501: Instead, they are created on "matrix << firstValue" operator.
        -:  502:
        -:  503: The sample below initializes 2x2 rotation matrix:
        -:  504:
        -:  505: \code
        -:  506: double angle = 30, a = cos(angle*CV_PI/180), b = sin(angle*CV_PI/180);
        -:  507: Mat R = (Mat_<double>(2,2) << a, -b, b, a);
        -:  508: \endcode
        -:  509:*/
        -:  510:template<typename _Tp> class MatCommaInitializer_
        -:  511:{
        -:  512:public:
        -:  513:    //! the constructor, created by "matrix << firstValue" operator, where matrix is cv::Mat
        -:  514:    MatCommaInitializer_(Mat_<_Tp>* _m);
        -:  515:    //! the operator that takes the next value and put it to the matrix
        -:  516:    template<typename T2> MatCommaInitializer_<_Tp>& operator , (T2 v);
        -:  517:    //! another form of conversion operator
        -:  518:    operator Mat_<_Tp>() const;
        -:  519:protected:
        -:  520:    MatIterator_<_Tp> it;
        -:  521:};
        -:  522:
        -:  523:
        -:  524://///////////////////////////////////// Mat ///////////////////////////////////////////
        -:  525:
        -:  526:// note that umatdata might be allocated together
        -:  527:// with the matrix data, not as a separate object.
        -:  528:// therefore, it does not have constructor or destructor;
        -:  529:// it should be explicitly initialized using init().
        -:  530:struct CV_EXPORTS UMatData
        -:  531:{
        -:  532:    enum MemoryFlag { COPY_ON_MAP=1, HOST_COPY_OBSOLETE=2,
        -:  533:        DEVICE_COPY_OBSOLETE=4, TEMP_UMAT=8, TEMP_COPIED_UMAT=24,
        -:  534:        USER_ALLOCATED=32, DEVICE_MEM_MAPPED=64,
        -:  535:        ASYNC_CLEANUP=128
        -:  536:    };
        -:  537:    UMatData(const MatAllocator* allocator);
        -:  538:    ~UMatData();
        -:  539:
        -:  540:    // provide atomic access to the structure
        -:  541:    void lock();
        -:  542:    void unlock();
        -:  543:
        -:  544:    bool hostCopyObsolete() const;
        -:  545:    bool deviceCopyObsolete() const;
        -:  546:    bool deviceMemMapped() const;
        -:  547:    bool copyOnMap() const;
        -:  548:    bool tempUMat() const;
        -:  549:    bool tempCopiedUMat() const;
        -:  550:    void markHostCopyObsolete(bool flag);
        -:  551:    void markDeviceCopyObsolete(bool flag);
        -:  552:    void markDeviceMemMapped(bool flag);
        -:  553:
        -:  554:    const MatAllocator* prevAllocator;
        -:  555:    const MatAllocator* currAllocator;
        -:  556:    int urefcount;
        -:  557:    int refcount;
        -:  558:    uchar* data;
        -:  559:    uchar* origdata;
        -:  560:    size_t size;
        -:  561:
        -:  562:    UMatData::MemoryFlag flags;
        -:  563:    void* handle;
        -:  564:    void* userdata;
        -:  565:    int allocatorFlags_;
        -:  566:    int mapcount;
        -:  567:    UMatData* originalUMatData;
        -:  568:};
        -:  569:CV_ENUM_FLAGS(UMatData::MemoryFlag)
        -:  570:
        -:  571:
        -:  572:struct CV_EXPORTS MatSize
        -:  573:{
        -:  574:    explicit MatSize(int* _p);
        -:  575:    int dims() const;
        -:  576:    Size operator()() const;
        -:  577:    const int& operator[](int i) const;
        -:  578:    int& operator[](int i);
        -:  579:    operator const int*() const;  // TODO OpenCV 4.0: drop this
        -:  580:    bool operator == (const MatSize& sz) const;
        -:  581:    bool operator != (const MatSize& sz) const;
        -:  582:
        -:  583:    int* p;
        -:  584:};
        -:  585:
        -:  586:struct CV_EXPORTS MatStep
        -:  587:{
        -:  588:    MatStep();
        -:  589:    explicit MatStep(size_t s);
        -:  590:    const size_t& operator[](int i) const;
        -:  591:    size_t& operator[](int i);
        -:  592:    operator size_t() const;
        -:  593:    MatStep& operator = (size_t s);
        -:  594:
        -:  595:    size_t* p;
        -:  596:    size_t buf[2];
        -:  597:protected:
        -:  598:    MatStep& operator = (const MatStep&);
        -:  599:};
        -:  600:
        -:  601:/** @example samples/cpp/cout_mat.cpp
        -:  602:An example demonstrating the serial out capabilities of cv::Mat
        -:  603:*/
        -:  604:
        -:  605: /** @brief n-dimensional dense array class \anchor CVMat_Details
        -:  606:
        -:  607:The class Mat represents an n-dimensional dense numerical single-channel or multi-channel array. It
        -:  608:can be used to store real or complex-valued vectors and matrices, grayscale or color images, voxel
        -:  609:volumes, vector fields, point clouds, tensors, histograms (though, very high-dimensional histograms
        -:  610:may be better stored in a SparseMat ). The data layout of the array `M` is defined by the array
        -:  611:`M.step[]`, so that the address of element \f$(i_0,...,i_{M.dims-1})\f$, where \f$0\leq i_k<M.size[k]\f$, is
        -:  612:computed as:
        -:  613:\f[addr(M_{i_0,...,i_{M.dims-1}}) = M.data + M.step[0]*i_0 + M.step[1]*i_1 + ... + M.step[M.dims-1]*i_{M.dims-1}\f]
        -:  614:In case of a 2-dimensional array, the above formula is reduced to:
        -:  615:\f[addr(M_{i,j}) = M.data + M.step[0]*i + M.step[1]*j\f]
        -:  616:Note that `M.step[i] >= M.step[i+1]` (in fact, `M.step[i] >= M.step[i+1]*M.size[i+1]` ). This means
        -:  617:that 2-dimensional matrices are stored row-by-row, 3-dimensional matrices are stored plane-by-plane,
        -:  618:and so on. M.step[M.dims-1] is minimal and always equal to the element size M.elemSize() .
        -:  619:
        -:  620:So, the data layout in Mat is compatible with the majority of dense array types from the standard
        -:  621:toolkits and SDKs, such as Numpy (ndarray), Win32 (independent device bitmaps), and others,
        -:  622:that is, with any array that uses *steps* (or *strides*) to compute the position of a pixel.
        -:  623:Due to this compatibility, it is possible to make a Mat header for user-allocated data and process
        -:  624:it in-place using OpenCV functions.
        -:  625:
        -:  626:There are many different ways to create a Mat object. The most popular options are listed below:
        -:  627:
        -:  628:- Use the create(nrows, ncols, type) method or the similar Mat(nrows, ncols, type[, fillValue])
        -:  629:constructor. A new array of the specified size and type is allocated. type has the same meaning as
        -:  630:in the cvCreateMat method. For example, CV_8UC1 means a 8-bit single-channel array, CV_32FC2
        -:  631:means a 2-channel (complex) floating-point array, and so on.
        -:  632:@code
        -:  633:    // make a 7x7 complex matrix filled with 1+3j.
        -:  634:    Mat M(7,7,CV_32FC2,Scalar(1,3));
        -:  635:    // and now turn M to a 100x60 15-channel 8-bit matrix.
        -:  636:    // The old content will be deallocated
        -:  637:    M.create(100,60,CV_8UC(15));
        -:  638:@endcode
        -:  639:As noted in the introduction to this chapter, create() allocates only a new array when the shape
        -:  640:or type of the current array are different from the specified ones.
        -:  641:
        -:  642:- Create a multi-dimensional array:
        -:  643:@code
        -:  644:    // create a 100x100x100 8-bit array
        -:  645:    int sz[] = {100, 100, 100};
        -:  646:    Mat bigCube(3, sz, CV_8U, Scalar::all(0));
        -:  647:@endcode
        -:  648:It passes the number of dimensions =1 to the Mat constructor but the created array will be
        -:  649:2-dimensional with the number of columns set to 1. So, Mat::dims is always \>= 2 (can also be 0
        -:  650:when the array is empty).
        -:  651:
        -:  652:- Use a copy constructor or assignment operator where there can be an array or expression on the
        -:  653:right side (see below). As noted in the introduction, the array assignment is an O(1) operation
        -:  654:because it only copies the header and increases the reference counter. The Mat::clone() method can
        -:  655:be used to get a full (deep) copy of the array when you need it.
        -:  656:
        -:  657:- Construct a header for a part of another array. It can be a single row, single column, several
        -:  658:rows, several columns, rectangular region in the array (called a *minor* in algebra) or a
        -:  659:diagonal. Such operations are also O(1) because the new header references the same data. You can
        -:  660:actually modify a part of the array using this feature, for example:
        -:  661:@code
        -:  662:    // add the 5-th row, multiplied by 3 to the 3rd row
        -:  663:    M.row(3) = M.row(3) + M.row(5)*3;
        -:  664:    // now copy the 7-th column to the 1-st column
        -:  665:    // M.col(1) = M.col(7); // this will not work
        -:  666:    Mat M1 = M.col(1);
        -:  667:    M.col(7).copyTo(M1);
        -:  668:    // create a new 320x240 image
        -:  669:    Mat img(Size(320,240),CV_8UC3);
        -:  670:    // select a ROI
        -:  671:    Mat roi(img, Rect(10,10,100,100));
        -:  672:    // fill the ROI with (0,255,0) (which is green in RGB space);
        -:  673:    // the original 320x240 image will be modified
        -:  674:    roi = Scalar(0,255,0);
        -:  675:@endcode
        -:  676:Due to the additional datastart and dataend members, it is possible to compute a relative
        -:  677:sub-array position in the main *container* array using locateROI():
        -:  678:@code
        -:  679:    Mat A = Mat::eye(10, 10, CV_32S);
        -:  680:    // extracts A columns, 1 (inclusive) to 3 (exclusive).
        -:  681:    Mat B = A(Range::all(), Range(1, 3));
        -:  682:    // extracts B rows, 5 (inclusive) to 9 (exclusive).
        -:  683:    // that is, C \~ A(Range(5, 9), Range(1, 3))
        -:  684:    Mat C = B(Range(5, 9), Range::all());
        -:  685:    Size size; Point ofs;
        -:  686:    C.locateROI(size, ofs);
        -:  687:    // size will be (width=10,height=10) and the ofs will be (x=1, y=5)
        -:  688:@endcode
        -:  689:As in case of whole matrices, if you need a deep copy, use the `clone()` method of the extracted
        -:  690:sub-matrices.
        -:  691:
        -:  692:- Make a header for user-allocated data. It can be useful to do the following:
        -:  693:    -# Process "foreign" data using OpenCV (for example, when you implement a DirectShow\* filter or
        -:  694:    a processing module for gstreamer, and so on). For example:
        -:  695:    @code
        -:  696:        void process_video_frame(const unsigned char* pixels,
        -:  697:                                 int width, int height, int step)
        -:  698:        {
        -:  699:            Mat img(height, width, CV_8UC3, pixels, step);
        -:  700:            GaussianBlur(img, img, Size(7,7), 1.5, 1.5);
        -:  701:        }
        -:  702:    @endcode
        -:  703:    -# Quickly initialize small matrices and/or get a super-fast element access.
        -:  704:    @code
        -:  705:        double m[3][3] = {{a, b, c}, {d, e, f}, {g, h, i}};
        -:  706:        Mat M = Mat(3, 3, CV_64F, m).inv();
        -:  707:    @endcode
        -:  708:    .
        -:  709:
        -:  710:- Use MATLAB-style array initializers, zeros(), ones(), eye(), for example:
        -:  711:@code
        -:  712:    // create a double-precision identity matrix and add it to M.
        -:  713:    M += Mat::eye(M.rows, M.cols, CV_64F);
        -:  714:@endcode
        -:  715:
        -:  716:- Use a comma-separated initializer:
        -:  717:@code
        -:  718:    // create a 3x3 double-precision identity matrix
        -:  719:    Mat M = (Mat_<double>(3,3) << 1, 0, 0, 0, 1, 0, 0, 0, 1);
        -:  720:@endcode
        -:  721:With this approach, you first call a constructor of the Mat class with the proper parameters, and
        -:  722:then you just put `<< operator` followed by comma-separated values that can be constants,
        -:  723:variables, expressions, and so on. Also, note the extra parentheses required to avoid compilation
        -:  724:errors.
        -:  725:
        -:  726:Once the array is created, it is automatically managed via a reference-counting mechanism. If the
        -:  727:array header is built on top of user-allocated data, you should handle the data by yourself. The
        -:  728:array data is deallocated when no one points to it. If you want to release the data pointed by a
        -:  729:array header before the array destructor is called, use Mat::release().
        -:  730:
        -:  731:The next important thing to learn about the array class is element access. This manual already
        -:  732:described how to compute an address of each array element. Normally, you are not required to use the
        -:  733:formula directly in the code. If you know the array element type (which can be retrieved using the
        -:  734:method Mat::type() ), you can access the element \f$M_{ij}\f$ of a 2-dimensional array as:
        -:  735:@code
        -:  736:    M.at<double>(i,j) += 1.f;
        -:  737:@endcode
        -:  738:assuming that `M` is a double-precision floating-point array. There are several variants of the method
        -:  739:at for a different number of dimensions.
        -:  740:
        -:  741:If you need to process a whole row of a 2D array, the most efficient way is to get the pointer to
        -:  742:the row first, and then just use the plain C operator [] :
        -:  743:@code
        -:  744:    // compute sum of positive matrix elements
        -:  745:    // (assuming that M is a double-precision matrix)
        -:  746:    double sum=0;
        -:  747:    for(int i = 0; i < M.rows; i++)
        -:  748:    {
        -:  749:        const double* Mi = M.ptr<double>(i);
        -:  750:        for(int j = 0; j < M.cols; j++)
        -:  751:            sum += std::max(Mi[j], 0.);
        -:  752:    }
        -:  753:@endcode
        -:  754:Some operations, like the one above, do not actually depend on the array shape. They just process
        -:  755:elements of an array one by one (or elements from multiple arrays that have the same coordinates,
        -:  756:for example, array addition). Such operations are called *element-wise*. It makes sense to check
        -:  757:whether all the input/output arrays are continuous, namely, have no gaps at the end of each row. If
        -:  758:yes, process them as a long single row:
        -:  759:@code
        -:  760:    // compute the sum of positive matrix elements, optimized variant
        -:  761:    double sum=0;
        -:  762:    int cols = M.cols, rows = M.rows;
        -:  763:    if(M.isContinuous())
        -:  764:    {
        -:  765:        cols *= rows;
        -:  766:        rows = 1;
        -:  767:    }
        -:  768:    for(int i = 0; i < rows; i++)
        -:  769:    {
        -:  770:        const double* Mi = M.ptr<double>(i);
        -:  771:        for(int j = 0; j < cols; j++)
        -:  772:            sum += std::max(Mi[j], 0.);
        -:  773:    }
        -:  774:@endcode
        -:  775:In case of the continuous matrix, the outer loop body is executed just once. So, the overhead is
        -:  776:smaller, which is especially noticeable in case of small matrices.
        -:  777:
        -:  778:Finally, there are STL-style iterators that are smart enough to skip gaps between successive rows:
        -:  779:@code
        -:  780:    // compute sum of positive matrix elements, iterator-based variant
        -:  781:    double sum=0;
        -:  782:    MatConstIterator_<double> it = M.begin<double>(), it_end = M.end<double>();
        -:  783:    for(; it != it_end; ++it)
        -:  784:        sum += std::max(*it, 0.);
        -:  785:@endcode
        -:  786:The matrix iterators are random-access iterators, so they can be passed to any STL algorithm,
        -:  787:including std::sort().
        -:  788:
        -:  789:@note Matrix Expressions and arithmetic see MatExpr
        -:  790:*/
        -:  791:class CV_EXPORTS Mat
        -:  792:{
        -:  793:public:
        -:  794:    /**
        -:  795:    These are various constructors that form a matrix. As noted in the AutomaticAllocation, often
        -:  796:    the default constructor is enough, and the proper matrix will be allocated by an OpenCV function.
        -:  797:    The constructed matrix can further be assigned to another matrix or matrix expression or can be
        -:  798:    allocated with Mat::create . In the former case, the old content is de-referenced.
        -:  799:     */
        -:  800:    Mat();
        -:  801:
        -:  802:    /** @overload
        -:  803:    @param rows Number of rows in a 2D array.
        -:  804:    @param cols Number of columns in a 2D array.
        -:  805:    @param type Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or
        -:  806:    CV_8UC(n), ..., CV_64FC(n) to create multi-channel (up to CV_CN_MAX channels) matrices.
        -:  807:    */
        -:  808:    Mat(int rows, int cols, int type);
        -:  809:
        -:  810:    /** @overload
        -:  811:    @param size 2D array size: Size(cols, rows) . In the Size() constructor, the number of rows and the
        -:  812:    number of columns go in the reverse order.
        -:  813:    @param type Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or
        -:  814:    CV_8UC(n), ..., CV_64FC(n) to create multi-channel (up to CV_CN_MAX channels) matrices.
        -:  815:      */
        -:  816:    Mat(Size size, int type);
        -:  817:
        -:  818:    /** @overload
        -:  819:    @param rows Number of rows in a 2D array.
        -:  820:    @param cols Number of columns in a 2D array.
        -:  821:    @param type Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or
        -:  822:    CV_8UC(n), ..., CV_64FC(n) to create multi-channel (up to CV_CN_MAX channels) matrices.
        -:  823:    @param s An optional value to initialize each matrix element with. To set all the matrix elements to
        -:  824:    the particular value after the construction, use the assignment operator
        -:  825:    Mat::operator=(const Scalar& value) .
        -:  826:    */
        -:  827:    Mat(int rows, int cols, int type, const Scalar& s);
        -:  828:
        -:  829:    /** @overload
        -:  830:    @param size 2D array size: Size(cols, rows) . In the Size() constructor, the number of rows and the
        -:  831:    number of columns go in the reverse order.
        -:  832:    @param type Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or
        -:  833:    CV_8UC(n), ..., CV_64FC(n) to create multi-channel (up to CV_CN_MAX channels) matrices.
        -:  834:    @param s An optional value to initialize each matrix element with. To set all the matrix elements to
        -:  835:    the particular value after the construction, use the assignment operator
        -:  836:    Mat::operator=(const Scalar& value) .
        -:  837:      */
        -:  838:    Mat(Size size, int type, const Scalar& s);
        -:  839:
        -:  840:    /** @overload
        -:  841:    @param ndims Array dimensionality.
        -:  842:    @param sizes Array of integers specifying an n-dimensional array shape.
        -:  843:    @param type Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or
        -:  844:    CV_8UC(n), ..., CV_64FC(n) to create multi-channel (up to CV_CN_MAX channels) matrices.
        -:  845:    */
        -:  846:    Mat(int ndims, const int* sizes, int type);
        -:  847:
        -:  848:    /** @overload
        -:  849:    @param sizes Array of integers specifying an n-dimensional array shape.
        -:  850:    @param type Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or
        -:  851:    CV_8UC(n), ..., CV_64FC(n) to create multi-channel (up to CV_CN_MAX channels) matrices.
        -:  852:    */
        -:  853:    Mat(const std::vector<int>& sizes, int type);
        -:  854:
        -:  855:    /** @overload
        -:  856:    @param ndims Array dimensionality.
        -:  857:    @param sizes Array of integers specifying an n-dimensional array shape.
        -:  858:    @param type Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or
        -:  859:    CV_8UC(n), ..., CV_64FC(n) to create multi-channel (up to CV_CN_MAX channels) matrices.
        -:  860:    @param s An optional value to initialize each matrix element with. To set all the matrix elements to
        -:  861:    the particular value after the construction, use the assignment operator
        -:  862:    Mat::operator=(const Scalar& value) .
        -:  863:    */
        -:  864:    Mat(int ndims, const int* sizes, int type, const Scalar& s);
        -:  865:
        -:  866:    /** @overload
        -:  867:    @param sizes Array of integers specifying an n-dimensional array shape.
        -:  868:    @param type Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or
        -:  869:    CV_8UC(n), ..., CV_64FC(n) to create multi-channel (up to CV_CN_MAX channels) matrices.
        -:  870:    @param s An optional value to initialize each matrix element with. To set all the matrix elements to
        -:  871:    the particular value after the construction, use the assignment operator
        -:  872:    Mat::operator=(const Scalar& value) .
        -:  873:    */
        -:  874:    Mat(const std::vector<int>& sizes, int type, const Scalar& s);
        -:  875:
        -:  876:
        -:  877:    /** @overload
        -:  878:    @param m Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied
        -:  879:    by these constructors. Instead, the header pointing to m data or its sub-array is constructed and
        -:  880:    associated with it. The reference counter, if any, is incremented. So, when you modify the matrix
        -:  881:    formed using such a constructor, you also modify the corresponding elements of m . If you want to
        -:  882:    have an independent copy of the sub-array, use Mat::clone() .
        -:  883:    */
        -:  884:    Mat(const Mat& m);
        -:  885:
        -:  886:    /** @overload
        -:  887:    @param rows Number of rows in a 2D array.
        -:  888:    @param cols Number of columns in a 2D array.
        -:  889:    @param type Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or
        -:  890:    CV_8UC(n), ..., CV_64FC(n) to create multi-channel (up to CV_CN_MAX channels) matrices.
        -:  891:    @param data Pointer to the user data. Matrix constructors that take data and step parameters do not
        -:  892:    allocate matrix data. Instead, they just initialize the matrix header that points to the specified
        -:  893:    data, which means that no data is copied. This operation is very efficient and can be used to
        -:  894:    process external data using OpenCV functions. The external data is not automatically deallocated, so
        -:  895:    you should take care of it.
        -:  896:    @param step Number of bytes each matrix row occupies. The value should include the padding bytes at
        -:  897:    the end of each row, if any. If the parameter is missing (set to AUTO_STEP ), no padding is assumed
        -:  898:    and the actual step is calculated as cols*elemSize(). See Mat::elemSize.
        -:  899:    */
        -:  900:    Mat(int rows, int cols, int type, void* data, size_t step=AUTO_STEP);
        -:  901:
        -:  902:    /** @overload
        -:  903:    @param size 2D array size: Size(cols, rows) . In the Size() constructor, the number of rows and the
        -:  904:    number of columns go in the reverse order.
        -:  905:    @param type Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or
        -:  906:    CV_8UC(n), ..., CV_64FC(n) to create multi-channel (up to CV_CN_MAX channels) matrices.
        -:  907:    @param data Pointer to the user data. Matrix constructors that take data and step parameters do not
        -:  908:    allocate matrix data. Instead, they just initialize the matrix header that points to the specified
        -:  909:    data, which means that no data is copied. This operation is very efficient and can be used to
        -:  910:    process external data using OpenCV functions. The external data is not automatically deallocated, so
        -:  911:    you should take care of it.
        -:  912:    @param step Number of bytes each matrix row occupies. The value should include the padding bytes at
        -:  913:    the end of each row, if any. If the parameter is missing (set to AUTO_STEP ), no padding is assumed
        -:  914:    and the actual step is calculated as cols*elemSize(). See Mat::elemSize.
        -:  915:    */
        -:  916:    Mat(Size size, int type, void* data, size_t step=AUTO_STEP);
        -:  917:
        -:  918:    /** @overload
        -:  919:    @param ndims Array dimensionality.
        -:  920:    @param sizes Array of integers specifying an n-dimensional array shape.
        -:  921:    @param type Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or
        -:  922:    CV_8UC(n), ..., CV_64FC(n) to create multi-channel (up to CV_CN_MAX channels) matrices.
        -:  923:    @param data Pointer to the user data. Matrix constructors that take data and step parameters do not
        -:  924:    allocate matrix data. Instead, they just initialize the matrix header that points to the specified
        -:  925:    data, which means that no data is copied. This operation is very efficient and can be used to
        -:  926:    process external data using OpenCV functions. The external data is not automatically deallocated, so
        -:  927:    you should take care of it.
        -:  928:    @param steps Array of ndims-1 steps in case of a multi-dimensional array (the last step is always
        -:  929:    set to the element size). If not specified, the matrix is assumed to be continuous.
        -:  930:    */
        -:  931:    Mat(int ndims, const int* sizes, int type, void* data, const size_t* steps=0);
        -:  932:
        -:  933:    /** @overload
        -:  934:    @param sizes Array of integers specifying an n-dimensional array shape.
        -:  935:    @param type Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or
        -:  936:    CV_8UC(n), ..., CV_64FC(n) to create multi-channel (up to CV_CN_MAX channels) matrices.
        -:  937:    @param data Pointer to the user data. Matrix constructors that take data and step parameters do not
        -:  938:    allocate matrix data. Instead, they just initialize the matrix header that points to the specified
        -:  939:    data, which means that no data is copied. This operation is very efficient and can be used to
        -:  940:    process external data using OpenCV functions. The external data is not automatically deallocated, so
        -:  941:    you should take care of it.
        -:  942:    @param steps Array of ndims-1 steps in case of a multi-dimensional array (the last step is always
        -:  943:    set to the element size). If not specified, the matrix is assumed to be continuous.
        -:  944:    */
        -:  945:    Mat(const std::vector<int>& sizes, int type, void* data, const size_t* steps=0);
        -:  946:
        -:  947:    /** @overload
        -:  948:    @param m Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied
        -:  949:    by these constructors. Instead, the header pointing to m data or its sub-array is constructed and
        -:  950:    associated with it. The reference counter, if any, is incremented. So, when you modify the matrix
        -:  951:    formed using such a constructor, you also modify the corresponding elements of m . If you want to
        -:  952:    have an independent copy of the sub-array, use Mat::clone() .
        -:  953:    @param rowRange Range of the m rows to take. As usual, the range start is inclusive and the range
        -:  954:    end is exclusive. Use Range::all() to take all the rows.
        -:  955:    @param colRange Range of the m columns to take. Use Range::all() to take all the columns.
        -:  956:    */
        -:  957:    Mat(const Mat& m, const Range& rowRange, const Range& colRange=Range::all());
        -:  958:
        -:  959:    /** @overload
        -:  960:    @param m Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied
        -:  961:    by these constructors. Instead, the header pointing to m data or its sub-array is constructed and
        -:  962:    associated with it. The reference counter, if any, is incremented. So, when you modify the matrix
        -:  963:    formed using such a constructor, you also modify the corresponding elements of m . If you want to
        -:  964:    have an independent copy of the sub-array, use Mat::clone() .
        -:  965:    @param roi Region of interest.
        -:  966:    */
        -:  967:    Mat(const Mat& m, const Rect& roi);
        -:  968:
        -:  969:    /** @overload
        -:  970:    @param m Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied
        -:  971:    by these constructors. Instead, the header pointing to m data or its sub-array is constructed and
        -:  972:    associated with it. The reference counter, if any, is incremented. So, when you modify the matrix
        -:  973:    formed using such a constructor, you also modify the corresponding elements of m . If you want to
        -:  974:    have an independent copy of the sub-array, use Mat::clone() .
        -:  975:    @param ranges Array of selected ranges of m along each dimensionality.
        -:  976:    */
        -:  977:    Mat(const Mat& m, const Range* ranges);
        -:  978:
        -:  979:    /** @overload
        -:  980:    @param m Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied
        -:  981:    by these constructors. Instead, the header pointing to m data or its sub-array is constructed and
        -:  982:    associated with it. The reference counter, if any, is incremented. So, when you modify the matrix
        -:  983:    formed using such a constructor, you also modify the corresponding elements of m . If you want to
        -:  984:    have an independent copy of the sub-array, use Mat::clone() .
        -:  985:    @param ranges Array of selected ranges of m along each dimensionality.
        -:  986:    */
        -:  987:    Mat(const Mat& m, const std::vector<Range>& ranges);
        -:  988:
        -:  989:    /** @overload
        -:  990:    @param vec STL vector whose elements form the matrix. The matrix has a single column and the number
        -:  991:    of rows equal to the number of vector elements. Type of the matrix matches the type of vector
        -:  992:    elements. The constructor can handle arbitrary types, for which there is a properly declared
        -:  993:    DataType . This means that the vector elements must be primitive numbers or uni-type numerical
        -:  994:    tuples of numbers. Mixed-type structures are not supported. The corresponding constructor is
        -:  995:    explicit. Since STL vectors are not automatically converted to Mat instances, you should write
        -:  996:    Mat(vec) explicitly. Unless you copy the data into the matrix ( copyData=true ), no new elements
        -:  997:    will be added to the vector because it can potentially yield vector data reallocation, and, thus,
        -:  998:    the matrix data pointer will be invalid.
        -:  999:    @param copyData Flag to specify whether the underlying data of the STL vector should be copied
        -: 1000:    to (true) or shared with (false) the newly constructed matrix. When the data is copied, the
        -: 1001:    allocated buffer is managed using Mat reference counting mechanism. While the data is shared,
        -: 1002:    the reference counter is NULL, and you should not deallocate the data until the matrix is not
        -: 1003:    destructed.
        -: 1004:    */
        -: 1005:    template<typename _Tp> explicit Mat(const std::vector<_Tp>& vec, bool copyData=false);
        -: 1006:
        -: 1007:    /** @overload
        -: 1008:    */
        -: 1009:    template<typename _Tp, typename = typename std::enable_if<std::is_arithmetic<_Tp>::value>::type>
        -: 1010:    explicit Mat(const std::initializer_list<_Tp> list);
        -: 1011:
        -: 1012:    /** @overload
        -: 1013:    */
        -: 1014:    template<typename _Tp> explicit Mat(const std::initializer_list<int> sizes, const std::initializer_list<_Tp> list);
        -: 1015:
        -: 1016:    /** @overload
        -: 1017:    */
        -: 1018:    template<typename _Tp, size_t _Nm> explicit Mat(const std::array<_Tp, _Nm>& arr, bool copyData=false);
        -: 1019:
        -: 1020:    /** @overload
        -: 1021:    */
        -: 1022:    template<typename _Tp, int n> explicit Mat(const Vec<_Tp, n>& vec, bool copyData=true);
        -: 1023:
        -: 1024:    /** @overload
        -: 1025:    */
        -: 1026:    template<typename _Tp, int m, int n> explicit Mat(const Matx<_Tp, m, n>& mtx, bool copyData=true);
        -: 1027:
        -: 1028:    /** @overload
        -: 1029:    */
        -: 1030:    template<typename _Tp> explicit Mat(const Point_<_Tp>& pt, bool copyData=true);
        -: 1031:
        -: 1032:    /** @overload
        -: 1033:    */
        -: 1034:    template<typename _Tp> explicit Mat(const Point3_<_Tp>& pt, bool copyData=true);
        -: 1035:
        -: 1036:    /** @overload
        -: 1037:    */
        -: 1038:    template<typename _Tp> explicit Mat(const MatCommaInitializer_<_Tp>& commaInitializer);
        -: 1039:
        -: 1040:    //! download data from GpuMat
        -: 1041:    explicit Mat(const cuda::GpuMat& m);
        -: 1042:
        -: 1043:    //! destructor - calls release()
        -: 1044:    ~Mat();
        -: 1045:
        -: 1046:    /** @brief assignment operators
        -: 1047:
        -: 1048:    These are available assignment operators. Since they all are very different, make sure to read the
        -: 1049:    operator parameters description.
        -: 1050:    @param m Assigned, right-hand-side matrix. Matrix assignment is an O(1) operation. This means that
        -: 1051:    no data is copied but the data is shared and the reference counter, if any, is incremented. Before
        -: 1052:    assigning new data, the old data is de-referenced via Mat::release .
        -: 1053:     */
        -: 1054:    Mat& operator = (const Mat& m);
        -: 1055:
        -: 1056:    /** @overload
        -: 1057:    @param expr Assigned matrix expression object. As opposite to the first form of the assignment
        -: 1058:    operation, the second form can reuse already allocated matrix if it has the right size and type to
        -: 1059:    fit the matrix expression result. It is automatically handled by the real function that the matrix
        -: 1060:    expressions is expanded to. For example, C=A+B is expanded to add(A, B, C), and add takes care of
        -: 1061:    automatic C reallocation.
        -: 1062:    */
        -: 1063:    Mat& operator = (const MatExpr& expr);
        -: 1064:
        -: 1065:    //! retrieve UMat from Mat
        -: 1066:    UMat getUMat(AccessFlag accessFlags, UMatUsageFlags usageFlags = USAGE_DEFAULT) const;
        -: 1067:
        -: 1068:    /** @brief Creates a matrix header for the specified matrix row.
        -: 1069:
        -: 1070:    The method makes a new header for the specified matrix row and returns it. This is an O(1)
        -: 1071:    operation, regardless of the matrix size. The underlying data of the new matrix is shared with the
        -: 1072:    original matrix. Here is the example of one of the classical basic matrix processing operations,
        -: 1073:    axpy, used by LU and many other algorithms:
        -: 1074:    @code
        -: 1075:        inline void matrix_axpy(Mat& A, int i, int j, double alpha)
        -: 1076:        {
        -: 1077:            A.row(i) += A.row(j)*alpha;
        -: 1078:        }
        -: 1079:    @endcode
        -: 1080:    @note In the current implementation, the following code does not work as expected:
        -: 1081:    @code
        -: 1082:        Mat A;
        -: 1083:        ...
        -: 1084:        A.row(i) = A.row(j); // will not work
        -: 1085:    @endcode
        -: 1086:    This happens because A.row(i) forms a temporary header that is further assigned to another header.
        -: 1087:    Remember that each of these operations is O(1), that is, no data is copied. Thus, the above
        -: 1088:    assignment is not true if you may have expected the j-th row to be copied to the i-th row. To
        -: 1089:    achieve that, you should either turn this simple assignment into an expression or use the
        -: 1090:    Mat::copyTo method:
        -: 1091:    @code
        -: 1092:        Mat A;
        -: 1093:        ...
        -: 1094:        // works, but looks a bit obscure.
        -: 1095:        A.row(i) = A.row(j) + 0;
        -: 1096:        // this is a bit longer, but the recommended method.
        -: 1097:        A.row(j).copyTo(A.row(i));
        -: 1098:    @endcode
        -: 1099:    @param y A 0-based row index.
        -: 1100:     */
        -: 1101:    Mat row(int y) const;
        -: 1102:
        -: 1103:    /** @brief Creates a matrix header for the specified matrix column.
        -: 1104:
        -: 1105:    The method makes a new header for the specified matrix column and returns it. This is an O(1)
        -: 1106:    operation, regardless of the matrix size. The underlying data of the new matrix is shared with the
        -: 1107:    original matrix. See also the Mat::row description.
        -: 1108:    @param x A 0-based column index.
        -: 1109:     */
        -: 1110:    Mat col(int x) const;
        -: 1111:
        -: 1112:    /** @brief Creates a matrix header for the specified row span.
        -: 1113:
        -: 1114:    The method makes a new header for the specified row span of the matrix. Similarly to Mat::row and
        -: 1115:    Mat::col , this is an O(1) operation.
        -: 1116:    @param startrow An inclusive 0-based start index of the row span.
        -: 1117:    @param endrow An exclusive 0-based ending index of the row span.
        -: 1118:     */
        -: 1119:    Mat rowRange(int startrow, int endrow) const;
        -: 1120:
        -: 1121:    /** @overload
        -: 1122:    @param r Range structure containing both the start and the end indices.
        -: 1123:    */
        -: 1124:    Mat rowRange(const Range& r) const;
        -: 1125:
        -: 1126:    /** @brief Creates a matrix header for the specified column span.
        -: 1127:
        -: 1128:    The method makes a new header for the specified column span of the matrix. Similarly to Mat::row and
        -: 1129:    Mat::col , this is an O(1) operation.
        -: 1130:    @param startcol An inclusive 0-based start index of the column span.
        -: 1131:    @param endcol An exclusive 0-based ending index of the column span.
        -: 1132:     */
        -: 1133:    Mat colRange(int startcol, int endcol) const;
        -: 1134:
        -: 1135:    /** @overload
        -: 1136:    @param r Range structure containing both the start and the end indices.
        -: 1137:    */
        -: 1138:    Mat colRange(const Range& r) const;
        -: 1139:
        -: 1140:    /** @brief Extracts a diagonal from a matrix
        -: 1141:
        -: 1142:    The method makes a new header for the specified matrix diagonal. The new matrix is represented as a
        -: 1143:    single-column matrix. Similarly to Mat::row and Mat::col, this is an O(1) operation.
        -: 1144:    @param d index of the diagonal, with the following values:
        -: 1145:    - `d=0` is the main diagonal.
        -: 1146:    - `d<0` is a diagonal from the lower half. For example, d=-1 means the diagonal is set
        -: 1147:      immediately below the main one.
        -: 1148:    - `d>0` is a diagonal from the upper half. For example, d=1 means the diagonal is set
        -: 1149:      immediately above the main one.
        -: 1150:    For example:
        -: 1151:    @code
        -: 1152:        Mat m = (Mat_<int>(3,3) <<
        -: 1153:                    1,2,3,
        -: 1154:                    4,5,6,
        -: 1155:                    7,8,9);
        -: 1156:        Mat d0 = m.diag(0);
        -: 1157:        Mat d1 = m.diag(1);
        -: 1158:        Mat d_1 = m.diag(-1);
        -: 1159:    @endcode
        -: 1160:    The resulting matrices are
        -: 1161:    @code
        -: 1162:     d0 =
        -: 1163:       [1;
        -: 1164:        5;
        -: 1165:        9]
        -: 1166:     d1 =
        -: 1167:       [2;
        -: 1168:        6]
        -: 1169:     d_1 =
        -: 1170:       [4;
        -: 1171:        8]
        -: 1172:    @endcode
        -: 1173:     */
        -: 1174:    Mat diag(int d=0) const;
        -: 1175:
        -: 1176:    /** @brief creates a diagonal matrix
        -: 1177:
        -: 1178:    The method creates a square diagonal matrix from specified main diagonal.
        -: 1179:    @param d One-dimensional matrix that represents the main diagonal.
        -: 1180:     */
        -: 1181:    static Mat diag(const Mat& d);
        -: 1182:
        -: 1183:    /** @brief Creates a full copy of the array and the underlying data.
        -: 1184:
        -: 1185:    The method creates a full copy of the array. The original step[] is not taken into account. So, the
        -: 1186:    array copy is a continuous array occupying total()*elemSize() bytes.
        -: 1187:     */
        -: 1188:    Mat clone() const CV_NODISCARD;
        -: 1189:
        -: 1190:    /** @brief Copies the matrix to another one.
        -: 1191:
        -: 1192:    The method copies the matrix data to another matrix. Before copying the data, the method invokes :
        -: 1193:    @code
        -: 1194:        m.create(this->size(), this->type());
        -: 1195:    @endcode
        -: 1196:    so that the destination matrix is reallocated if needed. While m.copyTo(m); works flawlessly, the
        -: 1197:    function does not handle the case of a partial overlap between the source and the destination
        -: 1198:    matrices.
        -: 1199:
        -: 1200:    When the operation mask is specified, if the Mat::create call shown above reallocates the matrix,
        -: 1201:    the newly allocated matrix is initialized with all zeros before copying the data.
        -: 1202:    @param m Destination matrix. If it does not have a proper size or type before the operation, it is
        -: 1203:    reallocated.
        -: 1204:     */
        -: 1205:    void copyTo( OutputArray m ) const;
        -: 1206:
        -: 1207:    /** @overload
        -: 1208:    @param m Destination matrix. If it does not have a proper size or type before the operation, it is
        -: 1209:    reallocated.
        -: 1210:    @param mask Operation mask of the same size as \*this. Its non-zero elements indicate which matrix
        -: 1211:    elements need to be copied. The mask has to be of type CV_8U and can have 1 or multiple channels.
        -: 1212:    */
        -: 1213:    void copyTo( OutputArray m, InputArray mask ) const;
        -: 1214:
        -: 1215:    /** @brief Converts an array to another data type with optional scaling.
        -: 1216:
        -: 1217:    The method converts source pixel values to the target data type. saturate_cast\<\> is applied at
        -: 1218:    the end to avoid possible overflows:
        -: 1219:
        -: 1220:    \f[m(x,y) = saturate \_ cast<rType>( \alpha (*this)(x,y) +  \beta )\f]
        -: 1221:    @param m output matrix; if it does not have a proper size or type before the operation, it is
        -: 1222:    reallocated.
        -: 1223:    @param rtype desired output matrix type or, rather, the depth since the number of channels are the
        -: 1224:    same as the input has; if rtype is negative, the output matrix will have the same type as the input.
        -: 1225:    @param alpha optional scale factor.
        -: 1226:    @param beta optional delta added to the scaled values.
        -: 1227:     */
        -: 1228:    void convertTo( OutputArray m, int rtype, double alpha=1, double beta=0 ) const;
        -: 1229:
        -: 1230:    /** @brief Provides a functional form of convertTo.
        -: 1231:
        -: 1232:    This is an internally used method called by the @ref MatrixExpressions engine.
        -: 1233:    @param m Destination array.
        -: 1234:    @param type Desired destination array depth (or -1 if it should be the same as the source type).
        -: 1235:     */
        -: 1236:    void assignTo( Mat& m, int type=-1 ) const;
        -: 1237:
        -: 1238:    /** @brief Sets all or some of the array elements to the specified value.
        -: 1239:    @param s Assigned scalar converted to the actual array type.
        -: 1240:    */
        -: 1241:    Mat& operator = (const Scalar& s);
        -: 1242:
        -: 1243:    /** @brief Sets all or some of the array elements to the specified value.
        -: 1244:
        -: 1245:    This is an advanced variant of the Mat::operator=(const Scalar& s) operator.
        -: 1246:    @param value Assigned scalar converted to the actual array type.
        -: 1247:    @param mask Operation mask of the same size as \*this. Its non-zero elements indicate which matrix
        -: 1248:    elements need to be copied. The mask has to be of type CV_8U and can have 1 or multiple channels
        -: 1249:     */
        -: 1250:    Mat& setTo(InputArray value, InputArray mask=noArray());
        -: 1251:
        -: 1252:    /** @brief Changes the shape and/or the number of channels of a 2D matrix without copying the data.
        -: 1253:
        -: 1254:    The method makes a new matrix header for \*this elements. The new matrix may have a different size
        -: 1255:    and/or different number of channels. Any combination is possible if:
        -: 1256:    -   No extra elements are included into the new matrix and no elements are excluded. Consequently,
        -: 1257:        the product rows\*cols\*channels() must stay the same after the transformation.
        -: 1258:    -   No data is copied. That is, this is an O(1) operation. Consequently, if you change the number of
        -: 1259:        rows, or the operation changes the indices of elements row in some other way, the matrix must be
        -: 1260:        continuous. See Mat::isContinuous .
        -: 1261:
        -: 1262:    For example, if there is a set of 3D points stored as an STL vector, and you want to represent the
        -: 1263:    points as a 3xN matrix, do the following:
        -: 1264:    @code
        -: 1265:        std::vector<Point3f> vec;
        -: 1266:        ...
        -: 1267:        Mat pointMat = Mat(vec). // convert vector to Mat, O(1) operation
        -: 1268:                          reshape(1). // make Nx3 1-channel matrix out of Nx1 3-channel.
        -: 1269:                                      // Also, an O(1) operation
        -: 1270:                             t(); // finally, transpose the Nx3 matrix.
        -: 1271:                                  // This involves copying all the elements
        -: 1272:    @endcode
        -: 1273:    @param cn New number of channels. If the parameter is 0, the number of channels remains the same.
        -: 1274:    @param rows New number of rows. If the parameter is 0, the number of rows remains the same.
        -: 1275:     */
        -: 1276:    Mat reshape(int cn, int rows=0) const;
        -: 1277:
        -: 1278:    /** @overload */
        -: 1279:    Mat reshape(int cn, int newndims, const int* newsz) const;
        -: 1280:
        -: 1281:    /** @overload */
        -: 1282:    Mat reshape(int cn, const std::vector<int>& newshape) const;
        -: 1283:
        -: 1284:    /** @brief Transposes a matrix.
        -: 1285:
        -: 1286:    The method performs matrix transposition by means of matrix expressions. It does not perform the
        -: 1287:    actual transposition but returns a temporary matrix transposition object that can be further used as
        -: 1288:    a part of more complex matrix expressions or can be assigned to a matrix:
        -: 1289:    @code
        -: 1290:        Mat A1 = A + Mat::eye(A.size(), A.type())*lambda;
        -: 1291:        Mat C = A1.t()*A1; // compute (A + lambda*I)^t * (A + lamda*I)
        -: 1292:    @endcode
        -: 1293:     */
        -: 1294:    MatExpr t() const;
        -: 1295:
        -: 1296:    /** @brief Inverses a matrix.
        -: 1297:
        -: 1298:    The method performs a matrix inversion by means of matrix expressions. This means that a temporary
        -: 1299:    matrix inversion object is returned by the method and can be used further as a part of more complex
        -: 1300:    matrix expressions or can be assigned to a matrix.
        -: 1301:    @param method Matrix inversion method. One of cv::DecompTypes
        -: 1302:     */
        -: 1303:    MatExpr inv(int method=DECOMP_LU) const;
        -: 1304:
        -: 1305:    /** @brief Performs an element-wise multiplication or division of the two matrices.
        -: 1306:
        -: 1307:    The method returns a temporary object encoding per-element array multiplication, with optional
        -: 1308:    scale. Note that this is not a matrix multiplication that corresponds to a simpler "\*" operator.
        -: 1309:
        -: 1310:    Example:
        -: 1311:    @code
        -: 1312:        Mat C = A.mul(5/B); // equivalent to divide(A, B, C, 5)
        -: 1313:    @endcode
        -: 1314:    @param m Another array of the same type and the same size as \*this, or a matrix expression.
        -: 1315:    @param scale Optional scale factor.
        -: 1316:     */
        -: 1317:    MatExpr mul(InputArray m, double scale=1) const;
        -: 1318:
        -: 1319:    /** @brief Computes a cross-product of two 3-element vectors.
        -: 1320:
        -: 1321:    The method computes a cross-product of two 3-element vectors. The vectors must be 3-element
        -: 1322:    floating-point vectors of the same shape and size. The result is another 3-element vector of the
        -: 1323:    same shape and type as operands.
        -: 1324:    @param m Another cross-product operand.
        -: 1325:     */
        -: 1326:    Mat cross(InputArray m) const;
        -: 1327:
        -: 1328:    /** @brief Computes a dot-product of two vectors.
        -: 1329:
        -: 1330:    The method computes a dot-product of two matrices. If the matrices are not single-column or
        -: 1331:    single-row vectors, the top-to-bottom left-to-right scan ordering is used to treat them as 1D
        -: 1332:    vectors. The vectors must have the same size and type. If the matrices have more than one channel,
        -: 1333:    the dot products from all the channels are summed together.
        -: 1334:    @param m another dot-product operand.
        -: 1335:     */
        -: 1336:    double dot(InputArray m) const;
        -: 1337:
        -: 1338:    /** @brief Returns a zero array of the specified size and type.
        -: 1339:
        -: 1340:    The method returns a Matlab-style zero array initializer. It can be used to quickly form a constant
        -: 1341:    array as a function parameter, part of a matrix expression, or as a matrix initializer:
        -: 1342:    @code
        -: 1343:        Mat A;
        -: 1344:        A = Mat::zeros(3, 3, CV_32F);
        -: 1345:    @endcode
        -: 1346:    In the example above, a new matrix is allocated only if A is not a 3x3 floating-point matrix.
        -: 1347:    Otherwise, the existing matrix A is filled with zeros.
        -: 1348:    @param rows Number of rows.
        -: 1349:    @param cols Number of columns.
        -: 1350:    @param type Created matrix type.
        -: 1351:     */
        -: 1352:    static MatExpr zeros(int rows, int cols, int type);
        -: 1353:
        -: 1354:    /** @overload
        -: 1355:    @param size Alternative to the matrix size specification Size(cols, rows) .
        -: 1356:    @param type Created matrix type.
        -: 1357:    */
        -: 1358:    static MatExpr zeros(Size size, int type);
        -: 1359:
        -: 1360:    /** @overload
        -: 1361:    @param ndims Array dimensionality.
        -: 1362:    @param sz Array of integers specifying the array shape.
        -: 1363:    @param type Created matrix type.
        -: 1364:    */
        -: 1365:    static MatExpr zeros(int ndims, const int* sz, int type);
        -: 1366:
        -: 1367:    /** @brief Returns an array of all 1's of the specified size and type.
        -: 1368:
        -: 1369:    The method returns a Matlab-style 1's array initializer, similarly to Mat::zeros. Note that using
        -: 1370:    this method you can initialize an array with an arbitrary value, using the following Matlab idiom:
        -: 1371:    @code
        -: 1372:        Mat A = Mat::ones(100, 100, CV_8U)*3; // make 100x100 matrix filled with 3.
        -: 1373:    @endcode
        -: 1374:    The above operation does not form a 100x100 matrix of 1's and then multiply it by 3. Instead, it
        -: 1375:    just remembers the scale factor (3 in this case) and use it when actually invoking the matrix
        -: 1376:    initializer.
        -: 1377:    @note In case of multi-channels type, only the first channel will be initialized with 1's, the
        -: 1378:    others will be set to 0's.
        -: 1379:    @param rows Number of rows.
        -: 1380:    @param cols Number of columns.
        -: 1381:    @param type Created matrix type.
        -: 1382:     */
        -: 1383:    static MatExpr ones(int rows, int cols, int type);
        -: 1384:
        -: 1385:    /** @overload
        -: 1386:    @param size Alternative to the matrix size specification Size(cols, rows) .
        -: 1387:    @param type Created matrix type.
        -: 1388:    */
        -: 1389:    static MatExpr ones(Size size, int type);
        -: 1390:
        -: 1391:    /** @overload
        -: 1392:    @param ndims Array dimensionality.
        -: 1393:    @param sz Array of integers specifying the array shape.
        -: 1394:    @param type Created matrix type.
        -: 1395:    */
        -: 1396:    static MatExpr ones(int ndims, const int* sz, int type);
        -: 1397:
        -: 1398:    /** @brief Returns an identity matrix of the specified size and type.
        -: 1399:
        -: 1400:    The method returns a Matlab-style identity matrix initializer, similarly to Mat::zeros. Similarly to
        -: 1401:    Mat::ones, you can use a scale operation to create a scaled identity matrix efficiently:
        -: 1402:    @code
        -: 1403:        // make a 4x4 diagonal matrix with 0.1's on the diagonal.
        -: 1404:        Mat A = Mat::eye(4, 4, CV_32F)*0.1;
        -: 1405:    @endcode
        -: 1406:    @note In case of multi-channels type, identity matrix will be initialized only for the first channel,
        -: 1407:    the others will be set to 0's
        -: 1408:    @param rows Number of rows.
        -: 1409:    @param cols Number of columns.
        -: 1410:    @param type Created matrix type.
        -: 1411:     */
        -: 1412:    static MatExpr eye(int rows, int cols, int type);
        -: 1413:
        -: 1414:    /** @overload
        -: 1415:    @param size Alternative matrix size specification as Size(cols, rows) .
        -: 1416:    @param type Created matrix type.
        -: 1417:    */
        -: 1418:    static MatExpr eye(Size size, int type);
        -: 1419:
        -: 1420:    /** @brief Allocates new array data if needed.
        -: 1421:
        -: 1422:    This is one of the key Mat methods. Most new-style OpenCV functions and methods that produce arrays
        -: 1423:    call this method for each output array. The method uses the following algorithm:
        -: 1424:
        -: 1425:    -# If the current array shape and the type match the new ones, return immediately. Otherwise,
        -: 1426:       de-reference the previous data by calling Mat::release.
        -: 1427:    -# Initialize the new header.
        -: 1428:    -# Allocate the new data of total()\*elemSize() bytes.
        -: 1429:    -# Allocate the new, associated with the data, reference counter and set it to 1.
        -: 1430:
        -: 1431:    Such a scheme makes the memory management robust and efficient at the same time and helps avoid
        -: 1432:    extra typing for you. This means that usually there is no need to explicitly allocate output arrays.
        -: 1433:    That is, instead of writing:
        -: 1434:    @code
        -: 1435:        Mat color;
        -: 1436:        ...
        -: 1437:        Mat gray(color.rows, color.cols, color.depth());
        -: 1438:        cvtColor(color, gray, COLOR_BGR2GRAY);
        -: 1439:    @endcode
        -: 1440:    you can simply write:
        -: 1441:    @code
        -: 1442:        Mat color;
        -: 1443:        ...
        -: 1444:        Mat gray;
        -: 1445:        cvtColor(color, gray, COLOR_BGR2GRAY);
        -: 1446:    @endcode
        -: 1447:    because cvtColor, as well as the most of OpenCV functions, calls Mat::create() for the output array
        -: 1448:    internally.
        -: 1449:    @param rows New number of rows.
        -: 1450:    @param cols New number of columns.
        -: 1451:    @param type New matrix type.
        -: 1452:     */
        -: 1453:    void create(int rows, int cols, int type);
        -: 1454:
        -: 1455:    /** @overload
        -: 1456:    @param size Alternative new matrix size specification: Size(cols, rows)
        -: 1457:    @param type New matrix type.
        -: 1458:    */
        -: 1459:    void create(Size size, int type);
        -: 1460:
        -: 1461:    /** @overload
        -: 1462:    @param ndims New array dimensionality.
        -: 1463:    @param sizes Array of integers specifying a new array shape.
        -: 1464:    @param type New matrix type.
        -: 1465:    */
        -: 1466:    void create(int ndims, const int* sizes, int type);
        -: 1467:
        -: 1468:    /** @overload
        -: 1469:    @param sizes Array of integers specifying a new array shape.
        -: 1470:    @param type New matrix type.
        -: 1471:    */
        -: 1472:    void create(const std::vector<int>& sizes, int type);
        -: 1473:
        -: 1474:    /** @brief Increments the reference counter.
        -: 1475:
        -: 1476:    The method increments the reference counter associated with the matrix data. If the matrix header
        -: 1477:    points to an external data set (see Mat::Mat ), the reference counter is NULL, and the method has no
        -: 1478:    effect in this case. Normally, to avoid memory leaks, the method should not be called explicitly. It
        -: 1479:    is called implicitly by the matrix assignment operator. The reference counter increment is an atomic
        -: 1480:    operation on the platforms that support it. Thus, it is safe to operate on the same matrices
        -: 1481:    asynchronously in different threads.
        -: 1482:     */
        -: 1483:    void addref();
        -: 1484:
        -: 1485:    /** @brief Decrements the reference counter and deallocates the matrix if needed.
        -: 1486:
        -: 1487:    The method decrements the reference counter associated with the matrix data. When the reference
        -: 1488:    counter reaches 0, the matrix data is deallocated and the data and the reference counter pointers
        -: 1489:    are set to NULL's. If the matrix header points to an external data set (see Mat::Mat ), the
        -: 1490:    reference counter is NULL, and the method has no effect in this case.
        -: 1491:
        -: 1492:    This method can be called manually to force the matrix data deallocation. But since this method is
        -: 1493:    automatically called in the destructor, or by any other method that changes the data pointer, it is
        -: 1494:    usually not needed. The reference counter decrement and check for 0 is an atomic operation on the
        -: 1495:    platforms that support it. Thus, it is safe to operate on the same matrices asynchronously in
        -: 1496:    different threads.
        -: 1497:     */
        -: 1498:    void release();
        -: 1499:
        -: 1500:    //! internal use function, consider to use 'release' method instead; deallocates the matrix data
        -: 1501:    void deallocate();
        -: 1502:    //! internal use function; properly re-allocates _size, _step arrays
        -: 1503:    void copySize(const Mat& m);
        -: 1504:
        -: 1505:    /** @brief Reserves space for the certain number of rows.
        -: 1506:
        -: 1507:    The method reserves space for sz rows. If the matrix already has enough space to store sz rows,
        -: 1508:    nothing happens. If the matrix is reallocated, the first Mat::rows rows are preserved. The method
        -: 1509:    emulates the corresponding method of the STL vector class.
        -: 1510:    @param sz Number of rows.
        -: 1511:     */
        -: 1512:    void reserve(size_t sz);
        -: 1513:
        -: 1514:    /** @brief Reserves space for the certain number of bytes.
        -: 1515:
        -: 1516:    The method reserves space for sz bytes. If the matrix already has enough space to store sz bytes,
        -: 1517:    nothing happens. If matrix has to be reallocated its previous content could be lost.
        -: 1518:    @param sz Number of bytes.
        -: 1519:    */
        -: 1520:    void reserveBuffer(size_t sz);
        -: 1521:
        -: 1522:    /** @brief Changes the number of matrix rows.
        -: 1523:
        -: 1524:    The methods change the number of matrix rows. If the matrix is reallocated, the first
        -: 1525:    min(Mat::rows, sz) rows are preserved. The methods emulate the corresponding methods of the STL
        -: 1526:    vector class.
        -: 1527:    @param sz New number of rows.
        -: 1528:     */
        -: 1529:    void resize(size_t sz);
        -: 1530:
        -: 1531:    /** @overload
        -: 1532:    @param sz New number of rows.
        -: 1533:    @param s Value assigned to the newly added elements.
        -: 1534:     */
        -: 1535:    void resize(size_t sz, const Scalar& s);
        -: 1536:
        -: 1537:    //! internal function
        -: 1538:    void push_back_(const void* elem);
        -: 1539:
        -: 1540:    /** @brief Adds elements to the bottom of the matrix.
        -: 1541:
        -: 1542:    The methods add one or more elements to the bottom of the matrix. They emulate the corresponding
        -: 1543:    method of the STL vector class. When elem is Mat , its type and the number of columns must be the
        -: 1544:    same as in the container matrix.
        -: 1545:    @param elem Added element(s).
        -: 1546:     */
        -: 1547:    template<typename _Tp> void push_back(const _Tp& elem);
        -: 1548:
        -: 1549:    /** @overload
        -: 1550:    @param elem Added element(s).
        -: 1551:    */
        -: 1552:    template<typename _Tp> void push_back(const Mat_<_Tp>& elem);
        -: 1553:
        -: 1554:    /** @overload
        -: 1555:    @param elem Added element(s).
        -: 1556:    */
        -: 1557:    template<typename _Tp> void push_back(const std::vector<_Tp>& elem);
        -: 1558:
        -: 1559:    /** @overload
        -: 1560:    @param m Added line(s).
        -: 1561:    */
        -: 1562:    void push_back(const Mat& m);
        -: 1563:
        -: 1564:    /** @brief Removes elements from the bottom of the matrix.
        -: 1565:
        -: 1566:    The method removes one or more rows from the bottom of the matrix.
        -: 1567:    @param nelems Number of removed rows. If it is greater than the total number of rows, an exception
        -: 1568:    is thrown.
        -: 1569:     */
        -: 1570:    void pop_back(size_t nelems=1);
        -: 1571:
        -: 1572:    /** @brief Locates the matrix header within a parent matrix.
        -: 1573:
        -: 1574:    After you extracted a submatrix from a matrix using Mat::row, Mat::col, Mat::rowRange,
        -: 1575:    Mat::colRange, and others, the resultant submatrix points just to the part of the original big
        -: 1576:    matrix. However, each submatrix contains information (represented by datastart and dataend
        -: 1577:    fields) that helps reconstruct the original matrix size and the position of the extracted
        -: 1578:    submatrix within the original matrix. The method locateROI does exactly that.
        -: 1579:    @param wholeSize Output parameter that contains the size of the whole matrix containing *this*
        -: 1580:    as a part.
        -: 1581:    @param ofs Output parameter that contains an offset of *this* inside the whole matrix.
        -: 1582:     */
        -: 1583:    void locateROI( Size& wholeSize, Point& ofs ) const;
        -: 1584:
        -: 1585:    /** @brief Adjusts a submatrix size and position within the parent matrix.
        -: 1586:
        -: 1587:    The method is complimentary to Mat::locateROI . The typical use of these functions is to determine
        -: 1588:    the submatrix position within the parent matrix and then shift the position somehow. Typically, it
        -: 1589:    can be required for filtering operations when pixels outside of the ROI should be taken into
        -: 1590:    account. When all the method parameters are positive, the ROI needs to grow in all directions by the
        -: 1591:    specified amount, for example:
        -: 1592:    @code
        -: 1593:        A.adjustROI(2, 2, 2, 2);
        -: 1594:    @endcode
        -: 1595:    In this example, the matrix size is increased by 4 elements in each direction. The matrix is shifted
        -: 1596:    by 2 elements to the left and 2 elements up, which brings in all the necessary pixels for the
        -: 1597:    filtering with the 5x5 kernel.
        -: 1598:
        -: 1599:    adjustROI forces the adjusted ROI to be inside of the parent matrix that is boundaries of the
        -: 1600:    adjusted ROI are constrained by boundaries of the parent matrix. For example, if the submatrix A is
        -: 1601:    located in the first row of a parent matrix and you called A.adjustROI(2, 2, 2, 2) then A will not
        -: 1602:    be increased in the upward direction.
        -: 1603:
        -: 1604:    The function is used internally by the OpenCV filtering functions, like filter2D , morphological
        -: 1605:    operations, and so on.
        -: 1606:    @param dtop Shift of the top submatrix boundary upwards.
        -: 1607:    @param dbottom Shift of the bottom submatrix boundary downwards.
        -: 1608:    @param dleft Shift of the left submatrix boundary to the left.
        -: 1609:    @param dright Shift of the right submatrix boundary to the right.
        -: 1610:    @sa copyMakeBorder
        -: 1611:     */
        -: 1612:    Mat& adjustROI( int dtop, int dbottom, int dleft, int dright );
        -: 1613:
        -: 1614:    /** @brief Extracts a rectangular submatrix.
        -: 1615:
        -: 1616:    The operators make a new header for the specified sub-array of \*this . They are the most
        -: 1617:    generalized forms of Mat::row, Mat::col, Mat::rowRange, and Mat::colRange . For example,
        -: 1618:    `A(Range(0, 10), Range::all())` is equivalent to `A.rowRange(0, 10)`. Similarly to all of the above,
        -: 1619:    the operators are O(1) operations, that is, no matrix data is copied.
        -: 1620:    @param rowRange Start and end row of the extracted submatrix. The upper boundary is not included. To
        -: 1621:    select all the rows, use Range::all().
        -: 1622:    @param colRange Start and end column of the extracted submatrix. The upper boundary is not included.
        -: 1623:    To select all the columns, use Range::all().
        -: 1624:     */
        -: 1625:    Mat operator()( Range rowRange, Range colRange ) const;
        -: 1626:
        -: 1627:    /** @overload
        -: 1628:    @param roi Extracted submatrix specified as a rectangle.
        -: 1629:    */
        -: 1630:    Mat operator()( const Rect& roi ) const;
        -: 1631:
        -: 1632:    /** @overload
        -: 1633:    @param ranges Array of selected ranges along each array dimension.
        -: 1634:    */
        -: 1635:    Mat operator()( const Range* ranges ) const;
        -: 1636:
        -: 1637:    /** @overload
        -: 1638:    @param ranges Array of selected ranges along each array dimension.
        -: 1639:    */
        -: 1640:    Mat operator()(const std::vector<Range>& ranges) const;
        -: 1641:
        -: 1642:    template<typename _Tp> operator std::vector<_Tp>() const;
        -: 1643:    template<typename _Tp, int n> operator Vec<_Tp, n>() const;
        -: 1644:    template<typename _Tp, int m, int n> operator Matx<_Tp, m, n>() const;
        -: 1645:
        -: 1646:    template<typename _Tp, std::size_t _Nm> operator std::array<_Tp, _Nm>() const;
        -: 1647:
        -: 1648:    /** @brief Reports whether the matrix is continuous or not.
        -: 1649:
        -: 1650:    The method returns true if the matrix elements are stored continuously without gaps at the end of
        -: 1651:    each row. Otherwise, it returns false. Obviously, 1x1 or 1xN matrices are always continuous.
        -: 1652:    Matrices created with Mat::create are always continuous. But if you extract a part of the matrix
        -: 1653:    using Mat::col, Mat::diag, and so on, or constructed a matrix header for externally allocated data,
        -: 1654:    such matrices may no longer have this property.
        -: 1655:
        -: 1656:    The continuity flag is stored as a bit in the Mat::flags field and is computed automatically when
        -: 1657:    you construct a matrix header. Thus, the continuity check is a very fast operation, though
        -: 1658:    theoretically it could be done as follows:
        -: 1659:    @code
        -: 1660:        // alternative implementation of Mat::isContinuous()
        -: 1661:        bool myCheckMatContinuity(const Mat& m)
        -: 1662:        {
        -: 1663:            //return (m.flags & Mat::CONTINUOUS_FLAG) != 0;
        -: 1664:            return m.rows == 1 || m.step == m.cols*m.elemSize();
        -: 1665:        }
        -: 1666:    @endcode
        -: 1667:    The method is used in quite a few of OpenCV functions. The point is that element-wise operations
        -: 1668:    (such as arithmetic and logical operations, math functions, alpha blending, color space
        -: 1669:    transformations, and others) do not depend on the image geometry. Thus, if all the input and output
        -: 1670:    arrays are continuous, the functions can process them as very long single-row vectors. The example
        -: 1671:    below illustrates how an alpha-blending function can be implemented:
        -: 1672:    @code
        -: 1673:        template<typename T>
        -: 1674:        void alphaBlendRGBA(const Mat& src1, const Mat& src2, Mat& dst)
        -: 1675:        {
        -: 1676:            const float alpha_scale = (float)std::numeric_limits<T>::max(),
        -: 1677:                        inv_scale = 1.f/alpha_scale;
        -: 1678:
        -: 1679:            CV_Assert( src1.type() == src2.type() &&
        -: 1680:                       src1.type() == CV_MAKETYPE(traits::Depth<T>::value, 4) &&
        -: 1681:                       src1.size() == src2.size());
        -: 1682:            Size size = src1.size();
        -: 1683:            dst.create(size, src1.type());
        -: 1684:
        -: 1685:            // here is the idiom: check the arrays for continuity and,
        -: 1686:            // if this is the case,
        -: 1687:            // treat the arrays as 1D vectors
        -: 1688:            if( src1.isContinuous() && src2.isContinuous() && dst.isContinuous() )
        -: 1689:            {
        -: 1690:                size.width *= size.height;
        -: 1691:                size.height = 1;
        -: 1692:            }
        -: 1693:            size.width *= 4;
        -: 1694:
        -: 1695:            for( int i = 0; i < size.height; i++ )
        -: 1696:            {
        -: 1697:                // when the arrays are continuous,
        -: 1698:                // the outer loop is executed only once
        -: 1699:                const T* ptr1 = src1.ptr<T>(i);
        -: 1700:                const T* ptr2 = src2.ptr<T>(i);
        -: 1701:                T* dptr = dst.ptr<T>(i);
        -: 1702:
        -: 1703:                for( int j = 0; j < size.width; j += 4 )
        -: 1704:                {
        -: 1705:                    float alpha = ptr1[j+3]*inv_scale, beta = ptr2[j+3]*inv_scale;
        -: 1706:                    dptr[j] = saturate_cast<T>(ptr1[j]*alpha + ptr2[j]*beta);
        -: 1707:                    dptr[j+1] = saturate_cast<T>(ptr1[j+1]*alpha + ptr2[j+1]*beta);
        -: 1708:                    dptr[j+2] = saturate_cast<T>(ptr1[j+2]*alpha + ptr2[j+2]*beta);
        -: 1709:                    dptr[j+3] = saturate_cast<T>((1 - (1-alpha)*(1-beta))*alpha_scale);
        -: 1710:                }
        -: 1711:            }
        -: 1712:        }
        -: 1713:    @endcode
        -: 1714:    This approach, while being very simple, can boost the performance of a simple element-operation by
        -: 1715:    10-20 percents, especially if the image is rather small and the operation is quite simple.
        -: 1716:
        -: 1717:    Another OpenCV idiom in this function, a call of Mat::create for the destination array, that
        -: 1718:    allocates the destination array unless it already has the proper size and type. And while the newly
        -: 1719:    allocated arrays are always continuous, you still need to check the destination array because
        -: 1720:    Mat::create does not always allocate a new matrix.
        -: 1721:     */
        -: 1722:    bool isContinuous() const;
        -: 1723:
        -: 1724:    //! returns true if the matrix is a submatrix of another matrix
        -: 1725:    bool isSubmatrix() const;
        -: 1726:
        -: 1727:    /** @brief Returns the matrix element size in bytes.
        -: 1728:
        -: 1729:    The method returns the matrix element size in bytes. For example, if the matrix type is CV_16SC3 ,
        -: 1730:    the method returns 3\*sizeof(short) or 6.
        -: 1731:     */
        -: 1732:    size_t elemSize() const;
        -: 1733:
        -: 1734:    /** @brief Returns the size of each matrix element channel in bytes.
        -: 1735:
        -: 1736:    The method returns the matrix element channel size in bytes, that is, it ignores the number of
        -: 1737:    channels. For example, if the matrix type is CV_16SC3 , the method returns sizeof(short) or 2.
        -: 1738:     */
        -: 1739:    size_t elemSize1() const;
        -: 1740:
        -: 1741:    /** @brief Returns the type of a matrix element.
        -: 1742:
        -: 1743:    The method returns a matrix element type. This is an identifier compatible with the CvMat type
        -: 1744:    system, like CV_16SC3 or 16-bit signed 3-channel array, and so on.
        -: 1745:     */
        -: 1746:    int type() const;
        -: 1747:
        -: 1748:    /** @brief Returns the depth of a matrix element.
        -: 1749:
        -: 1750:    The method returns the identifier of the matrix element depth (the type of each individual channel).
        -: 1751:    For example, for a 16-bit signed element array, the method returns CV_16S . A complete list of
        -: 1752:    matrix types contains the following values:
        -: 1753:    -   CV_8U - 8-bit unsigned integers ( 0..255 )
        -: 1754:    -   CV_8S - 8-bit signed integers ( -128..127 )
        -: 1755:    -   CV_16U - 16-bit unsigned integers ( 0..65535 )
        -: 1756:    -   CV_16S - 16-bit signed integers ( -32768..32767 )
        -: 1757:    -   CV_32S - 32-bit signed integers ( -2147483648..2147483647 )
        -: 1758:    -   CV_32F - 32-bit floating-point numbers ( -FLT_MAX..FLT_MAX, INF, NAN )
        -: 1759:    -   CV_64F - 64-bit floating-point numbers ( -DBL_MAX..DBL_MAX, INF, NAN )
        -: 1760:     */
        -: 1761:    int depth() const;
        -: 1762:
        -: 1763:    /** @brief Returns the number of matrix channels.
        -: 1764:
        -: 1765:    The method returns the number of matrix channels.
        -: 1766:     */
        -: 1767:    int channels() const;
        -: 1768:
        -: 1769:    /** @brief Returns a normalized step.
        -: 1770:
        -: 1771:    The method returns a matrix step divided by Mat::elemSize1() . It can be useful to quickly access an
        -: 1772:    arbitrary matrix element.
        -: 1773:     */
        -: 1774:    size_t step1(int i=0) const;
        -: 1775:
        -: 1776:    /** @brief Returns true if the array has no elements.
        -: 1777:
        -: 1778:    The method returns true if Mat::total() is 0 or if Mat::data is NULL. Because of pop_back() and
        -: 1779:    resize() methods `M.total() == 0` does not imply that `M.data == NULL`.
        -: 1780:     */
        -: 1781:    bool empty() const;
        -: 1782:
        -: 1783:    /** @brief Returns the total number of array elements.
        -: 1784:
        -: 1785:    The method returns the number of array elements (a number of pixels if the array represents an
        -: 1786:    image).
        -: 1787:     */
        -: 1788:    size_t total() const;
        -: 1789:
        -: 1790:    /** @brief Returns the total number of array elements.
        -: 1791:
        -: 1792:     The method returns the number of elements within a certain sub-array slice with startDim <= dim < endDim
        -: 1793:     */
        -: 1794:    size_t total(int startDim, int endDim=INT_MAX) const;
        -: 1795:
        -: 1796:    /**
        -: 1797:     * @param elemChannels Number of channels or number of columns the matrix should have.
        -: 1798:     *                     For a 2-D matrix, when the matrix has only 1 column, then it should have
        -: 1799:     *                     elemChannels channels; When the matrix has only 1 channel,
        -: 1800:     *                     then it should have elemChannels columns.
        -: 1801:     *                     For a 3-D matrix, it should have only one channel. Furthermore,
        -: 1802:     *                     if the number of planes is not one, then the number of rows
        -: 1803:     *                     within every plane has to be 1; if the number of rows within
        -: 1804:     *                     every plane is not 1, then the number of planes has to be 1.
        -: 1805:     * @param depth The depth the matrix should have. Set it to -1 when any depth is fine.
        -: 1806:     * @param requireContinuous Set it to true to require the matrix to be continuous
        -: 1807:     * @return -1 if the requirement is not satisfied.
        -: 1808:     *         Otherwise, it returns the number of elements in the matrix. Note
        -: 1809:     *         that an element may have multiple channels.
        -: 1810:     *
        -: 1811:     * The following code demonstrates its usage for a 2-d matrix:
        -: 1812:     * @snippet snippets/core_mat_checkVector.cpp example-2d
        -: 1813:     *
        -: 1814:     * The following code demonstrates its usage for a 3-d matrix:
        -: 1815:     * @snippet snippets/core_mat_checkVector.cpp example-3d
        -: 1816:     */
        -: 1817:    int checkVector(int elemChannels, int depth=-1, bool requireContinuous=true) const;
        -: 1818:
        -: 1819:    /** @brief Returns a pointer to the specified matrix row.
        -: 1820:
        -: 1821:    The methods return `uchar*` or typed pointer to the specified matrix row. See the sample in
        -: 1822:    Mat::isContinuous to know how to use these methods.
        -: 1823:    @param i0 A 0-based row index.
        -: 1824:     */
        -: 1825:    uchar* ptr(int i0=0);
        -: 1826:    /** @overload */
        -: 1827:    const uchar* ptr(int i0=0) const;
        -: 1828:
        -: 1829:    /** @overload
        -: 1830:    @param row Index along the dimension 0
        -: 1831:    @param col Index along the dimension 1
        -: 1832:    */
        -: 1833:    uchar* ptr(int row, int col);
        -: 1834:    /** @overload
        -: 1835:    @param row Index along the dimension 0
        -: 1836:    @param col Index along the dimension 1
        -: 1837:    */
        -: 1838:    const uchar* ptr(int row, int col) const;
        -: 1839:
        -: 1840:    /** @overload */
        -: 1841:    uchar* ptr(int i0, int i1, int i2);
        -: 1842:    /** @overload */
        -: 1843:    const uchar* ptr(int i0, int i1, int i2) const;
        -: 1844:
        -: 1845:    /** @overload */
        -: 1846:    uchar* ptr(const int* idx);
        -: 1847:    /** @overload */
        -: 1848:    const uchar* ptr(const int* idx) const;
        -: 1849:    /** @overload */
        -: 1850:    template<int n> uchar* ptr(const Vec<int, n>& idx);
        -: 1851:    /** @overload */
        -: 1852:    template<int n> const uchar* ptr(const Vec<int, n>& idx) const;
        -: 1853:
        -: 1854:    /** @overload */
        -: 1855:    template<typename _Tp> _Tp* ptr(int i0=0);
        -: 1856:    /** @overload */
        -: 1857:    template<typename _Tp> const _Tp* ptr(int i0=0) const;
        -: 1858:    /** @overload
        -: 1859:    @param row Index along the dimension 0
        -: 1860:    @param col Index along the dimension 1
        -: 1861:    */
        -: 1862:    template<typename _Tp> _Tp* ptr(int row, int col);
        -: 1863:    /** @overload
        -: 1864:    @param row Index along the dimension 0
        -: 1865:    @param col Index along the dimension 1
        -: 1866:    */
        -: 1867:    template<typename _Tp> const _Tp* ptr(int row, int col) const;
        -: 1868:    /** @overload */
        -: 1869:    template<typename _Tp> _Tp* ptr(int i0, int i1, int i2);
        -: 1870:    /** @overload */
        -: 1871:    template<typename _Tp> const _Tp* ptr(int i0, int i1, int i2) const;
        -: 1872:    /** @overload */
        -: 1873:    template<typename _Tp> _Tp* ptr(const int* idx);
        -: 1874:    /** @overload */
        -: 1875:    template<typename _Tp> const _Tp* ptr(const int* idx) const;
        -: 1876:    /** @overload */
        -: 1877:    template<typename _Tp, int n> _Tp* ptr(const Vec<int, n>& idx);
        -: 1878:    /** @overload */
        -: 1879:    template<typename _Tp, int n> const _Tp* ptr(const Vec<int, n>& idx) const;
        -: 1880:
        -: 1881:    /** @brief Returns a reference to the specified array element.
        -: 1882:
        -: 1883:    The template methods return a reference to the specified array element. For the sake of higher
        -: 1884:    performance, the index range checks are only performed in the Debug configuration.
        -: 1885:
        -: 1886:    Note that the variants with a single index (i) can be used to access elements of single-row or
        -: 1887:    single-column 2-dimensional arrays. That is, if, for example, A is a 1 x N floating-point matrix and
        -: 1888:    B is an M x 1 integer matrix, you can simply write `A.at<float>(k+4)` and `B.at<int>(2*i+1)`
        -: 1889:    instead of `A.at<float>(0,k+4)` and `B.at<int>(2*i+1,0)`, respectively.
        -: 1890:
        -: 1891:    The example below initializes a Hilbert matrix:
        -: 1892:    @code
        -: 1893:        Mat H(100, 100, CV_64F);
        -: 1894:        for(int i = 0; i < H.rows; i++)
        -: 1895:            for(int j = 0; j < H.cols; j++)
        -: 1896:                H.at<double>(i,j)=1./(i+j+1);
        -: 1897:    @endcode
        -: 1898:
        -: 1899:    Keep in mind that the size identifier used in the at operator cannot be chosen at random. It depends
        -: 1900:    on the image from which you are trying to retrieve the data. The table below gives a better insight in this:
        -: 1901:     - If matrix is of type `CV_8U` then use `Mat.at<uchar>(y,x)`.
        -: 1902:     - If matrix is of type `CV_8S` then use `Mat.at<schar>(y,x)`.
        -: 1903:     - If matrix is of type `CV_16U` then use `Mat.at<ushort>(y,x)`.
        -: 1904:     - If matrix is of type `CV_16S` then use `Mat.at<short>(y,x)`.
        -: 1905:     - If matrix is of type `CV_32S`  then use `Mat.at<int>(y,x)`.
        -: 1906:     - If matrix is of type `CV_32F`  then use `Mat.at<float>(y,x)`.
        -: 1907:     - If matrix is of type `CV_64F` then use `Mat.at<double>(y,x)`.
        -: 1908:
        -: 1909:    @param i0 Index along the dimension 0
        -: 1910:     */
        -: 1911:    template<typename _Tp> _Tp& at(int i0=0);
        -: 1912:    /** @overload
        -: 1913:    @param i0 Index along the dimension 0
        -: 1914:    */
        -: 1915:    template<typename _Tp> const _Tp& at(int i0=0) const;
        -: 1916:    /** @overload
        -: 1917:    @param row Index along the dimension 0
        -: 1918:    @param col Index along the dimension 1
        -: 1919:    */
        -: 1920:    template<typename _Tp> _Tp& at(int row, int col);
        -: 1921:    /** @overload
        -: 1922:    @param row Index along the dimension 0
        -: 1923:    @param col Index along the dimension 1
        -: 1924:    */
        -: 1925:    template<typename _Tp> const _Tp& at(int row, int col) const;
        -: 1926:
        -: 1927:    /** @overload
        -: 1928:    @param i0 Index along the dimension 0
        -: 1929:    @param i1 Index along the dimension 1
        -: 1930:    @param i2 Index along the dimension 2
        -: 1931:    */
        -: 1932:    template<typename _Tp> _Tp& at(int i0, int i1, int i2);
        -: 1933:    /** @overload
        -: 1934:    @param i0 Index along the dimension 0
        -: 1935:    @param i1 Index along the dimension 1
        -: 1936:    @param i2 Index along the dimension 2
        -: 1937:    */
        -: 1938:    template<typename _Tp> const _Tp& at(int i0, int i1, int i2) const;
        -: 1939:
        -: 1940:    /** @overload
        -: 1941:    @param idx Array of Mat::dims indices.
        -: 1942:    */
        -: 1943:    template<typename _Tp> _Tp& at(const int* idx);
        -: 1944:    /** @overload
        -: 1945:    @param idx Array of Mat::dims indices.
        -: 1946:    */
        -: 1947:    template<typename _Tp> const _Tp& at(const int* idx) const;
        -: 1948:
        -: 1949:    /** @overload */
        -: 1950:    template<typename _Tp, int n> _Tp& at(const Vec<int, n>& idx);
        -: 1951:    /** @overload */
        -: 1952:    template<typename _Tp, int n> const _Tp& at(const Vec<int, n>& idx) const;
        -: 1953:
        -: 1954:    /** @overload
        -: 1955:    special versions for 2D arrays (especially convenient for referencing image pixels)
        -: 1956:    @param pt Element position specified as Point(j,i) .
        -: 1957:    */
        -: 1958:    template<typename _Tp> _Tp& at(Point pt);
        -: 1959:    /** @overload
        -: 1960:    special versions for 2D arrays (especially convenient for referencing image pixels)
        -: 1961:    @param pt Element position specified as Point(j,i) .
        -: 1962:    */
        -: 1963:    template<typename _Tp> const _Tp& at(Point pt) const;
        -: 1964:
        -: 1965:    /** @brief Returns the matrix iterator and sets it to the first matrix element.
        -: 1966:
        -: 1967:    The methods return the matrix read-only or read-write iterators. The use of matrix iterators is very
        -: 1968:    similar to the use of bi-directional STL iterators. In the example below, the alpha blending
        -: 1969:    function is rewritten using the matrix iterators:
        -: 1970:    @code
        -: 1971:        template<typename T>
        -: 1972:        void alphaBlendRGBA(const Mat& src1, const Mat& src2, Mat& dst)
        -: 1973:        {
        -: 1974:            typedef Vec<T, 4> VT;
        -: 1975:
        -: 1976:            const float alpha_scale = (float)std::numeric_limits<T>::max(),
        -: 1977:                        inv_scale = 1.f/alpha_scale;
        -: 1978:
        -: 1979:            CV_Assert( src1.type() == src2.type() &&
        -: 1980:                       src1.type() == traits::Type<VT>::value &&
        -: 1981:                       src1.size() == src2.size());
        -: 1982:            Size size = src1.size();
        -: 1983:            dst.create(size, src1.type());
        -: 1984:
        -: 1985:            MatConstIterator_<VT> it1 = src1.begin<VT>(), it1_end = src1.end<VT>();
        -: 1986:            MatConstIterator_<VT> it2 = src2.begin<VT>();
        -: 1987:            MatIterator_<VT> dst_it = dst.begin<VT>();
        -: 1988:
        -: 1989:            for( ; it1 != it1_end; ++it1, ++it2, ++dst_it )
        -: 1990:            {
        -: 1991:                VT pix1 = *it1, pix2 = *it2;
        -: 1992:                float alpha = pix1[3]*inv_scale, beta = pix2[3]*inv_scale;
        -: 1993:                *dst_it = VT(saturate_cast<T>(pix1[0]*alpha + pix2[0]*beta),
        -: 1994:                             saturate_cast<T>(pix1[1]*alpha + pix2[1]*beta),
        -: 1995:                             saturate_cast<T>(pix1[2]*alpha + pix2[2]*beta),
        -: 1996:                             saturate_cast<T>((1 - (1-alpha)*(1-beta))*alpha_scale));
        -: 1997:            }
        -: 1998:        }
        -: 1999:    @endcode
        -: 2000:     */
        -: 2001:    template<typename _Tp> MatIterator_<_Tp> begin();
        -: 2002:    template<typename _Tp> MatConstIterator_<_Tp> begin() const;
        -: 2003:
        -: 2004:    /** @brief Returns the matrix iterator and sets it to the after-last matrix element.
        -: 2005:
        -: 2006:    The methods return the matrix read-only or read-write iterators, set to the point following the last
        -: 2007:    matrix element.
        -: 2008:     */
        -: 2009:    template<typename _Tp> MatIterator_<_Tp> end();
        -: 2010:    template<typename _Tp> MatConstIterator_<_Tp> end() const;
        -: 2011:
        -: 2012:    /** @brief Runs the given functor over all matrix elements in parallel.
        -: 2013:
        -: 2014:    The operation passed as argument has to be a function pointer, a function object or a lambda(C++11).
        -: 2015:
        -: 2016:    Example 1. All of the operations below put 0xFF the first channel of all matrix elements:
        -: 2017:    @code
        -: 2018:        Mat image(1920, 1080, CV_8UC3);
        -: 2019:        typedef cv::Point3_<uint8_t> Pixel;
        -: 2020:
        -: 2021:        // first. raw pointer access.
        -: 2022:        for (int r = 0; r < image.rows; ++r) {
        -: 2023:            Pixel* ptr = image.ptr<Pixel>(r, 0);
        -: 2024:            const Pixel* ptr_end = ptr + image.cols;
        -: 2025:            for (; ptr != ptr_end; ++ptr) {
        -: 2026:                ptr->x = 255;
        -: 2027:            }
        -: 2028:        }
        -: 2029:
        -: 2030:        // Using MatIterator. (Simple but there are a Iterator's overhead)
        -: 2031:        for (Pixel &p : cv::Mat_<Pixel>(image)) {
        -: 2032:            p.x = 255;
        -: 2033:        }
        -: 2034:
        -: 2035:        // Parallel execution with function object.
        -: 2036:        struct Operator {
        -: 2037:            void operator ()(Pixel &pixel, const int * position) {
        -: 2038:                pixel.x = 255;
        -: 2039:            }
        -: 2040:        };
        -: 2041:        image.forEach<Pixel>(Operator());
        -: 2042:
        -: 2043:        // Parallel execution using C++11 lambda.
        -: 2044:        image.forEach<Pixel>([](Pixel &p, const int * position) -> void {
        -: 2045:            p.x = 255;
        -: 2046:        });
        -: 2047:    @endcode
        -: 2048:    Example 2. Using the pixel's position:
        -: 2049:    @code
        -: 2050:        // Creating 3D matrix (255 x 255 x 255) typed uint8_t
        -: 2051:        // and initialize all elements by the value which equals elements position.
        -: 2052:        // i.e. pixels (x,y,z) = (1,2,3) is (b,g,r) = (1,2,3).
        -: 2053:
        -: 2054:        int sizes[] = { 255, 255, 255 };
        -: 2055:        typedef cv::Point3_<uint8_t> Pixel;
        -: 2056:
        -: 2057:        Mat_<Pixel> image = Mat::zeros(3, sizes, CV_8UC3);
        -: 2058:
        -: 2059:        image.forEach<Pixel>([&](Pixel& pixel, const int position[]) -> void {
        -: 2060:            pixel.x = position[0];
        -: 2061:            pixel.y = position[1];
        -: 2062:            pixel.z = position[2];
        -: 2063:        });
        -: 2064:    @endcode
        -: 2065:     */
        -: 2066:    template<typename _Tp, typename Functor> void forEach(const Functor& operation);
        -: 2067:    /** @overload */
        -: 2068:    template<typename _Tp, typename Functor> void forEach(const Functor& operation) const;
        -: 2069:
        -: 2070:    Mat(Mat&& m);
        -: 2071:    Mat& operator = (Mat&& m);
        -: 2072:
        -: 2073:    enum { MAGIC_VAL  = 0x42FF0000, AUTO_STEP = 0, CONTINUOUS_FLAG = CV_MAT_CONT_FLAG, SUBMATRIX_FLAG = CV_SUBMAT_FLAG };
        -: 2074:    enum { MAGIC_MASK = 0xFFFF0000, TYPE_MASK = 0x00000FFF, DEPTH_MASK = 7 };
        -: 2075:
        -: 2076:    /*! includes several bit-fields:
        -: 2077:         - the magic signature
        -: 2078:         - continuity flag
        -: 2079:         - depth
        -: 2080:         - number of channels
        -: 2081:     */
        -: 2082:    int flags;
        -: 2083:    //! the matrix dimensionality, >= 2
        -: 2084:    int dims;
        -: 2085:    //! the number of rows and columns or (-1, -1) when the matrix has more than 2 dimensions
        -: 2086:    int rows, cols;
        -: 2087:    //! pointer to the data
        -: 2088:    uchar* data;
        -: 2089:
        -: 2090:    //! helper fields used in locateROI and adjustROI
        -: 2091:    const uchar* datastart;
        -: 2092:    const uchar* dataend;
        -: 2093:    const uchar* datalimit;
        -: 2094:
        -: 2095:    //! custom allocator
        -: 2096:    MatAllocator* allocator;
        -: 2097:    //! and the standard allocator
        -: 2098:    static MatAllocator* getStdAllocator();
        -: 2099:    static MatAllocator* getDefaultAllocator();
        -: 2100:    static void setDefaultAllocator(MatAllocator* allocator);
        -: 2101:
        -: 2102:    //! internal use method: updates the continuity flag
        -: 2103:    void updateContinuityFlag();
        -: 2104:
        -: 2105:    //! interaction with UMat
        -: 2106:    UMatData* u;
        -: 2107:
        -: 2108:    MatSize size;
        -: 2109:    MatStep step;
        -: 2110:
        -: 2111:protected:
        -: 2112:    template<typename _Tp, typename Functor> void forEach_impl(const Functor& operation);
        -: 2113:};
        -: 2114:
        -: 2115:
        -: 2116:///////////////////////////////// Mat_<_Tp> ////////////////////////////////////
        -: 2117:
        -: 2118:/** @brief Template matrix class derived from Mat
        -: 2119:
        -: 2120:@code{.cpp}
        -: 2121:    template<typename _Tp> class Mat_ : public Mat
        -: 2122:    {
        -: 2123:    public:
        -: 2124:        // ... some specific methods
        -: 2125:        //         and
        -: 2126:        // no new extra fields
        -: 2127:    };
        -: 2128:@endcode
        -: 2129:The class `Mat_<_Tp>` is a *thin* template wrapper on top of the Mat class. It does not have any
        -: 2130:extra data fields. Nor this class nor Mat has any virtual methods. Thus, references or pointers to
        -: 2131:these two classes can be freely but carefully converted one to another. For example:
        -: 2132:@code{.cpp}
        -: 2133:    // create a 100x100 8-bit matrix
        -: 2134:    Mat M(100,100,CV_8U);
        -: 2135:    // this will be compiled fine. no any data conversion will be done.
        -: 2136:    Mat_<float>& M1 = (Mat_<float>&)M;
        -: 2137:    // the program is likely to crash at the statement below
        -: 2138:    M1(99,99) = 1.f;
        -: 2139:@endcode
        -: 2140:While Mat is sufficient in most cases, Mat_ can be more convenient if you use a lot of element
        -: 2141:access operations and if you know matrix type at the compilation time. Note that
        -: 2142:`Mat::at(int y,int x)` and `Mat_::operator()(int y,int x)` do absolutely the same
        -: 2143:and run at the same speed, but the latter is certainly shorter:
        -: 2144:@code{.cpp}
        -: 2145:    Mat_<double> M(20,20);
        -: 2146:    for(int i = 0; i < M.rows; i++)
        -: 2147:        for(int j = 0; j < M.cols; j++)
        -: 2148:            M(i,j) = 1./(i+j+1);
        -: 2149:    Mat E, V;
        -: 2150:    eigen(M,E,V);
        -: 2151:    cout << E.at<double>(0,0)/E.at<double>(M.rows-1,0);
        -: 2152:@endcode
        -: 2153:To use Mat_ for multi-channel images/matrices, pass Vec as a Mat_ parameter:
        -: 2154:@code{.cpp}
        -: 2155:    // allocate a 320x240 color image and fill it with green (in RGB space)
        -: 2156:    Mat_<Vec3b> img(240, 320, Vec3b(0,255,0));
        -: 2157:    // now draw a diagonal white line
        -: 2158:    for(int i = 0; i < 100; i++)
        -: 2159:        img(i,i)=Vec3b(255,255,255);
        -: 2160:    // and now scramble the 2nd (red) channel of each pixel
        -: 2161:    for(int i = 0; i < img.rows; i++)
        -: 2162:        for(int j = 0; j < img.cols; j++)
        -: 2163:            img(i,j)[2] ^= (uchar)(i ^ j);
        -: 2164:@endcode
        -: 2165:Mat_ is fully compatible with C++11 range-based for loop. For example such loop
        -: 2166:can be used to safely apply look-up table:
        -: 2167:@code{.cpp}
        -: 2168:void applyTable(Mat_<uchar>& I, const uchar* const table)
        -: 2169:{
        -: 2170:    for(auto& pixel : I)
        -: 2171:    {
        -: 2172:        pixel = table[pixel];
        -: 2173:    }
        -: 2174:}
        -: 2175:@endcode
        -: 2176: */
        -: 2177:template<typename _Tp> class Mat_ : public Mat
        -: 2178:{
        -: 2179:public:
        -: 2180:    typedef _Tp value_type;
        -: 2181:    typedef typename DataType<_Tp>::channel_type channel_type;
        -: 2182:    typedef MatIterator_<_Tp> iterator;
        -: 2183:    typedef MatConstIterator_<_Tp> const_iterator;
        -: 2184:
        -: 2185:    //! default constructor
        -: 2186:    Mat_();
        -: 2187:    //! equivalent to Mat(_rows, _cols, DataType<_Tp>::type)
        -: 2188:    Mat_(int _rows, int _cols);
        -: 2189:    //! constructor that sets each matrix element to specified value
        -: 2190:    Mat_(int _rows, int _cols, const _Tp& value);
        -: 2191:    //! equivalent to Mat(_size, DataType<_Tp>::type)
        -: 2192:    explicit Mat_(Size _size);
        -: 2193:    //! constructor that sets each matrix element to specified value
        -: 2194:    Mat_(Size _size, const _Tp& value);
        -: 2195:    //! n-dim array constructor
        -: 2196:    Mat_(int _ndims, const int* _sizes);
        -: 2197:    //! n-dim array constructor that sets each matrix element to specified value
        -: 2198:    Mat_(int _ndims, const int* _sizes, const _Tp& value);
        -: 2199:    //! copy/conversion constructor. If m is of different type, it's converted
        -: 2200:    Mat_(const Mat& m);
        -: 2201:    //! copy constructor
        -: 2202:    Mat_(const Mat_& m);
        -: 2203:    //! constructs a matrix on top of user-allocated data. step is in bytes(!!!), regardless of the type
        -: 2204:    Mat_(int _rows, int _cols, _Tp* _data, size_t _step=AUTO_STEP);
        -: 2205:    //! constructs n-dim matrix on top of user-allocated data. steps are in bytes(!!!), regardless of the type
        -: 2206:    Mat_(int _ndims, const int* _sizes, _Tp* _data, const size_t* _steps=0);
        -: 2207:    //! selects a submatrix
        -: 2208:    Mat_(const Mat_& m, const Range& rowRange, const Range& colRange=Range::all());
        -: 2209:    //! selects a submatrix
        -: 2210:    Mat_(const Mat_& m, const Rect& roi);
        -: 2211:    //! selects a submatrix, n-dim version
        -: 2212:    Mat_(const Mat_& m, const Range* ranges);
        -: 2213:    //! selects a submatrix, n-dim version
        -: 2214:    Mat_(const Mat_& m, const std::vector<Range>& ranges);
        -: 2215:    //! from a matrix expression
        -: 2216:    explicit Mat_(const MatExpr& e);
        -: 2217:    //! makes a matrix out of Vec, std::vector, Point_ or Point3_. The matrix will have a single column
        -: 2218:    explicit Mat_(const std::vector<_Tp>& vec, bool copyData=false);
        -: 2219:    template<int n> explicit Mat_(const Vec<typename DataType<_Tp>::channel_type, n>& vec, bool copyData=true);
        -: 2220:    template<int m, int n> explicit Mat_(const Matx<typename DataType<_Tp>::channel_type, m, n>& mtx, bool copyData=true);
        -: 2221:    explicit Mat_(const Point_<typename DataType<_Tp>::channel_type>& pt, bool copyData=true);
        -: 2222:    explicit Mat_(const Point3_<typename DataType<_Tp>::channel_type>& pt, bool copyData=true);
        -: 2223:    explicit Mat_(const MatCommaInitializer_<_Tp>& commaInitializer);
        -: 2224:
        -: 2225:    Mat_(std::initializer_list<_Tp> values);
        -: 2226:    explicit Mat_(const std::initializer_list<int> sizes, const std::initializer_list<_Tp> values);
        -: 2227:
        -: 2228:    template <std::size_t _Nm> explicit Mat_(const std::array<_Tp, _Nm>& arr, bool copyData=false);
        -: 2229:
        -: 2230:    Mat_& operator = (const Mat& m);
        -: 2231:    Mat_& operator = (const Mat_& m);
        -: 2232:    //! set all the elements to s.
        -: 2233:    Mat_& operator = (const _Tp& s);
        -: 2234:    //! assign a matrix expression
        -: 2235:    Mat_& operator = (const MatExpr& e);
        -: 2236:
        -: 2237:    //! iterators; they are smart enough to skip gaps in the end of rows
        -: 2238:    iterator begin();
        -: 2239:    iterator end();
        -: 2240:    const_iterator begin() const;
        -: 2241:    const_iterator end() const;
        -: 2242:
        -: 2243:    //! template methods for for operation over all matrix elements.
        -: 2244:    // the operations take care of skipping gaps in the end of rows (if any)
        -: 2245:    template<typename Functor> void forEach(const Functor& operation);
        -: 2246:    template<typename Functor> void forEach(const Functor& operation) const;
        -: 2247:
        -: 2248:    //! equivalent to Mat::create(_rows, _cols, DataType<_Tp>::type)
        -: 2249:    void create(int _rows, int _cols);
        -: 2250:    //! equivalent to Mat::create(_size, DataType<_Tp>::type)
        -: 2251:    void create(Size _size);
        -: 2252:    //! equivalent to Mat::create(_ndims, _sizes, DatType<_Tp>::type)
        -: 2253:    void create(int _ndims, const int* _sizes);
        -: 2254:    //! equivalent to Mat::release()
        -: 2255:    void release();
        -: 2256:    //! cross-product
        -: 2257:    Mat_ cross(const Mat_& m) const;
        -: 2258:    //! data type conversion
        -: 2259:    template<typename T2> operator Mat_<T2>() const;
        -: 2260:    //! overridden forms of Mat::row() etc.
        -: 2261:    Mat_ row(int y) const;
        -: 2262:    Mat_ col(int x) const;
        -: 2263:    Mat_ diag(int d=0) const;
        -: 2264:    Mat_ clone() const CV_NODISCARD;
        -: 2265:
        -: 2266:    //! overridden forms of Mat::elemSize() etc.
        -: 2267:    size_t elemSize() const;
        -: 2268:    size_t elemSize1() const;
        -: 2269:    int type() const;
        -: 2270:    int depth() const;
        -: 2271:    int channels() const;
        -: 2272:    size_t step1(int i=0) const;
        -: 2273:    //! returns step()/sizeof(_Tp)
        -: 2274:    size_t stepT(int i=0) const;
        -: 2275:
        -: 2276:    //! overridden forms of Mat::zeros() etc. Data type is omitted, of course
        -: 2277:    static MatExpr zeros(int rows, int cols);
        -: 2278:    static MatExpr zeros(Size size);
        -: 2279:    static MatExpr zeros(int _ndims, const int* _sizes);
        -: 2280:    static MatExpr ones(int rows, int cols);
        -: 2281:    static MatExpr ones(Size size);
        -: 2282:    static MatExpr ones(int _ndims, const int* _sizes);
        -: 2283:    static MatExpr eye(int rows, int cols);
        -: 2284:    static MatExpr eye(Size size);
        -: 2285:
        -: 2286:    //! some more overridden methods
        -: 2287:    Mat_& adjustROI( int dtop, int dbottom, int dleft, int dright );
        -: 2288:    Mat_ operator()( const Range& rowRange, const Range& colRange ) const;
        -: 2289:    Mat_ operator()( const Rect& roi ) const;
        -: 2290:    Mat_ operator()( const Range* ranges ) const;
        -: 2291:    Mat_ operator()(const std::vector<Range>& ranges) const;
        -: 2292:
        -: 2293:    //! more convenient forms of row and element access operators
        -: 2294:    _Tp* operator [](int y);
        -: 2295:    const _Tp* operator [](int y) const;
        -: 2296:
        -: 2297:    //! returns reference to the specified element
        -: 2298:    _Tp& operator ()(const int* idx);
        -: 2299:    //! returns read-only reference to the specified element
        -: 2300:    const _Tp& operator ()(const int* idx) const;
        -: 2301:
        -: 2302:    //! returns reference to the specified element
        -: 2303:    template<int n> _Tp& operator ()(const Vec<int, n>& idx);
        -: 2304:    //! returns read-only reference to the specified element
        -: 2305:    template<int n> const _Tp& operator ()(const Vec<int, n>& idx) const;
        -: 2306:
        -: 2307:    //! returns reference to the specified element (1D case)
        -: 2308:    _Tp& operator ()(int idx0);
        -: 2309:    //! returns read-only reference to the specified element (1D case)
        -: 2310:    const _Tp& operator ()(int idx0) const;
        -: 2311:    //! returns reference to the specified element (2D case)
        -: 2312:    _Tp& operator ()(int row, int col);
        -: 2313:    //! returns read-only reference to the specified element (2D case)
        -: 2314:    const _Tp& operator ()(int row, int col) const;
        -: 2315:    //! returns reference to the specified element (3D case)
        -: 2316:    _Tp& operator ()(int idx0, int idx1, int idx2);
        -: 2317:    //! returns read-only reference to the specified element (3D case)
        -: 2318:    const _Tp& operator ()(int idx0, int idx1, int idx2) const;
        -: 2319:
        -: 2320:    _Tp& operator ()(Point pt);
        -: 2321:    const _Tp& operator ()(Point pt) const;
        -: 2322:
        -: 2323:    //! conversion to vector.
        -: 2324:    operator std::vector<_Tp>() const;
        -: 2325:
        -: 2326:    //! conversion to array.
        -: 2327:    template<std::size_t _Nm> operator std::array<_Tp, _Nm>() const;
        -: 2328:
        -: 2329:    //! conversion to Vec
        -: 2330:    template<int n> operator Vec<typename DataType<_Tp>::channel_type, n>() const;
        -: 2331:    //! conversion to Matx
        -: 2332:    template<int m, int n> operator Matx<typename DataType<_Tp>::channel_type, m, n>() const;
        -: 2333:
        -: 2334:    Mat_(Mat_&& m);
        -: 2335:    Mat_& operator = (Mat_&& m);
        -: 2336:
        -: 2337:    Mat_(Mat&& m);
        -: 2338:    Mat_& operator = (Mat&& m);
        -: 2339:
        -: 2340:    Mat_(MatExpr&& e);
        -: 2341:};
        -: 2342:
        -: 2343:typedef Mat_<uchar> Mat1b;
        -: 2344:typedef Mat_<Vec2b> Mat2b;
        -: 2345:typedef Mat_<Vec3b> Mat3b;
        -: 2346:typedef Mat_<Vec4b> Mat4b;
        -: 2347:
        -: 2348:typedef Mat_<short> Mat1s;
        -: 2349:typedef Mat_<Vec2s> Mat2s;
        -: 2350:typedef Mat_<Vec3s> Mat3s;
        -: 2351:typedef Mat_<Vec4s> Mat4s;
        -: 2352:
        -: 2353:typedef Mat_<ushort> Mat1w;
        -: 2354:typedef Mat_<Vec2w> Mat2w;
        -: 2355:typedef Mat_<Vec3w> Mat3w;
        -: 2356:typedef Mat_<Vec4w> Mat4w;
        -: 2357:
        -: 2358:typedef Mat_<int>   Mat1i;
        -: 2359:typedef Mat_<Vec2i> Mat2i;
        -: 2360:typedef Mat_<Vec3i> Mat3i;
        -: 2361:typedef Mat_<Vec4i> Mat4i;
        -: 2362:
        -: 2363:typedef Mat_<float> Mat1f;
        -: 2364:typedef Mat_<Vec2f> Mat2f;
        -: 2365:typedef Mat_<Vec3f> Mat3f;
        -: 2366:typedef Mat_<Vec4f> Mat4f;
        -: 2367:
        -: 2368:typedef Mat_<double> Mat1d;
        -: 2369:typedef Mat_<Vec2d> Mat2d;
        -: 2370:typedef Mat_<Vec3d> Mat3d;
        -: 2371:typedef Mat_<Vec4d> Mat4d;
        -: 2372:
        -: 2373:/** @todo document */
        -: 2374:class CV_EXPORTS UMat
        -: 2375:{
        -: 2376:public:
        -: 2377:    //! default constructor
        -: 2378:    UMat(UMatUsageFlags usageFlags = USAGE_DEFAULT);
        -: 2379:    //! constructs 2D matrix of the specified size and type
        -: 2380:    // (_type is CV_8UC1, CV_64FC3, CV_32SC(12) etc.)
        -: 2381:    UMat(int rows, int cols, int type, UMatUsageFlags usageFlags = USAGE_DEFAULT);
        -: 2382:    UMat(Size size, int type, UMatUsageFlags usageFlags = USAGE_DEFAULT);
        -: 2383:    //! constructs 2D matrix and fills it with the specified value _s.
        -: 2384:    UMat(int rows, int cols, int type, const Scalar& s, UMatUsageFlags usageFlags = USAGE_DEFAULT);
        -: 2385:    UMat(Size size, int type, const Scalar& s, UMatUsageFlags usageFlags = USAGE_DEFAULT);
        -: 2386:
        -: 2387:    //! constructs n-dimensional matrix
        -: 2388:    UMat(int ndims, const int* sizes, int type, UMatUsageFlags usageFlags = USAGE_DEFAULT);
        -: 2389:    UMat(int ndims, const int* sizes, int type, const Scalar& s, UMatUsageFlags usageFlags = USAGE_DEFAULT);
        -: 2390:
        -: 2391:    //! copy constructor
        -: 2392:    UMat(const UMat& m);
        -: 2393:
        -: 2394:    //! creates a matrix header for a part of the bigger matrix
        -: 2395:    UMat(const UMat& m, const Range& rowRange, const Range& colRange=Range::all());
        -: 2396:    UMat(const UMat& m, const Rect& roi);
        -: 2397:    UMat(const UMat& m, const Range* ranges);
        -: 2398:    UMat(const UMat& m, const std::vector<Range>& ranges);
        -: 2399:    //! builds matrix from std::vector with or without copying the data
        -: 2400:    template<typename _Tp> explicit UMat(const std::vector<_Tp>& vec, bool copyData=false);
        -: 2401:
        -: 2402:    //! builds matrix from cv::Vec; the data is copied by default
        -: 2403:    template<typename _Tp, int n> explicit UMat(const Vec<_Tp, n>& vec, bool copyData=true);
        -: 2404:    //! builds matrix from cv::Matx; the data is copied by default
        -: 2405:    template<typename _Tp, int m, int n> explicit UMat(const Matx<_Tp, m, n>& mtx, bool copyData=true);
        -: 2406:    //! builds matrix from a 2D point
        -: 2407:    template<typename _Tp> explicit UMat(const Point_<_Tp>& pt, bool copyData=true);
        -: 2408:    //! builds matrix from a 3D point
        -: 2409:    template<typename _Tp> explicit UMat(const Point3_<_Tp>& pt, bool copyData=true);
        -: 2410:    //! builds matrix from comma initializer
        -: 2411:    template<typename _Tp> explicit UMat(const MatCommaInitializer_<_Tp>& commaInitializer);
        -: 2412:
        -: 2413:    //! destructor - calls release()
        -: 2414:    ~UMat();
        -: 2415:    //! assignment operators
        -: 2416:    UMat& operator = (const UMat& m);
        -: 2417:
        -: 2418:    Mat getMat(AccessFlag flags) const;
        -: 2419:
        -: 2420:    //! returns a new matrix header for the specified row
        -: 2421:    UMat row(int y) const;
        -: 2422:    //! returns a new matrix header for the specified column
        -: 2423:    UMat col(int x) const;
        -: 2424:    //! ... for the specified row span
        -: 2425:    UMat rowRange(int startrow, int endrow) const;
        -: 2426:    UMat rowRange(const Range& r) const;
        -: 2427:    //! ... for the specified column span
        -: 2428:    UMat colRange(int startcol, int endcol) const;
        -: 2429:    UMat colRange(const Range& r) const;
        -: 2430:    //! ... for the specified diagonal
        -: 2431:    //! (d=0 - the main diagonal,
        -: 2432:    //!  >0 - a diagonal from the upper half,
        -: 2433:    //!  <0 - a diagonal from the lower half)
        -: 2434:    UMat diag(int d=0) const;
        -: 2435:    //! constructs a square diagonal matrix which main diagonal is vector "d"
        -: 2436:    static UMat diag(const UMat& d);
        -: 2437:
        -: 2438:    //! returns deep copy of the matrix, i.e. the data is copied
        -: 2439:    UMat clone() const CV_NODISCARD;
        -: 2440:    //! copies the matrix content to "m".
        -: 2441:    // It calls m.create(this->size(), this->type()).
        -: 2442:    void copyTo( OutputArray m ) const;
        -: 2443:    //! copies those matrix elements to "m" that are marked with non-zero mask elements.
        -: 2444:    void copyTo( OutputArray m, InputArray mask ) const;
        -: 2445:    //! converts matrix to another datatype with optional scaling. See cvConvertScale.
        -: 2446:    void convertTo( OutputArray m, int rtype, double alpha=1, double beta=0 ) const;
        -: 2447:
        -: 2448:    void assignTo( UMat& m, int type=-1 ) const;
        -: 2449:
        -: 2450:    //! sets every matrix element to s
        -: 2451:    UMat& operator = (const Scalar& s);
        -: 2452:    //! sets some of the matrix elements to s, according to the mask
        -: 2453:    UMat& setTo(InputArray value, InputArray mask=noArray());
        -: 2454:    //! creates alternative matrix header for the same data, with different
        -: 2455:    // number of channels and/or different number of rows. see cvReshape.
        -: 2456:    UMat reshape(int cn, int rows=0) const;
        -: 2457:    UMat reshape(int cn, int newndims, const int* newsz) const;
        -: 2458:
        -: 2459:    //! matrix transposition by means of matrix expressions
        -: 2460:    UMat t() const;
        -: 2461:    //! matrix inversion by means of matrix expressions
        -: 2462:    UMat inv(int method=DECOMP_LU) const;
        -: 2463:    //! per-element matrix multiplication by means of matrix expressions
        -: 2464:    UMat mul(InputArray m, double scale=1) const;
        -: 2465:
        -: 2466:    //! computes dot-product
        -: 2467:    double dot(InputArray m) const;
        -: 2468:
        -: 2469:    //! Matlab-style matrix initialization
        -: 2470:    static UMat zeros(int rows, int cols, int type);
        -: 2471:    static UMat zeros(Size size, int type);
        -: 2472:    static UMat zeros(int ndims, const int* sz, int type);
        -: 2473:    static UMat ones(int rows, int cols, int type);
        -: 2474:    static UMat ones(Size size, int type);
        -: 2475:    static UMat ones(int ndims, const int* sz, int type);
        -: 2476:    static UMat eye(int rows, int cols, int type);
        -: 2477:    static UMat eye(Size size, int type);
        -: 2478:
        -: 2479:    //! allocates new matrix data unless the matrix already has specified size and type.
        -: 2480:    // previous data is unreferenced if needed.
        -: 2481:    void create(int rows, int cols, int type, UMatUsageFlags usageFlags = USAGE_DEFAULT);
        -: 2482:    void create(Size size, int type, UMatUsageFlags usageFlags = USAGE_DEFAULT);
        -: 2483:    void create(int ndims, const int* sizes, int type, UMatUsageFlags usageFlags = USAGE_DEFAULT);
        -: 2484:    void create(const std::vector<int>& sizes, int type, UMatUsageFlags usageFlags = USAGE_DEFAULT);
        -: 2485:
        -: 2486:    //! increases the reference counter; use with care to avoid memleaks
        -: 2487:    void addref();
        -: 2488:    //! decreases reference counter;
        -: 2489:    // deallocates the data when reference counter reaches 0.
        -: 2490:    void release();
        -: 2491:
        -: 2492:    //! deallocates the matrix data
        -: 2493:    void deallocate();
        -: 2494:    //! internal use function; properly re-allocates _size, _step arrays
        -: 2495:    void copySize(const UMat& m);
        -: 2496:
        -: 2497:    //! locates matrix header within a parent matrix. See below
        -: 2498:    void locateROI( Size& wholeSize, Point& ofs ) const;
        -: 2499:    //! moves/resizes the current matrix ROI inside the parent matrix.
        -: 2500:    UMat& adjustROI( int dtop, int dbottom, int dleft, int dright );
        -: 2501:    //! extracts a rectangular sub-matrix
        -: 2502:    // (this is a generalized form of row, rowRange etc.)
        -: 2503:    UMat operator()( Range rowRange, Range colRange ) const;
        -: 2504:    UMat operator()( const Rect& roi ) const;
        -: 2505:    UMat operator()( const Range* ranges ) const;
        -: 2506:    UMat operator()(const std::vector<Range>& ranges) const;
        -: 2507:
        -: 2508:    //! returns true iff the matrix data is continuous
        -: 2509:    // (i.e. when there are no gaps between successive rows).
        -: 2510:    // similar to CV_IS_MAT_CONT(cvmat->type)
        -: 2511:    bool isContinuous() const;
        -: 2512:
        -: 2513:    //! returns true if the matrix is a submatrix of another matrix
        -: 2514:    bool isSubmatrix() const;
        -: 2515:
        -: 2516:    //! returns element size in bytes,
        -: 2517:    // similar to CV_ELEM_SIZE(cvmat->type)
        -: 2518:    size_t elemSize() const;
        -: 2519:    //! returns the size of element channel in bytes.
        -: 2520:    size_t elemSize1() const;
        -: 2521:    //! returns element type, similar to CV_MAT_TYPE(cvmat->type)
        -: 2522:    int type() const;
        -: 2523:    //! returns element type, similar to CV_MAT_DEPTH(cvmat->type)
        -: 2524:    int depth() const;
        -: 2525:    //! returns element type, similar to CV_MAT_CN(cvmat->type)
        -: 2526:    int channels() const;
        -: 2527:    //! returns step/elemSize1()
        -: 2528:    size_t step1(int i=0) const;
        -: 2529:    //! returns true if matrix data is NULL
        -: 2530:    bool empty() const;
        -: 2531:    //! returns the total number of matrix elements
        -: 2532:    size_t total() const;
        -: 2533:
        -: 2534:    //! returns N if the matrix is 1-channel (N x ptdim) or ptdim-channel (1 x N) or (N x 1); negative number otherwise
        -: 2535:    int checkVector(int elemChannels, int depth=-1, bool requireContinuous=true) const;
        -: 2536:
        -: 2537:    UMat(UMat&& m);
        -: 2538:    UMat& operator = (UMat&& m);
        -: 2539:
        -: 2540:    /*! Returns the OpenCL buffer handle on which UMat operates on.
        -: 2541:        The UMat instance should be kept alive during the use of the handle to prevent the buffer to be
        -: 2542:        returned to the OpenCV buffer pool.
        -: 2543:     */
        -: 2544:    void* handle(AccessFlag accessFlags) const;
        -: 2545:    void ndoffset(size_t* ofs) const;
        -: 2546:
        -: 2547:    enum { MAGIC_VAL  = 0x42FF0000, AUTO_STEP = 0, CONTINUOUS_FLAG = CV_MAT_CONT_FLAG, SUBMATRIX_FLAG = CV_SUBMAT_FLAG };
        -: 2548:    enum { MAGIC_MASK = 0xFFFF0000, TYPE_MASK = 0x00000FFF, DEPTH_MASK = 7 };
        -: 2549:
        -: 2550:    /*! includes several bit-fields:
        -: 2551:         - the magic signature
        -: 2552:         - continuity flag
        -: 2553:         - depth
        -: 2554:         - number of channels
        -: 2555:     */
        -: 2556:    int flags;
        -: 2557:    //! the matrix dimensionality, >= 2
        -: 2558:    int dims;
        -: 2559:    //! the number of rows and columns or (-1, -1) when the matrix has more than 2 dimensions
        -: 2560:    int rows, cols;
        -: 2561:
        -: 2562:    //! custom allocator
        -: 2563:    MatAllocator* allocator;
        -: 2564:    UMatUsageFlags usageFlags; // usage flags for allocator
        -: 2565:    //! and the standard allocator
        -: 2566:    static MatAllocator* getStdAllocator();
        -: 2567:
        -: 2568:    //! internal use method: updates the continuity flag
        -: 2569:    void updateContinuityFlag();
        -: 2570:
        -: 2571:    // black-box container of UMat data
        -: 2572:    UMatData* u;
        -: 2573:
        -: 2574:    // offset of the submatrix (or 0)
        -: 2575:    size_t offset;
        -: 2576:
        -: 2577:    MatSize size;
        -: 2578:    MatStep step;
        -: 2579:
        -: 2580:protected:
        -: 2581:};
        -: 2582:
        -: 2583:
        -: 2584://///////////////////////// multi-dimensional sparse matrix //////////////////////////
        -: 2585:
        -: 2586:/** @brief The class SparseMat represents multi-dimensional sparse numerical arrays.
        -: 2587:
        -: 2588:Such a sparse array can store elements of any type that Mat can store. *Sparse* means that only
        -: 2589:non-zero elements are stored (though, as a result of operations on a sparse matrix, some of its
        -: 2590:stored elements can actually become 0. It is up to you to detect such elements and delete them
        -: 2591:using SparseMat::erase ). The non-zero elements are stored in a hash table that grows when it is
        -: 2592:filled so that the search time is O(1) in average (regardless of whether element is there or not).
        -: 2593:Elements can be accessed using the following methods:
        -: 2594:-   Query operations (SparseMat::ptr and the higher-level SparseMat::ref, SparseMat::value and
        -: 2595:    SparseMat::find), for example:
        -: 2596:    @code
        -: 2597:        const int dims = 5;
        -: 2598:        int size[5] = {10, 10, 10, 10, 10};
        -: 2599:        SparseMat sparse_mat(dims, size, CV_32F);
        -: 2600:        for(int i = 0; i < 1000; i++)
        -: 2601:        {
        -: 2602:            int idx[dims];
        -: 2603:            for(int k = 0; k < dims; k++)
        -: 2604:                idx[k] = rand() % size[k];
        -: 2605:            sparse_mat.ref<float>(idx) += 1.f;
        -: 2606:        }
        -: 2607:        cout << "nnz = " << sparse_mat.nzcount() << endl;
        -: 2608:    @endcode
        -: 2609:-   Sparse matrix iterators. They are similar to MatIterator but different from NAryMatIterator.
        -: 2610:    That is, the iteration loop is familiar to STL users:
        -: 2611:    @code
        -: 2612:        // prints elements of a sparse floating-point matrix
        -: 2613:        // and the sum of elements.
        -: 2614:        SparseMatConstIterator_<float>
        -: 2615:            it = sparse_mat.begin<float>(),
        -: 2616:            it_end = sparse_mat.end<float>();
        -: 2617:        double s = 0;
        -: 2618:        int dims = sparse_mat.dims();
        -: 2619:        for(; it != it_end; ++it)
        -: 2620:        {
        -: 2621:            // print element indices and the element value
        -: 2622:            const SparseMat::Node* n = it.node();
        -: 2623:            printf("(");
        -: 2624:            for(int i = 0; i < dims; i++)
        -: 2625:                printf("%d%s", n->idx[i], i < dims-1 ? ", " : ")");
        -: 2626:            printf(": %g\n", it.value<float>());
        -: 2627:            s += *it;
        -: 2628:        }
        -: 2629:        printf("Element sum is %g\n", s);
        -: 2630:    @endcode
        -: 2631:    If you run this loop, you will notice that elements are not enumerated in a logical order
        -: 2632:    (lexicographical, and so on). They come in the same order as they are stored in the hash table
        -: 2633:    (semi-randomly). You may collect pointers to the nodes and sort them to get the proper ordering.
        -: 2634:    Note, however, that pointers to the nodes may become invalid when you add more elements to the
        -: 2635:    matrix. This may happen due to possible buffer reallocation.
        -: 2636:-   Combination of the above 2 methods when you need to process 2 or more sparse matrices
        -: 2637:    simultaneously. For example, this is how you can compute unnormalized cross-correlation of the 2
        -: 2638:    floating-point sparse matrices:
        -: 2639:    @code
        -: 2640:        double cross_corr(const SparseMat& a, const SparseMat& b)
        -: 2641:        {
        -: 2642:            const SparseMat *_a = &a, *_b = &b;
        -: 2643:            // if b contains less elements than a,
        -: 2644:            // it is faster to iterate through b
        -: 2645:            if(_a->nzcount() > _b->nzcount())
        -: 2646:                std::swap(_a, _b);
        -: 2647:            SparseMatConstIterator_<float> it = _a->begin<float>(),
        -: 2648:                                           it_end = _a->end<float>();
        -: 2649:            double ccorr = 0;
        -: 2650:            for(; it != it_end; ++it)
        -: 2651:            {
        -: 2652:                // take the next element from the first matrix
        -: 2653:                float avalue = *it;
        -: 2654:                const Node* anode = it.node();
        -: 2655:                // and try to find an element with the same index in the second matrix.
        -: 2656:                // since the hash value depends only on the element index,
        -: 2657:                // reuse the hash value stored in the node
        -: 2658:                float bvalue = _b->value<float>(anode->idx,&anode->hashval);
        -: 2659:                ccorr += avalue*bvalue;
        -: 2660:            }
        -: 2661:            return ccorr;
        -: 2662:        }
        -: 2663:    @endcode
        -: 2664: */
        -: 2665:class CV_EXPORTS SparseMat
        -: 2666:{
        -: 2667:public:
        -: 2668:    typedef SparseMatIterator iterator;
        -: 2669:    typedef SparseMatConstIterator const_iterator;
        -: 2670:
        -: 2671:    enum { MAGIC_VAL=0x42FD0000, MAX_DIM=32, HASH_SCALE=0x5bd1e995, HASH_BIT=0x80000000 };
        -: 2672:
        -: 2673:    //! the sparse matrix header
        -: 2674:    struct CV_EXPORTS Hdr
        -: 2675:    {
        -: 2676:        Hdr(int _dims, const int* _sizes, int _type);
        -: 2677:        void clear();
        -: 2678:        int refcount;
        -: 2679:        int dims;
        -: 2680:        int valueOffset;
        -: 2681:        size_t nodeSize;
        -: 2682:        size_t nodeCount;
        -: 2683:        size_t freeList;
        -: 2684:        std::vector<uchar> pool;
        -: 2685:        std::vector<size_t> hashtab;
        -: 2686:        int size[MAX_DIM];
        -: 2687:    };
        -: 2688:
        -: 2689:    //! sparse matrix node - element of a hash table
        -: 2690:    struct CV_EXPORTS Node
        -: 2691:    {
        -: 2692:        //! hash value
        -: 2693:        size_t hashval;
        -: 2694:        //! index of the next node in the same hash table entry
        -: 2695:        size_t next;
        -: 2696:        //! index of the matrix element
        -: 2697:        int idx[MAX_DIM];
        -: 2698:    };
        -: 2699:
        -: 2700:    /** @brief Various SparseMat constructors.
        -: 2701:     */
        -: 2702:    SparseMat();
        -: 2703:
        -: 2704:    /** @overload
        -: 2705:    @param dims Array dimensionality.
        -: 2706:    @param _sizes Sparce matrix size on all dementions.
        -: 2707:    @param _type Sparse matrix data type.
        -: 2708:    */
        -: 2709:    SparseMat(int dims, const int* _sizes, int _type);
        -: 2710:
        -: 2711:    /** @overload
        -: 2712:    @param m Source matrix for copy constructor. If m is dense matrix (ocvMat) then it will be converted
        -: 2713:    to sparse representation.
        -: 2714:    */
        -: 2715:    SparseMat(const SparseMat& m);
        -: 2716:
        -: 2717:    /** @overload
        -: 2718:    @param m Source matrix for copy constructor. If m is dense matrix (ocvMat) then it will be converted
        -: 2719:    to sparse representation.
        -: 2720:    */
        -: 2721:    explicit SparseMat(const Mat& m);
        -: 2722:
        -: 2723:    //! the destructor
        -: 2724:    ~SparseMat();
        -: 2725:
        -: 2726:    //! assignment operator. This is O(1) operation, i.e. no data is copied
        -: 2727:    SparseMat& operator = (const SparseMat& m);
        -: 2728:    //! equivalent to the corresponding constructor
        -: 2729:    SparseMat& operator = (const Mat& m);
        -: 2730:
        -: 2731:    //! creates full copy of the matrix
        -: 2732:    SparseMat clone() const CV_NODISCARD;
        -: 2733:
        -: 2734:    //! copies all the data to the destination matrix. All the previous content of m is erased
        -: 2735:    void copyTo( SparseMat& m ) const;
        -: 2736:    //! converts sparse matrix to dense matrix.
        -: 2737:    void copyTo( Mat& m ) const;
        -: 2738:    //! multiplies all the matrix elements by the specified scale factor alpha and converts the results to the specified data type
        -: 2739:    void convertTo( SparseMat& m, int rtype, double alpha=1 ) const;
        -: 2740:    //! converts sparse matrix to dense n-dim matrix with optional type conversion and scaling.
        -: 2741:    /*!
        -: 2742:        @param [out] m - output matrix; if it does not have a proper size or type before the operation,
        -: 2743:            it is reallocated
        -: 2744:        @param [in] rtype - desired output matrix type or, rather, the depth since the number of channels
        -: 2745:            are the same as the input has; if rtype is negative, the output matrix will have the
        -: 2746:            same type as the input.
        -: 2747:        @param [in] alpha - optional scale factor
        -: 2748:        @param [in] beta - optional delta added to the scaled values
        -: 2749:    */
        -: 2750:    void convertTo( Mat& m, int rtype, double alpha=1, double beta=0 ) const;
        -: 2751:
        -: 2752:    // not used now
        -: 2753:    void assignTo( SparseMat& m, int type=-1 ) const;
        -: 2754:
        -: 2755:    //! reallocates sparse matrix.
        -: 2756:    /*!
        -: 2757:        If the matrix already had the proper size and type,
        -: 2758:        it is simply cleared with clear(), otherwise,
        -: 2759:        the old matrix is released (using release()) and the new one is allocated.
        -: 2760:    */
        -: 2761:    void create(int dims, const int* _sizes, int _type);
        -: 2762:    //! sets all the sparse matrix elements to 0, which means clearing the hash table.
        -: 2763:    void clear();
        -: 2764:    //! manually increments the reference counter to the header.
        -: 2765:    void addref();
        -: 2766:    // decrements the header reference counter. When the counter reaches 0, the header and all the underlying data are deallocated.
        -: 2767:    void release();
        -: 2768:
        -: 2769:    //! converts sparse matrix to the old-style representation; all the elements are copied.
        -: 2770:    //operator CvSparseMat*() const;
        -: 2771:    //! returns the size of each element in bytes (not including the overhead - the space occupied by SparseMat::Node elements)
        -: 2772:    size_t elemSize() const;
        -: 2773:    //! returns elemSize()/channels()
        -: 2774:    size_t elemSize1() const;
        -: 2775:
        -: 2776:    //! returns type of sparse matrix elements
        -: 2777:    int type() const;
        -: 2778:    //! returns the depth of sparse matrix elements
        -: 2779:    int depth() const;
        -: 2780:    //! returns the number of channels
        -: 2781:    int channels() const;
        -: 2782:
        -: 2783:    //! returns the array of sizes, or NULL if the matrix is not allocated
        -: 2784:    const int* size() const;
        -: 2785:    //! returns the size of i-th matrix dimension (or 0)
        -: 2786:    int size(int i) const;
        -: 2787:    //! returns the matrix dimensionality
        -: 2788:    int dims() const;
        -: 2789:    //! returns the number of non-zero elements (=the number of hash table nodes)
        -: 2790:    size_t nzcount() const;
        -: 2791:
        -: 2792:    //! computes the element hash value (1D case)
        -: 2793:    size_t hash(int i0) const;
        -: 2794:    //! computes the element hash value (2D case)
        -: 2795:    size_t hash(int i0, int i1) const;
        -: 2796:    //! computes the element hash value (3D case)
        -: 2797:    size_t hash(int i0, int i1, int i2) const;
        -: 2798:    //! computes the element hash value (nD case)
        -: 2799:    size_t hash(const int* idx) const;
        -: 2800:
        -: 2801:    //!@{
        -: 2802:    /*!
        -: 2803:     specialized variants for 1D, 2D, 3D cases and the generic_type one for n-D case.
        -: 2804:     return pointer to the matrix element.
        -: 2805:      - if the element is there (it's non-zero), the pointer to it is returned
        -: 2806:      - if it's not there and createMissing=false, NULL pointer is returned
        -: 2807:      - if it's not there and createMissing=true, then the new element
        -: 2808:        is created and initialized with 0. Pointer to it is returned
        -: 2809:      - if the optional hashval pointer is not NULL, the element hash value is
        -: 2810:        not computed, but *hashval is taken instead.
        -: 2811:    */
        -: 2812:    //! returns pointer to the specified element (1D case)
        -: 2813:    uchar* ptr(int i0, bool createMissing, size_t* hashval=0);
        -: 2814:    //! returns pointer to the specified element (2D case)
        -: 2815:    uchar* ptr(int i0, int i1, bool createMissing, size_t* hashval=0);
        -: 2816:    //! returns pointer to the specified element (3D case)
        -: 2817:    uchar* ptr(int i0, int i1, int i2, bool createMissing, size_t* hashval=0);
        -: 2818:    //! returns pointer to the specified element (nD case)
        -: 2819:    uchar* ptr(const int* idx, bool createMissing, size_t* hashval=0);
        -: 2820:    //!@}
        -: 2821:
        -: 2822:    //!@{
        -: 2823:    /*!
        -: 2824:     return read-write reference to the specified sparse matrix element.
        -: 2825:
        -: 2826:     `ref<_Tp>(i0,...[,hashval])` is equivalent to `*(_Tp*)ptr(i0,...,true[,hashval])`.
        -: 2827:     The methods always return a valid reference.
        -: 2828:     If the element did not exist, it is created and initialized with 0.
        -: 2829:    */
        -: 2830:    //! returns reference to the specified element (1D case)
        -: 2831:    template<typename _Tp> _Tp& ref(int i0, size_t* hashval=0);
        -: 2832:    //! returns reference to the specified element (2D case)
        -: 2833:    template<typename _Tp> _Tp& ref(int i0, int i1, size_t* hashval=0);
        -: 2834:    //! returns reference to the specified element (3D case)
        -: 2835:    template<typename _Tp> _Tp& ref(int i0, int i1, int i2, size_t* hashval=0);
        -: 2836:    //! returns reference to the specified element (nD case)
        -: 2837:    template<typename _Tp> _Tp& ref(const int* idx, size_t* hashval=0);
        -: 2838:    //!@}
        -: 2839:
        -: 2840:    //!@{
        -: 2841:    /*!
        -: 2842:     return value of the specified sparse matrix element.
        -: 2843:
        -: 2844:     `value<_Tp>(i0,...[,hashval])` is equivalent to
        -: 2845:     @code
        -: 2846:     { const _Tp* p = find<_Tp>(i0,...[,hashval]); return p ? *p : _Tp(); }
        -: 2847:     @endcode
        -: 2848:
        -: 2849:     That is, if the element did not exist, the methods return 0.
        -: 2850:     */
        -: 2851:    //! returns value of the specified element (1D case)
        -: 2852:    template<typename _Tp> _Tp value(int i0, size_t* hashval=0) const;
        -: 2853:    //! returns value of the specified element (2D case)
        -: 2854:    template<typename _Tp> _Tp value(int i0, int i1, size_t* hashval=0) const;
        -: 2855:    //! returns value of the specified element (3D case)
        -: 2856:    template<typename _Tp> _Tp value(int i0, int i1, int i2, size_t* hashval=0) const;
        -: 2857:    //! returns value of the specified element (nD case)
        -: 2858:    template<typename _Tp> _Tp value(const int* idx, size_t* hashval=0) const;
        -: 2859:    //!@}
        -: 2860:
        -: 2861:    //!@{
        -: 2862:    /*!
        -: 2863:     Return pointer to the specified sparse matrix element if it exists
        -: 2864:
        -: 2865:     `find<_Tp>(i0,...[,hashval])` is equivalent to `(_const Tp*)ptr(i0,...false[,hashval])`.
        -: 2866:
        -: 2867:     If the specified element does not exist, the methods return NULL.
        -: 2868:    */
        -: 2869:    //! returns pointer to the specified element (1D case)
        -: 2870:    template<typename _Tp> const _Tp* find(int i0, size_t* hashval=0) const;
        -: 2871:    //! returns pointer to the specified element (2D case)
        -: 2872:    template<typename _Tp> const _Tp* find(int i0, int i1, size_t* hashval=0) const;
        -: 2873:    //! returns pointer to the specified element (3D case)
        -: 2874:    template<typename _Tp> const _Tp* find(int i0, int i1, int i2, size_t* hashval=0) const;
        -: 2875:    //! returns pointer to the specified element (nD case)
        -: 2876:    template<typename _Tp> const _Tp* find(const int* idx, size_t* hashval=0) const;
        -: 2877:    //!@}
        -: 2878:
        -: 2879:    //! erases the specified element (2D case)
        -: 2880:    void erase(int i0, int i1, size_t* hashval=0);
        -: 2881:    //! erases the specified element (3D case)
        -: 2882:    void erase(int i0, int i1, int i2, size_t* hashval=0);
        -: 2883:    //! erases the specified element (nD case)
        -: 2884:    void erase(const int* idx, size_t* hashval=0);
        -: 2885:
        -: 2886:    //!@{
        -: 2887:    /*!
        -: 2888:       return the sparse matrix iterator pointing to the first sparse matrix element
        -: 2889:    */
        -: 2890:    //! returns the sparse matrix iterator at the matrix beginning
        -: 2891:    SparseMatIterator begin();
        -: 2892:    //! returns the sparse matrix iterator at the matrix beginning
        -: 2893:    template<typename _Tp> SparseMatIterator_<_Tp> begin();
        -: 2894:    //! returns the read-only sparse matrix iterator at the matrix beginning
        -: 2895:    SparseMatConstIterator begin() const;
        -: 2896:    //! returns the read-only sparse matrix iterator at the matrix beginning
        -: 2897:    template<typename _Tp> SparseMatConstIterator_<_Tp> begin() const;
        -: 2898:    //!@}
        -: 2899:    /*!
        -: 2900:       return the sparse matrix iterator pointing to the element following the last sparse matrix element
        -: 2901:    */
        -: 2902:    //! returns the sparse matrix iterator at the matrix end
        -: 2903:    SparseMatIterator end();
        -: 2904:    //! returns the read-only sparse matrix iterator at the matrix end
        -: 2905:    SparseMatConstIterator end() const;
        -: 2906:    //! returns the typed sparse matrix iterator at the matrix end
        -: 2907:    template<typename _Tp> SparseMatIterator_<_Tp> end();
        -: 2908:    //! returns the typed read-only sparse matrix iterator at the matrix end
        -: 2909:    template<typename _Tp> SparseMatConstIterator_<_Tp> end() const;
        -: 2910:
        -: 2911:    //! returns the value stored in the sparse martix node
        -: 2912:    template<typename _Tp> _Tp& value(Node* n);
        -: 2913:    //! returns the value stored in the sparse martix node
        -: 2914:    template<typename _Tp> const _Tp& value(const Node* n) const;
        -: 2915:
        -: 2916:    ////////////// some internal-use methods ///////////////
        -: 2917:    Node* node(size_t nidx);
        -: 2918:    const Node* node(size_t nidx) const;
        -: 2919:
        -: 2920:    uchar* newNode(const int* idx, size_t hashval);
        -: 2921:    void removeNode(size_t hidx, size_t nidx, size_t previdx);
        -: 2922:    void resizeHashTab(size_t newsize);
        -: 2923:
        -: 2924:    int flags;
        -: 2925:    Hdr* hdr;
        -: 2926:};
        -: 2927:
        -: 2928:
        -: 2929:
        -: 2930:///////////////////////////////// SparseMat_<_Tp> ////////////////////////////////////
        -: 2931:
        -: 2932:/** @brief Template sparse n-dimensional array class derived from SparseMat
        -: 2933:
        -: 2934:SparseMat_ is a thin wrapper on top of SparseMat created in the same way as Mat_ . It simplifies
        -: 2935:notation of some operations:
        -: 2936:@code
        -: 2937:    int sz[] = {10, 20, 30};
        -: 2938:    SparseMat_<double> M(3, sz);
        -: 2939:    ...
        -: 2940:    M.ref(1, 2, 3) = M(4, 5, 6) + M(7, 8, 9);
        -: 2941:@endcode
        -: 2942: */
        -: 2943:template<typename _Tp> class SparseMat_ : public SparseMat
        -: 2944:{
        -: 2945:public:
        -: 2946:    typedef SparseMatIterator_<_Tp> iterator;
        -: 2947:    typedef SparseMatConstIterator_<_Tp> const_iterator;
        -: 2948:
        -: 2949:    //! the default constructor
        -: 2950:    SparseMat_();
        -: 2951:    //! the full constructor equivalent to SparseMat(dims, _sizes, DataType<_Tp>::type)
        -: 2952:    SparseMat_(int dims, const int* _sizes);
        -: 2953:    //! the copy constructor. If DataType<_Tp>.type != m.type(), the m elements are converted
        -: 2954:    SparseMat_(const SparseMat& m);
        -: 2955:    //! the copy constructor. This is O(1) operation - no data is copied
        -: 2956:    SparseMat_(const SparseMat_& m);
        -: 2957:    //! converts dense matrix to the sparse form
        -: 2958:    SparseMat_(const Mat& m);
        -: 2959:    //! converts the old-style sparse matrix to the C++ class. All the elements are copied
        -: 2960:    //SparseMat_(const CvSparseMat* m);
        -: 2961:    //! the assignment operator. If DataType<_Tp>.type != m.type(), the m elements are converted
        -: 2962:    SparseMat_& operator = (const SparseMat& m);
        -: 2963:    //! the assignment operator. This is O(1) operation - no data is copied
        -: 2964:    SparseMat_& operator = (const SparseMat_& m);
        -: 2965:    //! converts dense matrix to the sparse form
        -: 2966:    SparseMat_& operator = (const Mat& m);
        -: 2967:
        -: 2968:    //! makes full copy of the matrix. All the elements are duplicated
        -: 2969:    SparseMat_ clone() const CV_NODISCARD;
        -: 2970:    //! equivalent to cv::SparseMat::create(dims, _sizes, DataType<_Tp>::type)
        -: 2971:    void create(int dims, const int* _sizes);
        -: 2972:    //! converts sparse matrix to the old-style CvSparseMat. All the elements are copied
        -: 2973:    //operator CvSparseMat*() const;
        -: 2974:
        -: 2975:    //! returns type of the matrix elements
        -: 2976:    int type() const;
        -: 2977:    //! returns depth of the matrix elements
        -: 2978:    int depth() const;
        -: 2979:    //! returns the number of channels in each matrix element
        -: 2980:    int channels() const;
        -: 2981:
        -: 2982:    //! equivalent to SparseMat::ref<_Tp>(i0, hashval)
        -: 2983:    _Tp& ref(int i0, size_t* hashval=0);
        -: 2984:    //! equivalent to SparseMat::ref<_Tp>(i0, i1, hashval)
        -: 2985:    _Tp& ref(int i0, int i1, size_t* hashval=0);
        -: 2986:    //! equivalent to SparseMat::ref<_Tp>(i0, i1, i2, hashval)
        -: 2987:    _Tp& ref(int i0, int i1, int i2, size_t* hashval=0);
        -: 2988:    //! equivalent to SparseMat::ref<_Tp>(idx, hashval)
        -: 2989:    _Tp& ref(const int* idx, size_t* hashval=0);
        -: 2990:
        -: 2991:    //! equivalent to SparseMat::value<_Tp>(i0, hashval)
        -: 2992:    _Tp operator()(int i0, size_t* hashval=0) const;
        -: 2993:    //! equivalent to SparseMat::value<_Tp>(i0, i1, hashval)
        -: 2994:    _Tp operator()(int i0, int i1, size_t* hashval=0) const;
        -: 2995:    //! equivalent to SparseMat::value<_Tp>(i0, i1, i2, hashval)
        -: 2996:    _Tp operator()(int i0, int i1, int i2, size_t* hashval=0) const;
        -: 2997:    //! equivalent to SparseMat::value<_Tp>(idx, hashval)
        -: 2998:    _Tp operator()(const int* idx, size_t* hashval=0) const;
        -: 2999:
        -: 3000:    //! returns sparse matrix iterator pointing to the first sparse matrix element
        -: 3001:    SparseMatIterator_<_Tp> begin();
        -: 3002:    //! returns read-only sparse matrix iterator pointing to the first sparse matrix element
        -: 3003:    SparseMatConstIterator_<_Tp> begin() const;
        -: 3004:    //! returns sparse matrix iterator pointing to the element following the last sparse matrix element
        -: 3005:    SparseMatIterator_<_Tp> end();
        -: 3006:    //! returns read-only sparse matrix iterator pointing to the element following the last sparse matrix element
        -: 3007:    SparseMatConstIterator_<_Tp> end() const;
        -: 3008:};
        -: 3009:
        -: 3010:
        -: 3011:
        -: 3012:////////////////////////////////// MatConstIterator //////////////////////////////////
        -: 3013:
        -: 3014:class CV_EXPORTS MatConstIterator
        -: 3015:{
        -: 3016:public:
        -: 3017:    typedef uchar* value_type;
        -: 3018:    typedef ptrdiff_t difference_type;
        -: 3019:    typedef const uchar** pointer;
        -: 3020:    typedef uchar* reference;
        -: 3021:
        -: 3022:    typedef std::random_access_iterator_tag iterator_category;
        -: 3023:
        -: 3024:    //! default constructor
        -: 3025:    MatConstIterator();
        -: 3026:    //! constructor that sets the iterator to the beginning of the matrix
        -: 3027:    MatConstIterator(const Mat* _m);
        -: 3028:    //! constructor that sets the iterator to the specified element of the matrix
        -: 3029:    MatConstIterator(const Mat* _m, int _row, int _col=0);
        -: 3030:    //! constructor that sets the iterator to the specified element of the matrix
        -: 3031:    MatConstIterator(const Mat* _m, Point _pt);
        -: 3032:    //! constructor that sets the iterator to the specified element of the matrix
        -: 3033:    MatConstIterator(const Mat* _m, const int* _idx);
        -: 3034:    //! copy constructor
        -: 3035:    MatConstIterator(const MatConstIterator& it);
        -: 3036:
        -: 3037:    //! copy operator
        -: 3038:    MatConstIterator& operator = (const MatConstIterator& it);
        -: 3039:    //! returns the current matrix element
        -: 3040:    const uchar* operator *() const;
        -: 3041:    //! returns the i-th matrix element, relative to the current
        -: 3042:    const uchar* operator [](ptrdiff_t i) const;
        -: 3043:
        -: 3044:    //! shifts the iterator forward by the specified number of elements
        -: 3045:    MatConstIterator& operator += (ptrdiff_t ofs);
        -: 3046:    //! shifts the iterator backward by the specified number of elements
        -: 3047:    MatConstIterator& operator -= (ptrdiff_t ofs);
        -: 3048:    //! decrements the iterator
        -: 3049:    MatConstIterator& operator --();
        -: 3050:    //! decrements the iterator
        -: 3051:    MatConstIterator operator --(int);
        -: 3052:    //! increments the iterator
        -: 3053:    MatConstIterator& operator ++();
        -: 3054:    //! increments the iterator
        -: 3055:    MatConstIterator operator ++(int);
        -: 3056:    //! returns the current iterator position
        -: 3057:    Point pos() const;
        -: 3058:    //! returns the current iterator position
        -: 3059:    void pos(int* _idx) const;
        -: 3060:
        -: 3061:    ptrdiff_t lpos() const;
        -: 3062:    void seek(ptrdiff_t ofs, bool relative = false);
        -: 3063:    void seek(const int* _idx, bool relative = false);
        -: 3064:
        -: 3065:    const Mat* m;
        -: 3066:    size_t elemSize;
        -: 3067:    const uchar* ptr;
        -: 3068:    const uchar* sliceStart;
        -: 3069:    const uchar* sliceEnd;
        -: 3070:};
        -: 3071:
        -: 3072:
        -: 3073:
        -: 3074:////////////////////////////////// MatConstIterator_ /////////////////////////////////
        -: 3075:
        -: 3076:/** @brief Matrix read-only iterator
        -: 3077: */
        -: 3078:template<typename _Tp>
        -: 3079:class MatConstIterator_ : public MatConstIterator
        -: 3080:{
        -: 3081:public:
        -: 3082:    typedef _Tp value_type;
        -: 3083:    typedef ptrdiff_t difference_type;
        -: 3084:    typedef const _Tp* pointer;
        -: 3085:    typedef const _Tp& reference;
        -: 3086:
        -: 3087:    typedef std::random_access_iterator_tag iterator_category;
        -: 3088:
        -: 3089:    //! default constructor
        -: 3090:    MatConstIterator_();
        -: 3091:    //! constructor that sets the iterator to the beginning of the matrix
        -: 3092:    MatConstIterator_(const Mat_<_Tp>* _m);
        -: 3093:    //! constructor that sets the iterator to the specified element of the matrix
        -: 3094:    MatConstIterator_(const Mat_<_Tp>* _m, int _row, int _col=0);
        -: 3095:    //! constructor that sets the iterator to the specified element of the matrix
        -: 3096:    MatConstIterator_(const Mat_<_Tp>* _m, Point _pt);
        -: 3097:    //! constructor that sets the iterator to the specified element of the matrix
        -: 3098:    MatConstIterator_(const Mat_<_Tp>* _m, const int* _idx);
        -: 3099:    //! copy constructor
        -: 3100:    MatConstIterator_(const MatConstIterator_& it);
        -: 3101:
        -: 3102:    //! copy operator
        -: 3103:    MatConstIterator_& operator = (const MatConstIterator_& it);
        -: 3104:    //! returns the current matrix element
        -: 3105:    const _Tp& operator *() const;
        -: 3106:    //! returns the i-th matrix element, relative to the current
        -: 3107:    const _Tp& operator [](ptrdiff_t i) const;
        -: 3108:
        -: 3109:    //! shifts the iterator forward by the specified number of elements
        -: 3110:    MatConstIterator_& operator += (ptrdiff_t ofs);
        -: 3111:    //! shifts the iterator backward by the specified number of elements
        -: 3112:    MatConstIterator_& operator -= (ptrdiff_t ofs);
        -: 3113:    //! decrements the iterator
        -: 3114:    MatConstIterator_& operator --();
        -: 3115:    //! decrements the iterator
        -: 3116:    MatConstIterator_ operator --(int);
        -: 3117:    //! increments the iterator
        -: 3118:    MatConstIterator_& operator ++();
        -: 3119:    //! increments the iterator
        -: 3120:    MatConstIterator_ operator ++(int);
        -: 3121:    //! returns the current iterator position
        -: 3122:    Point pos() const;
        -: 3123:};
        -: 3124:
        -: 3125:
        -: 3126:
        -: 3127://////////////////////////////////// MatIterator_ ////////////////////////////////////
        -: 3128:
        -: 3129:/** @brief Matrix read-write iterator
        -: 3130:*/
        -: 3131:template<typename _Tp>
        -: 3132:class MatIterator_ : public MatConstIterator_<_Tp>
        -: 3133:{
        -: 3134:public:
        -: 3135:    typedef _Tp* pointer;
        -: 3136:    typedef _Tp& reference;
        -: 3137:
        -: 3138:    typedef std::random_access_iterator_tag iterator_category;
        -: 3139:
        -: 3140:    //! the default constructor
        -: 3141:    MatIterator_();
        -: 3142:    //! constructor that sets the iterator to the beginning of the matrix
        -: 3143:    MatIterator_(Mat_<_Tp>* _m);
        -: 3144:    //! constructor that sets the iterator to the specified element of the matrix
        -: 3145:    MatIterator_(Mat_<_Tp>* _m, int _row, int _col=0);
        -: 3146:    //! constructor that sets the iterator to the specified element of the matrix
        -: 3147:    MatIterator_(Mat_<_Tp>* _m, Point _pt);
        -: 3148:    //! constructor that sets the iterator to the specified element of the matrix
        -: 3149:    MatIterator_(Mat_<_Tp>* _m, const int* _idx);
        -: 3150:    //! copy constructor
        -: 3151:    MatIterator_(const MatIterator_& it);
        -: 3152:    //! copy operator
        -: 3153:    MatIterator_& operator = (const MatIterator_<_Tp>& it );
        -: 3154:
        -: 3155:    //! returns the current matrix element
        -: 3156:    _Tp& operator *() const;
        -: 3157:    //! returns the i-th matrix element, relative to the current
        -: 3158:    _Tp& operator [](ptrdiff_t i) const;
        -: 3159:
        -: 3160:    //! shifts the iterator forward by the specified number of elements
        -: 3161:    MatIterator_& operator += (ptrdiff_t ofs);
        -: 3162:    //! shifts the iterator backward by the specified number of elements
        -: 3163:    MatIterator_& operator -= (ptrdiff_t ofs);
        -: 3164:    //! decrements the iterator
        -: 3165:    MatIterator_& operator --();
        -: 3166:    //! decrements the iterator
        -: 3167:    MatIterator_ operator --(int);
        -: 3168:    //! increments the iterator
        -: 3169:    MatIterator_& operator ++();
        -: 3170:    //! increments the iterator
        -: 3171:    MatIterator_ operator ++(int);
        -: 3172:};
        -: 3173:
        -: 3174:
        -: 3175:
        -: 3176://///////////////////////////// SparseMatConstIterator ///////////////////////////////
        -: 3177:
        -: 3178:/**  @brief Read-Only Sparse Matrix Iterator.
        -: 3179:
        -: 3180: Here is how to use the iterator to compute the sum of floating-point sparse matrix elements:
        -: 3181:
        -: 3182: \code
        -: 3183: SparseMatConstIterator it = m.begin(), it_end = m.end();
        -: 3184: double s = 0;
        -: 3185: CV_Assert( m.type() == CV_32F );
        -: 3186: for( ; it != it_end; ++it )
        -: 3187:    s += it.value<float>();
        -: 3188: \endcode
        -: 3189:*/
        -: 3190:class CV_EXPORTS SparseMatConstIterator
        -: 3191:{
        -: 3192:public:
        -: 3193:    //! the default constructor
        -: 3194:    SparseMatConstIterator();
        -: 3195:    //! the full constructor setting the iterator to the first sparse matrix element
        -: 3196:    SparseMatConstIterator(const SparseMat* _m);
        -: 3197:    //! the copy constructor
        -: 3198:    SparseMatConstIterator(const SparseMatConstIterator& it);
        -: 3199:
        -: 3200:    //! the assignment operator
        -: 3201:    SparseMatConstIterator& operator = (const SparseMatConstIterator& it);
        -: 3202:
        -: 3203:    //! template method returning the current matrix element
        -: 3204:    template<typename _Tp> const _Tp& value() const;
        -: 3205:    //! returns the current node of the sparse matrix. it.node->idx is the current element index
        -: 3206:    const SparseMat::Node* node() const;
        -: 3207:
        -: 3208:    //! moves iterator to the previous element
        -: 3209:    SparseMatConstIterator& operator --();
        -: 3210:    //! moves iterator to the previous element
        -: 3211:    SparseMatConstIterator operator --(int);
        -: 3212:    //! moves iterator to the next element
        -: 3213:    SparseMatConstIterator& operator ++();
        -: 3214:    //! moves iterator to the next element
        -: 3215:    SparseMatConstIterator operator ++(int);
        -: 3216:
        -: 3217:    //! moves iterator to the element after the last element
        -: 3218:    void seekEnd();
        -: 3219:
        -: 3220:    const SparseMat* m;
        -: 3221:    size_t hashidx;
        -: 3222:    uchar* ptr;
        -: 3223:};
        -: 3224:
        -: 3225:
        -: 3226:
        -: 3227:////////////////////////////////// SparseMatIterator /////////////////////////////////
        -: 3228:
        -: 3229:/** @brief  Read-write Sparse Matrix Iterator
        -: 3230:
        -: 3231: The class is similar to cv::SparseMatConstIterator,
        -: 3232: but can be used for in-place modification of the matrix elements.
        -: 3233:*/
        -: 3234:class CV_EXPORTS SparseMatIterator : public SparseMatConstIterator
        -: 3235:{
        -: 3236:public:
        -: 3237:    //! the default constructor
        -: 3238:    SparseMatIterator();
        -: 3239:    //! the full constructor setting the iterator to the first sparse matrix element
        -: 3240:    SparseMatIterator(SparseMat* _m);
        -: 3241:    //! the full constructor setting the iterator to the specified sparse matrix element
        -: 3242:    SparseMatIterator(SparseMat* _m, const int* idx);
        -: 3243:    //! the copy constructor
        -: 3244:    SparseMatIterator(const SparseMatIterator& it);
        -: 3245:
        -: 3246:    //! the assignment operator
        -: 3247:    SparseMatIterator& operator = (const SparseMatIterator& it);
        -: 3248:    //! returns read-write reference to the current sparse matrix element
        -: 3249:    template<typename _Tp> _Tp& value() const;
        -: 3250:    //! returns pointer to the current sparse matrix node. it.node->idx is the index of the current element (do not modify it!)
        -: 3251:    SparseMat::Node* node() const;
        -: 3252:
        -: 3253:    //! moves iterator to the next element
        -: 3254:    SparseMatIterator& operator ++();
        -: 3255:    //! moves iterator to the next element
        -: 3256:    SparseMatIterator operator ++(int);
        -: 3257:};
        -: 3258:
        -: 3259:
        -: 3260:
        -: 3261://///////////////////////////// SparseMatConstIterator_ //////////////////////////////
        -: 3262:
        -: 3263:/** @brief  Template Read-Only Sparse Matrix Iterator Class.
        -: 3264:
        -: 3265: This is the derived from SparseMatConstIterator class that
        -: 3266: introduces more convenient operator *() for accessing the current element.
        -: 3267:*/
        -: 3268:template<typename _Tp> class SparseMatConstIterator_ : public SparseMatConstIterator
        -: 3269:{
        -: 3270:public:
        -: 3271:
        -: 3272:    typedef std::forward_iterator_tag iterator_category;
        -: 3273:
        -: 3274:    //! the default constructor
        -: 3275:    SparseMatConstIterator_();
        -: 3276:    //! the full constructor setting the iterator to the first sparse matrix element
        -: 3277:    SparseMatConstIterator_(const SparseMat_<_Tp>* _m);
        -: 3278:    SparseMatConstIterator_(const SparseMat* _m);
        -: 3279:    //! the copy constructor
        -: 3280:    SparseMatConstIterator_(const SparseMatConstIterator_& it);
        -: 3281:
        -: 3282:    //! the assignment operator
        -: 3283:    SparseMatConstIterator_& operator = (const SparseMatConstIterator_& it);
        -: 3284:    //! the element access operator
        -: 3285:    const _Tp& operator *() const;
        -: 3286:
        -: 3287:    //! moves iterator to the next element
        -: 3288:    SparseMatConstIterator_& operator ++();
        -: 3289:    //! moves iterator to the next element
        -: 3290:    SparseMatConstIterator_ operator ++(int);
        -: 3291:};
        -: 3292:
        -: 3293:
        -: 3294:
        -: 3295:///////////////////////////////// SparseMatIterator_ /////////////////////////////////
        -: 3296:
        -: 3297:/** @brief  Template Read-Write Sparse Matrix Iterator Class.
        -: 3298:
        -: 3299: This is the derived from cv::SparseMatConstIterator_ class that
        -: 3300: introduces more convenient operator *() for accessing the current element.
        -: 3301:*/
        -: 3302:template<typename _Tp> class SparseMatIterator_ : public SparseMatConstIterator_<_Tp>
        -: 3303:{
        -: 3304:public:
        -: 3305:
        -: 3306:    typedef std::forward_iterator_tag iterator_category;
        -: 3307:
        -: 3308:    //! the default constructor
        -: 3309:    SparseMatIterator_();
        -: 3310:    //! the full constructor setting the iterator to the first sparse matrix element
        -: 3311:    SparseMatIterator_(SparseMat_<_Tp>* _m);
        -: 3312:    SparseMatIterator_(SparseMat* _m);
        -: 3313:    //! the copy constructor
        -: 3314:    SparseMatIterator_(const SparseMatIterator_& it);
        -: 3315:
        -: 3316:    //! the assignment operator
        -: 3317:    SparseMatIterator_& operator = (const SparseMatIterator_& it);
        -: 3318:    //! returns the reference to the current element
        -: 3319:    _Tp& operator *() const;
        -: 3320:
        -: 3321:    //! moves the iterator to the next element
        -: 3322:    SparseMatIterator_& operator ++();
        -: 3323:    //! moves the iterator to the next element
        -: 3324:    SparseMatIterator_ operator ++(int);
        -: 3325:};
        -: 3326:
        -: 3327:
        -: 3328:
        -: 3329://///////////////////////////////// NAryMatIterator //////////////////////////////////
        -: 3330:
        -: 3331:/** @brief n-ary multi-dimensional array iterator.
        -: 3332:
        -: 3333:Use the class to implement unary, binary, and, generally, n-ary element-wise operations on
        -: 3334:multi-dimensional arrays. Some of the arguments of an n-ary function may be continuous arrays, some
        -: 3335:may be not. It is possible to use conventional MatIterator 's for each array but incrementing all of
        -: 3336:the iterators after each small operations may be a big overhead. In this case consider using
        -: 3337:NAryMatIterator to iterate through several matrices simultaneously as long as they have the same
        -: 3338:geometry (dimensionality and all the dimension sizes are the same). On each iteration `it.planes[0]`,
        -: 3339:`it.planes[1]`,... will be the slices of the corresponding matrices.
        -: 3340:
        -: 3341:The example below illustrates how you can compute a normalized and threshold 3D color histogram:
        -: 3342:@code
        -: 3343:    void computeNormalizedColorHist(const Mat& image, Mat& hist, int N, double minProb)
        -: 3344:    {
        -: 3345:        const int histSize[] = {N, N, N};
        -: 3346:
        -: 3347:        // make sure that the histogram has a proper size and type
        -: 3348:        hist.create(3, histSize, CV_32F);
        -: 3349:
        -: 3350:        // and clear it
        -: 3351:        hist = Scalar(0);
        -: 3352:
        -: 3353:        // the loop below assumes that the image
        -: 3354:        // is a 8-bit 3-channel. check it.
        -: 3355:        CV_Assert(image.type() == CV_8UC3);
        -: 3356:        MatConstIterator_<Vec3b> it = image.begin<Vec3b>(),
        -: 3357:                                 it_end = image.end<Vec3b>();
        -: 3358:        for( ; it != it_end; ++it )
        -: 3359:        {
        -: 3360:            const Vec3b& pix = *it;
        -: 3361:            hist.at<float>(pix[0]*N/256, pix[1]*N/256, pix[2]*N/256) += 1.f;
        -: 3362:        }
        -: 3363:
        -: 3364:        minProb *= image.rows*image.cols;
        -: 3365:
        -: 3366:        // initialize iterator (the style is different from STL).
        -: 3367:        // after initialization the iterator will contain
        -: 3368:        // the number of slices or planes the iterator will go through.
        -: 3369:        // it simultaneously increments iterators for several matrices
        -: 3370:        // supplied as a null terminated list of pointers
        -: 3371:        const Mat* arrays[] = {&hist, 0};
        -: 3372:        Mat planes[1];
        -: 3373:        NAryMatIterator itNAry(arrays, planes, 1);
        -: 3374:        double s = 0;
        -: 3375:        // iterate through the matrix. on each iteration
        -: 3376:        // itNAry.planes[i] (of type Mat) will be set to the current plane
        -: 3377:        // of the i-th n-dim matrix passed to the iterator constructor.
        -: 3378:        for(int p = 0; p < itNAry.nplanes; p++, ++itNAry)
        -: 3379:        {
        -: 3380:            threshold(itNAry.planes[0], itNAry.planes[0], minProb, 0, THRESH_TOZERO);
        -: 3381:            s += sum(itNAry.planes[0])[0];
        -: 3382:        }
        -: 3383:
        -: 3384:        s = 1./s;
        -: 3385:        itNAry = NAryMatIterator(arrays, planes, 1);
        -: 3386:        for(int p = 0; p < itNAry.nplanes; p++, ++itNAry)
        -: 3387:            itNAry.planes[0] *= s;
        -: 3388:    }
        -: 3389:@endcode
        -: 3390: */
        -: 3391:class CV_EXPORTS NAryMatIterator
        -: 3392:{
        -: 3393:public:
        -: 3394:    //! the default constructor
        -: 3395:    NAryMatIterator();
        -: 3396:    //! the full constructor taking arbitrary number of n-dim matrices
        -: 3397:    NAryMatIterator(const Mat** arrays, uchar** ptrs, int narrays=-1);
        -: 3398:    //! the full constructor taking arbitrary number of n-dim matrices
        -: 3399:    NAryMatIterator(const Mat** arrays, Mat* planes, int narrays=-1);
        -: 3400:    //! the separate iterator initialization method
        -: 3401:    void init(const Mat** arrays, Mat* planes, uchar** ptrs, int narrays=-1);
        -: 3402:
        -: 3403:    //! proceeds to the next plane of every iterated matrix
        -: 3404:    NAryMatIterator& operator ++();
        -: 3405:    //! proceeds to the next plane of every iterated matrix (postfix increment operator)
        -: 3406:    NAryMatIterator operator ++(int);
        -: 3407:
        -: 3408:    //! the iterated arrays
        -: 3409:    const Mat** arrays;
        -: 3410:    //! the current planes
        -: 3411:    Mat* planes;
        -: 3412:    //! data pointers
        -: 3413:    uchar** ptrs;
        -: 3414:    //! the number of arrays
        -: 3415:    int narrays;
        -: 3416:    //! the number of hyper-planes that the iterator steps through
        -: 3417:    size_t nplanes;
        -: 3418:    //! the size of each segment (in elements)
        -: 3419:    size_t size;
        -: 3420:protected:
        -: 3421:    int iterdepth;
        -: 3422:    size_t idx;
        -: 3423:};
        -: 3424:
        -: 3425:
        -: 3426:
        -: 3427:///////////////////////////////// Matrix Expressions /////////////////////////////////
        -: 3428:
        -: 3429:class CV_EXPORTS MatOp
        -: 3430:{
        -: 3431:public:
        -: 3432:    MatOp();
        -: 3433:    virtual ~MatOp();
        -: 3434:
        -: 3435:    virtual bool elementWise(const MatExpr& expr) const;
        -: 3436:    virtual void assign(const MatExpr& expr, Mat& m, int type=-1) const = 0;
        -: 3437:    virtual void roi(const MatExpr& expr, const Range& rowRange,
        -: 3438:                     const Range& colRange, MatExpr& res) const;
        -: 3439:    virtual void diag(const MatExpr& expr, int d, MatExpr& res) const;
        -: 3440:    virtual void augAssignAdd(const MatExpr& expr, Mat& m) const;
        -: 3441:    virtual void augAssignSubtract(const MatExpr& expr, Mat& m) const;
        -: 3442:    virtual void augAssignMultiply(const MatExpr& expr, Mat& m) const;
        -: 3443:    virtual void augAssignDivide(const MatExpr& expr, Mat& m) const;
        -: 3444:    virtual void augAssignAnd(const MatExpr& expr, Mat& m) const;
        -: 3445:    virtual void augAssignOr(const MatExpr& expr, Mat& m) const;
        -: 3446:    virtual void augAssignXor(const MatExpr& expr, Mat& m) const;
        -: 3447:
        -: 3448:    virtual void add(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res) const;
        -: 3449:    virtual void add(const MatExpr& expr1, const Scalar& s, MatExpr& res) const;
        -: 3450:
        -: 3451:    virtual void subtract(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res) const;
        -: 3452:    virtual void subtract(const Scalar& s, const MatExpr& expr, MatExpr& res) const;
        -: 3453:
        -: 3454:    virtual void multiply(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res, double scale=1) const;
        -: 3455:    virtual void multiply(const MatExpr& expr1, double s, MatExpr& res) const;
        -: 3456:
        -: 3457:    virtual void divide(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res, double scale=1) const;
        -: 3458:    virtual void divide(double s, const MatExpr& expr, MatExpr& res) const;
        -: 3459:
        -: 3460:    virtual void abs(const MatExpr& expr, MatExpr& res) const;
        -: 3461:
        -: 3462:    virtual void transpose(const MatExpr& expr, MatExpr& res) const;
        -: 3463:    virtual void matmul(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res) const;
        -: 3464:    virtual void invert(const MatExpr& expr, int method, MatExpr& res) const;
        -: 3465:
        -: 3466:    virtual Size size(const MatExpr& expr) const;
        -: 3467:    virtual int type(const MatExpr& expr) const;
        -: 3468:};
        -: 3469:
        -: 3470:/** @brief Matrix expression representation
        -: 3471:@anchor MatrixExpressions
        -: 3472:This is a list of implemented matrix operations that can be combined in arbitrary complex
        -: 3473:expressions (here A, B stand for matrices ( Mat ), s for a scalar ( Scalar ), alpha for a
        -: 3474:real-valued scalar ( double )):
        -: 3475:-   Addition, subtraction, negation: `A+B`, `A-B`, `A+s`, `A-s`, `s+A`, `s-A`, `-A`
        -: 3476:-   Scaling: `A*alpha`
        -: 3477:-   Per-element multiplication and division: `A.mul(B)`, `A/B`, `alpha/A`
        -: 3478:-   Matrix multiplication: `A*B`
        -: 3479:-   Transposition: `A.t()` (means A<sup>T</sup>)
        -: 3480:-   Matrix inversion and pseudo-inversion, solving linear systems and least-squares problems:
        -: 3481:    `A.inv([method]) (~ A<sup>-1</sup>)`,   `A.inv([method])*B (~ X: AX=B)`
        -: 3482:-   Comparison: `A cmpop B`, `A cmpop alpha`, `alpha cmpop A`, where *cmpop* is one of
        -: 3483:  `>`, `>=`, `==`, `!=`, `<=`, `<`. The result of comparison is an 8-bit single channel mask whose
        -: 3484:    elements are set to 255 (if the particular element or pair of elements satisfy the condition) or
        -: 3485:    0.
        -: 3486:-   Bitwise logical operations: `A logicop B`, `A logicop s`, `s logicop A`, `~A`, where *logicop* is one of
        -: 3487:  `&`, `|`, `^`.
        -: 3488:-   Element-wise minimum and maximum: `min(A, B)`, `min(A, alpha)`, `max(A, B)`, `max(A, alpha)`
        -: 3489:-   Element-wise absolute value: `abs(A)`
        -: 3490:-   Cross-product, dot-product: `A.cross(B)`, `A.dot(B)`
        -: 3491:-   Any function of matrix or matrices and scalars that returns a matrix or a scalar, such as norm,
        -: 3492:    mean, sum, countNonZero, trace, determinant, repeat, and others.
        -: 3493:-   Matrix initializers ( Mat::eye(), Mat::zeros(), Mat::ones() ), matrix comma-separated
        -: 3494:    initializers, matrix constructors and operators that extract sub-matrices (see Mat description).
        -: 3495:-   Mat_<destination_type>() constructors to cast the result to the proper type.
        -: 3496:@note Comma-separated initializers and probably some other operations may require additional
        -: 3497:explicit Mat() or Mat_<T>() constructor calls to resolve a possible ambiguity.
        -: 3498:
        -: 3499:Here are examples of matrix expressions:
        -: 3500:@code
        -: 3501:    // compute pseudo-inverse of A, equivalent to A.inv(DECOMP_SVD)
        -: 3502:    SVD svd(A);
        -: 3503:    Mat pinvA = svd.vt.t()*Mat::diag(1./svd.w)*svd.u.t();
        -: 3504:
        -: 3505:    // compute the new vector of parameters in the Levenberg-Marquardt algorithm
        -: 3506:    x -= (A.t()*A + lambda*Mat::eye(A.cols,A.cols,A.type())).inv(DECOMP_CHOLESKY)*(A.t()*err);
        -: 3507:
        -: 3508:    // sharpen image using "unsharp mask" algorithm
        -: 3509:    Mat blurred; double sigma = 1, threshold = 5, amount = 1;
        -: 3510:    GaussianBlur(img, blurred, Size(), sigma, sigma);
        -: 3511:    Mat lowContrastMask = abs(img - blurred) < threshold;
        -: 3512:    Mat sharpened = img*(1+amount) + blurred*(-amount);
        -: 3513:    img.copyTo(sharpened, lowContrastMask);
        -: 3514:@endcode
        -: 3515:*/
        2: 3516:class CV_EXPORTS MatExpr
        1: 3516-block  0
        1: 3516-block  1
        1: 3516-block  2
        1: 3516-block  3
        -: 3517:{
        -: 3518:public:
        -: 3519:    MatExpr();
        -: 3520:    explicit MatExpr(const Mat& m);
        -: 3521:
        -: 3522:    MatExpr(const MatOp* _op, int _flags, const Mat& _a = Mat(), const Mat& _b = Mat(),
        -: 3523:            const Mat& _c = Mat(), double _alpha = 1, double _beta = 1, const Scalar& _s = Scalar());
        -: 3524:
        -: 3525:    operator Mat() const;
        -: 3526:    template<typename _Tp> operator Mat_<_Tp>() const;
        -: 3527:
        -: 3528:    Size size() const;
        -: 3529:    int type() const;
        -: 3530:
        -: 3531:    MatExpr row(int y) const;
        -: 3532:    MatExpr col(int x) const;
        -: 3533:    MatExpr diag(int d = 0) const;
        -: 3534:    MatExpr operator()( const Range& rowRange, const Range& colRange ) const;
        -: 3535:    MatExpr operator()( const Rect& roi ) const;
        -: 3536:
        -: 3537:    MatExpr t() const;
        -: 3538:    MatExpr inv(int method = DECOMP_LU) const;
        -: 3539:    MatExpr mul(const MatExpr& e, double scale=1) const;
        -: 3540:    MatExpr mul(const Mat& m, double scale=1) const;
        -: 3541:
        -: 3542:    Mat cross(const Mat& m) const;
        -: 3543:    double dot(const Mat& m) const;
        -: 3544:
        -: 3545:    const MatOp* op;
        -: 3546:    int flags;
        -: 3547:
        -: 3548:    Mat a, b, c;
        -: 3549:    double alpha, beta;
        -: 3550:    Scalar s;
        -: 3551:};
        -: 3552:
        -: 3553://! @} core_basic
        -: 3554:
        -: 3555://! @relates cv::MatExpr
        -: 3556://! @{
        -: 3557:CV_EXPORTS MatExpr operator + (const Mat& a, const Mat& b);
        -: 3558:CV_EXPORTS MatExpr operator + (const Mat& a, const Scalar& s);
        -: 3559:CV_EXPORTS MatExpr operator + (const Scalar& s, const Mat& a);
        -: 3560:CV_EXPORTS MatExpr operator + (const MatExpr& e, const Mat& m);
        -: 3561:CV_EXPORTS MatExpr operator + (const Mat& m, const MatExpr& e);
        -: 3562:CV_EXPORTS MatExpr operator + (const MatExpr& e, const Scalar& s);
        -: 3563:CV_EXPORTS MatExpr operator + (const Scalar& s, const MatExpr& e);
        -: 3564:CV_EXPORTS MatExpr operator + (const MatExpr& e1, const MatExpr& e2);
        -: 3565:template<typename _Tp, int m, int n> static inline
        -: 3566:MatExpr operator + (const Mat& a, const Matx<_Tp, m, n>& b) { return a + Mat(b); }
        -: 3567:template<typename _Tp, int m, int n> static inline
        -: 3568:MatExpr operator + (const Matx<_Tp, m, n>& a, const Mat& b) { return Mat(a) + b; }
        -: 3569:
        -: 3570:CV_EXPORTS MatExpr operator - (const Mat& a, const Mat& b);
        -: 3571:CV_EXPORTS MatExpr operator - (const Mat& a, const Scalar& s);
        -: 3572:CV_EXPORTS MatExpr operator - (const Scalar& s, const Mat& a);
        -: 3573:CV_EXPORTS MatExpr operator - (const MatExpr& e, const Mat& m);
        -: 3574:CV_EXPORTS MatExpr operator - (const Mat& m, const MatExpr& e);
        -: 3575:CV_EXPORTS MatExpr operator - (const MatExpr& e, const Scalar& s);
        -: 3576:CV_EXPORTS MatExpr operator - (const Scalar& s, const MatExpr& e);
        -: 3577:CV_EXPORTS MatExpr operator - (const MatExpr& e1, const MatExpr& e2);
        -: 3578:template<typename _Tp, int m, int n> static inline
        -: 3579:MatExpr operator - (const Mat& a, const Matx<_Tp, m, n>& b) { return a - Mat(b); }
        -: 3580:template<typename _Tp, int m, int n> static inline
        -: 3581:MatExpr operator - (const Matx<_Tp, m, n>& a, const Mat& b) { return Mat(a) - b; }
        -: 3582:
        -: 3583:CV_EXPORTS MatExpr operator - (const Mat& m);
        -: 3584:CV_EXPORTS MatExpr operator - (const MatExpr& e);
        -: 3585:
        -: 3586:CV_EXPORTS MatExpr operator * (const Mat& a, const Mat& b);
        -: 3587:CV_EXPORTS MatExpr operator * (const Mat& a, double s);
        -: 3588:CV_EXPORTS MatExpr operator * (double s, const Mat& a);
        -: 3589:CV_EXPORTS MatExpr operator * (const MatExpr& e, const Mat& m);
        -: 3590:CV_EXPORTS MatExpr operator * (const Mat& m, const MatExpr& e);
        -: 3591:CV_EXPORTS MatExpr operator * (const MatExpr& e, double s);
        -: 3592:CV_EXPORTS MatExpr operator * (double s, const MatExpr& e);
        -: 3593:CV_EXPORTS MatExpr operator * (const MatExpr& e1, const MatExpr& e2);
        -: 3594:template<typename _Tp, int m, int n> static inline
        -: 3595:MatExpr operator * (const Mat& a, const Matx<_Tp, m, n>& b) { return a * Mat(b); }
        -: 3596:template<typename _Tp, int m, int n> static inline
        -: 3597:MatExpr operator * (const Matx<_Tp, m, n>& a, const Mat& b) { return Mat(a) * b; }
        -: 3598:
        -: 3599:CV_EXPORTS MatExpr operator / (const Mat& a, const Mat& b);
        -: 3600:CV_EXPORTS MatExpr operator / (const Mat& a, double s);
        -: 3601:CV_EXPORTS MatExpr operator / (double s, const Mat& a);
        -: 3602:CV_EXPORTS MatExpr operator / (const MatExpr& e, const Mat& m);
        -: 3603:CV_EXPORTS MatExpr operator / (const Mat& m, const MatExpr& e);
        -: 3604:CV_EXPORTS MatExpr operator / (const MatExpr& e, double s);
        -: 3605:CV_EXPORTS MatExpr operator / (double s, const MatExpr& e);
        -: 3606:CV_EXPORTS MatExpr operator / (const MatExpr& e1, const MatExpr& e2);
        -: 3607:template<typename _Tp, int m, int n> static inline
        -: 3608:MatExpr operator / (const Mat& a, const Matx<_Tp, m, n>& b) { return a / Mat(b); }
        -: 3609:template<typename _Tp, int m, int n> static inline
        -: 3610:MatExpr operator / (const Matx<_Tp, m, n>& a, const Mat& b) { return Mat(a) / b; }
        -: 3611:
        -: 3612:CV_EXPORTS MatExpr operator < (const Mat& a, const Mat& b);
        -: 3613:CV_EXPORTS MatExpr operator < (const Mat& a, double s);
        -: 3614:CV_EXPORTS MatExpr operator < (double s, const Mat& a);
        -: 3615:template<typename _Tp, int m, int n> static inline
        -: 3616:MatExpr operator < (const Mat& a, const Matx<_Tp, m, n>& b) { return a < Mat(b); }
        -: 3617:template<typename _Tp, int m, int n> static inline
        -: 3618:MatExpr operator < (const Matx<_Tp, m, n>& a, const Mat& b) { return Mat(a) < b; }
        -: 3619:
        -: 3620:CV_EXPORTS MatExpr operator <= (const Mat& a, const Mat& b);
        -: 3621:CV_EXPORTS MatExpr operator <= (const Mat& a, double s);
        -: 3622:CV_EXPORTS MatExpr operator <= (double s, const Mat& a);
        -: 3623:template<typename _Tp, int m, int n> static inline
        -: 3624:MatExpr operator <= (const Mat& a, const Matx<_Tp, m, n>& b) { return a <= Mat(b); }
        -: 3625:template<typename _Tp, int m, int n> static inline
        -: 3626:MatExpr operator <= (const Matx<_Tp, m, n>& a, const Mat& b) { return Mat(a) <= b; }
        -: 3627:
        -: 3628:CV_EXPORTS MatExpr operator == (const Mat& a, const Mat& b);
        -: 3629:CV_EXPORTS MatExpr operator == (const Mat& a, double s);
        -: 3630:CV_EXPORTS MatExpr operator == (double s, const Mat& a);
        -: 3631:template<typename _Tp, int m, int n> static inline
        -: 3632:MatExpr operator == (const Mat& a, const Matx<_Tp, m, n>& b) { return a == Mat(b); }
        -: 3633:template<typename _Tp, int m, int n> static inline
        -: 3634:MatExpr operator == (const Matx<_Tp, m, n>& a, const Mat& b) { return Mat(a) == b; }
        -: 3635:
        -: 3636:CV_EXPORTS MatExpr operator != (const Mat& a, const Mat& b);
        -: 3637:CV_EXPORTS MatExpr operator != (const Mat& a, double s);
        -: 3638:CV_EXPORTS MatExpr operator != (double s, const Mat& a);
        -: 3639:template<typename _Tp, int m, int n> static inline
        -: 3640:MatExpr operator != (const Mat& a, const Matx<_Tp, m, n>& b) { return a != Mat(b); }
        -: 3641:template<typename _Tp, int m, int n> static inline
        -: 3642:MatExpr operator != (const Matx<_Tp, m, n>& a, const Mat& b) { return Mat(a) != b; }
        -: 3643:
        -: 3644:CV_EXPORTS MatExpr operator >= (const Mat& a, const Mat& b);
        -: 3645:CV_EXPORTS MatExpr operator >= (const Mat& a, double s);
        -: 3646:CV_EXPORTS MatExpr operator >= (double s, const Mat& a);
        -: 3647:template<typename _Tp, int m, int n> static inline
        -: 3648:MatExpr operator >= (const Mat& a, const Matx<_Tp, m, n>& b) { return a >= Mat(b); }
        -: 3649:template<typename _Tp, int m, int n> static inline
        -: 3650:MatExpr operator >= (const Matx<_Tp, m, n>& a, const Mat& b) { return Mat(a) >= b; }
        -: 3651:
        -: 3652:CV_EXPORTS MatExpr operator > (const Mat& a, const Mat& b);
        -: 3653:CV_EXPORTS MatExpr operator > (const Mat& a, double s);
        -: 3654:CV_EXPORTS MatExpr operator > (double s, const Mat& a);
        -: 3655:template<typename _Tp, int m, int n> static inline
        -: 3656:MatExpr operator > (const Mat& a, const Matx<_Tp, m, n>& b) { return a > Mat(b); }
        -: 3657:template<typename _Tp, int m, int n> static inline
        -: 3658:MatExpr operator > (const Matx<_Tp, m, n>& a, const Mat& b) { return Mat(a) > b; }
        -: 3659:
        -: 3660:CV_EXPORTS MatExpr operator & (const Mat& a, const Mat& b);
        -: 3661:CV_EXPORTS MatExpr operator & (const Mat& a, const Scalar& s);
        -: 3662:CV_EXPORTS MatExpr operator & (const Scalar& s, const Mat& a);
        -: 3663:template<typename _Tp, int m, int n> static inline
        -: 3664:MatExpr operator & (const Mat& a, const Matx<_Tp, m, n>& b) { return a & Mat(b); }
        -: 3665:template<typename _Tp, int m, int n> static inline
        -: 3666:MatExpr operator & (const Matx<_Tp, m, n>& a, const Mat& b) { return Mat(a) & b; }
        -: 3667:
        -: 3668:CV_EXPORTS MatExpr operator | (const Mat& a, const Mat& b);
        -: 3669:CV_EXPORTS MatExpr operator | (const Mat& a, const Scalar& s);
        -: 3670:CV_EXPORTS MatExpr operator | (const Scalar& s, const Mat& a);
        -: 3671:template<typename _Tp, int m, int n> static inline
        -: 3672:MatExpr operator | (const Mat& a, const Matx<_Tp, m, n>& b) { return a | Mat(b); }
        -: 3673:template<typename _Tp, int m, int n> static inline
        -: 3674:MatExpr operator | (const Matx<_Tp, m, n>& a, const Mat& b) { return Mat(a) | b; }
        -: 3675:
        -: 3676:CV_EXPORTS MatExpr operator ^ (const Mat& a, const Mat& b);
        -: 3677:CV_EXPORTS MatExpr operator ^ (const Mat& a, const Scalar& s);
        -: 3678:CV_EXPORTS MatExpr operator ^ (const Scalar& s, const Mat& a);
        -: 3679:template<typename _Tp, int m, int n> static inline
        -: 3680:MatExpr operator ^ (const Mat& a, const Matx<_Tp, m, n>& b) { return a ^ Mat(b); }
        -: 3681:template<typename _Tp, int m, int n> static inline
        -: 3682:MatExpr operator ^ (const Matx<_Tp, m, n>& a, const Mat& b) { return Mat(a) ^ b; }
        -: 3683:
        -: 3684:CV_EXPORTS MatExpr operator ~(const Mat& m);
        -: 3685:
        -: 3686:CV_EXPORTS MatExpr min(const Mat& a, const Mat& b);
        -: 3687:CV_EXPORTS MatExpr min(const Mat& a, double s);
        -: 3688:CV_EXPORTS MatExpr min(double s, const Mat& a);
        -: 3689:template<typename _Tp, int m, int n> static inline
        -: 3690:MatExpr min (const Mat& a, const Matx<_Tp, m, n>& b) { return min(a, Mat(b)); }
        -: 3691:template<typename _Tp, int m, int n> static inline
        -: 3692:MatExpr min (const Matx<_Tp, m, n>& a, const Mat& b) { return min(Mat(a), b); }
        -: 3693:
        -: 3694:CV_EXPORTS MatExpr max(const Mat& a, const Mat& b);
        -: 3695:CV_EXPORTS MatExpr max(const Mat& a, double s);
        -: 3696:CV_EXPORTS MatExpr max(double s, const Mat& a);
        -: 3697:template<typename _Tp, int m, int n> static inline
        -: 3698:MatExpr max (const Mat& a, const Matx<_Tp, m, n>& b) { return max(a, Mat(b)); }
        -: 3699:template<typename _Tp, int m, int n> static inline
        -: 3700:MatExpr max (const Matx<_Tp, m, n>& a, const Mat& b) { return max(Mat(a), b); }
        -: 3701:
        -: 3702:/** @brief Calculates an absolute value of each matrix element.
        -: 3703:
        -: 3704:abs is a meta-function that is expanded to one of absdiff or convertScaleAbs forms:
        -: 3705:- C = abs(A-B) is equivalent to `absdiff(A, B, C)`
        -: 3706:- C = abs(A) is equivalent to `absdiff(A, Scalar::all(0), C)`
        -: 3707:- C = `Mat_<Vec<uchar,n> >(abs(A*alpha + beta))` is equivalent to `convertScaleAbs(A, C, alpha,
        -: 3708:beta)`
        -: 3709:
        -: 3710:The output matrix has the same size and the same type as the input one except for the last case,
        -: 3711:where C is depth=CV_8U .
        -: 3712:@param m matrix.
        -: 3713:@sa @ref MatrixExpressions, absdiff, convertScaleAbs
        -: 3714: */
        -: 3715:CV_EXPORTS MatExpr abs(const Mat& m);
        -: 3716:/** @overload
        -: 3717:@param e matrix expression.
        -: 3718:*/
        -: 3719:CV_EXPORTS MatExpr abs(const MatExpr& e);
        -: 3720://! @} relates cv::MatExpr
        -: 3721:
        -: 3722:} // cv
        -: 3723:
        -: 3724:#include "opencv2/core/mat.inl.hpp"
        -: 3725:
        -: 3726:#endif // OPENCV_CORE_MAT_HPP
