        -:    0:Source:/usr/include/opencv2/flann/any.h
        -:    0:Graph:/cygdrive/c/Users/10505/CLionProjects/C-projcet/cmake-build-debug/CMakeFiles/cppProject.dir/main.cpp.gcno
        -:    0:Data:/cygdrive/c/Users/10505/CLionProjects/C-projcet/cmake-build-debug/CMakeFiles/cppProject.dir/main.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#ifndef OPENCV_FLANN_ANY_H_
        -:    2:#define OPENCV_FLANN_ANY_H_
        -:    3:/*
        -:    4: * (C) Copyright Christopher Diggins 2005-2011
        -:    5: * (C) Copyright Pablo Aguilar 2005
        -:    6: * (C) Copyright Kevlin Henney 2001
        -:    7: *
        -:    8: * Distributed under the Boost Software License, Version 1.0. (See
        -:    9: * accompanying file LICENSE_1_0.txt or copy at
        -:   10: * http://www.boost.org/LICENSE_1_0.txt
        -:   11: *
        -:   12: * Adapted for FLANN by Marius Muja
        -:   13: */
        -:   14:
        -:   15:#include "defines.h"
        -:   16:#include <stdexcept>
        -:   17:#include <ostream>
        -:   18:#include <typeinfo>
        -:   19:
        -:   20:namespace cvflann
        -:   21:{
        -:   22:
        -:   23:namespace anyimpl
        -:   24:{
        -:   25:
        -:   26:struct bad_any_cast
        -:   27:{
        -:   28:};
        -:   29:
        -:   30:struct empty_any
        -:   31:{
        -:   32:};
        -:   33:
    #####:   34:inline std::ostream& operator <<(std::ostream& out, const empty_any&)
    $$$$$:   34-block  0
        -:   35:{
    #####:   36:    out << "[empty_any]";
    $$$$$:   36-block  0
    #####:   37:    return out;
        -:   38:}
        -:   39:
        -:   40:struct base_any_policy
        -:   41:{
        -:   42:    virtual void static_delete(void** x) = 0;
        -:   43:    virtual void copy_from_value(void const* src, void** dest) = 0;
        -:   44:    virtual void clone(void* const* src, void** dest) = 0;
        -:   45:    virtual void move(void* const* src, void** dest) = 0;
        -:   46:    virtual void* get_value(void** src) = 0;
        -:   47:    virtual const void* get_value(void* const * src) = 0;
        -:   48:    virtual ::size_t get_size() = 0;
        -:   49:    virtual const std::type_info& type() = 0;
        -:   50:    virtual void print(std::ostream& out, void* const* src) = 0;
    #####:   51:    virtual ~base_any_policy() {}
    $$$$$:   51-block  0
        -:   52:};
        -:   53:
        -:   54:template<typename T>
    #####:   55:struct typed_base_any_policy : base_any_policy
    $$$$$:   55-block  0
    $$$$$:   55-block  1
    $$$$$:   55-block  2
    $$$$$:   55-block  3
    $$$$$:   55-block  4
    $$$$$:   55-block  5
    $$$$$:   55-block  6
    $$$$$:   55-block  7
    $$$$$:   55-block  8
    $$$$$:   55-block  9
    $$$$$:   55-block 10
    $$$$$:   55-block 11
    $$$$$:   55-block 12
    $$$$$:   55-block 13
    $$$$$:   55-block 14
    $$$$$:   55-block 15
    $$$$$:   55-block 16
    $$$$$:   55-block 17
        -:   56:{
    #####:   57:    virtual ::size_t get_size() { return sizeof(T); }
    $$$$$:   57-block  0
    $$$$$:   57-block  1
    $$$$$:   57-block  2
    $$$$$:   57-block  3
    $$$$$:   57-block  4
    $$$$$:   57-block  5
    $$$$$:   57-block  6
    $$$$$:   57-block  7
    $$$$$:   57-block  8
    $$$$$:   57-block  9
    $$$$$:   57-block 10
    $$$$$:   57-block 11
    $$$$$:   57-block 12
    $$$$$:   57-block 13
    $$$$$:   57-block 14
    $$$$$:   57-block 15
    $$$$$:   57-block 16
    $$$$$:   57-block 17
    #####:   58:    virtual const std::type_info& type() { return typeid(T); }
    $$$$$:   58-block  0
    $$$$$:   58-block  1
    $$$$$:   58-block  2
    $$$$$:   58-block  3
    $$$$$:   58-block  4
    $$$$$:   58-block  5
    $$$$$:   58-block  6
    $$$$$:   58-block  7
    $$$$$:   58-block  8
    $$$$$:   58-block  9
    $$$$$:   58-block 10
    $$$$$:   58-block 11
    $$$$$:   58-block 12
    $$$$$:   58-block 13
    $$$$$:   58-block 14
    $$$$$:   58-block 15
    $$$$$:   58-block 16
    $$$$$:   58-block 17
        -:   59:
        -:   60:};
        -:   61:
        -:   62:template<typename T>
    #####:   63:struct small_any_policy : typed_base_any_policy<T>
    $$$$$:   63-block  0
    $$$$$:   63-block  1
    $$$$$:   63-block  2
    $$$$$:   63-block  3
    $$$$$:   63-block  4
    $$$$$:   63-block  5
    $$$$$:   63-block  6
    $$$$$:   63-block  7
    $$$$$:   63-block  8
    $$$$$:   63-block  9
    $$$$$:   63-block 10
    $$$$$:   63-block 11
    $$$$$:   63-block 12
    $$$$$:   63-block 13
    $$$$$:   63-block 14
    $$$$$:   63-block 15
    $$$$$:   63-block 16
    $$$$$:   63-block 17
    $$$$$:   63-block 18
    $$$$$:   63-block 19
        -:   64:{
    #####:   65:    virtual void static_delete(void**) { }
    $$$$$:   65-block  0
    $$$$$:   65-block  1
    $$$$$:   65-block  2
    $$$$$:   65-block  3
    $$$$$:   65-block  4
    #####:   66:    virtual void copy_from_value(void const* src, void** dest)
    $$$$$:   66-block  0
    $$$$$:   66-block  1
    $$$$$:   66-block  2
    $$$$$:   66-block  3
    $$$$$:   66-block  4
        -:   67:    {
    #####:   68:        new (dest) T(* reinterpret_cast<T const*>(src));
    $$$$$:   68-block  0
    $$$$$:   68-block  1
    $$$$$:   68-block  2
    $$$$$:   68-block  3
    $$$$$:   68-block  4
    $$$$$:   68-block  5
    $$$$$:   68-block  6
    $$$$$:   68-block  7
    $$$$$:   68-block  8
    $$$$$:   68-block  9
    $$$$$:   68-block 10
    $$$$$:   68-block 11
    $$$$$:   68-block 12
    $$$$$:   68-block 13
    $$$$$:   68-block 14
    #####:   69:    }
    #####:   70:    virtual void clone(void* const* src, void** dest) { *dest = *src; }
    $$$$$:   70-block  0
    $$$$$:   70-block  1
    $$$$$:   70-block  2
    $$$$$:   70-block  3
    $$$$$:   70-block  4
    #####:   71:    virtual void move(void* const* src, void** dest) { *dest = *src; }
    $$$$$:   71-block  0
    $$$$$:   71-block  1
    $$$$$:   71-block  2
    $$$$$:   71-block  3
    $$$$$:   71-block  4
    #####:   72:    virtual void* get_value(void** src) { return reinterpret_cast<void*>(src); }
    $$$$$:   72-block  0
    $$$$$:   72-block  1
    $$$$$:   72-block  2
    $$$$$:   72-block  3
    $$$$$:   72-block  4
    $$$$$:   72-block  5
    $$$$$:   72-block  6
    $$$$$:   72-block  7
    $$$$$:   72-block  8
    $$$$$:   72-block  9
    #####:   73:    virtual const void* get_value(void* const * src) { return reinterpret_cast<const void*>(src); }
    $$$$$:   73-block  0
    $$$$$:   73-block  1
    $$$$$:   73-block  2
    $$$$$:   73-block  3
    $$$$$:   73-block  4
    $$$$$:   73-block  5
    $$$$$:   73-block  6
    $$$$$:   73-block  7
    $$$$$:   73-block  8
    $$$$$:   73-block  9
    #####:   74:    virtual void print(std::ostream& out, void* const* src) { out << *reinterpret_cast<T const*>(src); }
    $$$$$:   74-block  0
    $$$$$:   74-block  1
    $$$$$:   74-block  2
    $$$$$:   74-block  3
    $$$$$:   74-block  4
    $$$$$:   74-block  5
    $$$$$:   74-block  6
    $$$$$:   74-block  7
    $$$$$:   74-block  8
    $$$$$:   74-block  9
        -:   75:};
        -:   76:
        -:   77:template<typename T>
    #####:   78:struct big_any_policy : typed_base_any_policy<T>
    $$$$$:   78-block  0
    $$$$$:   78-block  1
    $$$$$:   78-block  2
    $$$$$:   78-block  3
    $$$$$:   78-block  4
    $$$$$:   78-block  5
    $$$$$:   78-block  6
    $$$$$:   78-block  7
    $$$$$:   78-block  8
    $$$$$:   78-block  9
    $$$$$:   78-block 10
    $$$$$:   78-block 11
    $$$$$:   78-block 12
    $$$$$:   78-block 13
    $$$$$:   78-block 14
    $$$$$:   78-block 15
        -:   79:{
    #####:   80:    virtual void static_delete(void** x)
    $$$$$:   80-block  0
    $$$$$:   80-block  1
    $$$$$:   80-block  2
    $$$$$:   80-block  3
        -:   81:    {
    #####:   82:        if (* x) delete (* reinterpret_cast<T**>(x));
    $$$$$:   82-block  0
    $$$$$:   82-block  1
    $$$$$:   82-block  2
    $$$$$:   82-block  3
    $$$$$:   82-block  4
    $$$$$:   82-block  5
    $$$$$:   82-block  6
    $$$$$:   82-block  7
    $$$$$:   82-block  8
    #####:   83:        *x = NULL;
    #####:   84:    }
    #####:   85:    virtual void copy_from_value(void const* src, void** dest)
    $$$$$:   85-block  0
    $$$$$:   85-block  1
    $$$$$:   85-block  2
    $$$$$:   85-block  3
        -:   86:    {
    #####:   87:        *dest = new T(*reinterpret_cast<T const*>(src));
    $$$$$:   87-block  0
    $$$$$:   87-block  1
    $$$$$:   87-block  2
    $$$$$:   87-block  3
    #####:   88:    }
    #####:   89:    virtual void clone(void* const* src, void** dest)
    $$$$$:   89-block  0
    $$$$$:   89-block  1
    $$$$$:   89-block  2
    $$$$$:   89-block  3
        -:   90:    {
    #####:   91:        *dest = new T(**reinterpret_cast<T* const*>(src));
    $$$$$:   91-block  0
    $$$$$:   91-block  1
    $$$$$:   91-block  2
    $$$$$:   91-block  3
    #####:   92:    }
    #####:   93:    virtual void move(void* const* src, void** dest)
    $$$$$:   93-block  0
    $$$$$:   93-block  1
    $$$$$:   93-block  2
    $$$$$:   93-block  3
        -:   94:    {
    #####:   95:        (*reinterpret_cast<T**>(dest))->~T();
    $$$$$:   95-block  0
    #####:   96:        **reinterpret_cast<T**>(dest) = **reinterpret_cast<T* const*>(src);
    #####:   97:    }
    #####:   98:    virtual void* get_value(void** src) { return *src; }
    $$$$$:   98-block  0
    $$$$$:   98-block  1
    $$$$$:   98-block  2
    $$$$$:   98-block  3
    $$$$$:   98-block  4
    $$$$$:   98-block  5
    $$$$$:   98-block  6
    $$$$$:   98-block  7
    #####:   99:    virtual const void* get_value(void* const * src) { return *src; }
    $$$$$:   99-block  0
    $$$$$:   99-block  1
    $$$$$:   99-block  2
    $$$$$:   99-block  3
    $$$$$:   99-block  4
    $$$$$:   99-block  5
    $$$$$:   99-block  6
    $$$$$:   99-block  7
    #####:  100:    virtual void print(std::ostream& out, void* const* src) { out << *reinterpret_cast<T const*>(*src); }
    $$$$$:  100-block  0
    $$$$$:  100-block  1
        -:  101:};
        -:  102:
    #####:  103:template<> inline void big_any_policy<flann_centers_init_t>::print(std::ostream& out, void* const* src)
    $$$$$:  103-block  0
        -:  104:{
    #####:  105:    out << int(*reinterpret_cast<flann_centers_init_t const*>(*src));
    $$$$$:  105-block  0
    #####:  106:}
        -:  107:
    #####:  108:template<> inline void big_any_policy<flann_algorithm_t>::print(std::ostream& out, void* const* src)
    $$$$$:  108-block  0
        -:  109:{
    #####:  110:    out << int(*reinterpret_cast<flann_algorithm_t const*>(*src));
    $$$$$:  110-block  0
    #####:  111:}
        -:  112:
    #####:  113:template<> inline void big_any_policy<cv::String>::print(std::ostream& out, void* const* src)
    $$$$$:  113-block  0
        -:  114:{
    #####:  115:    out << (*reinterpret_cast<cv::String const*>(*src)).c_str();
    $$$$$:  115-block  0
    #####:  116:}
        -:  117:
        -:  118:template<typename T>
        -:  119:struct choose_policy
        -:  120:{
        -:  121:    typedef big_any_policy<T> type;
        -:  122:};
        -:  123:
        -:  124:template<typename T>
        -:  125:struct choose_policy<T*>
        -:  126:{
        -:  127:    typedef small_any_policy<T*> type;
        -:  128:};
        -:  129:
        -:  130:struct any;
        -:  131:
        -:  132:/// Choosing the policy for an any type is illegal, but should never happen.
        -:  133:/// This is designed to throw a compiler error.
        -:  134:template<>
        -:  135:struct choose_policy<any>
        -:  136:{
        -:  137:    typedef void type;
        -:  138:};
        -:  139:
        -:  140:/// Specializations for small types.
        -:  141:#define SMALL_POLICY(TYPE) \
        -:  142:    template<> \
        -:  143:    struct choose_policy<TYPE> { typedef small_any_policy<TYPE> type; \
        -:  144:    }
        -:  145:
        -:  146:SMALL_POLICY(signed char);
        -:  147:SMALL_POLICY(unsigned char);
        -:  148:SMALL_POLICY(signed short);
        -:  149:SMALL_POLICY(unsigned short);
        -:  150:SMALL_POLICY(signed int);
        -:  151:SMALL_POLICY(unsigned int);
        -:  152:SMALL_POLICY(signed long);
        -:  153:SMALL_POLICY(unsigned long);
        -:  154:SMALL_POLICY(float);
        -:  155:SMALL_POLICY(bool);
        -:  156:
        -:  157:#undef SMALL_POLICY
        -:  158:
        -:  159:template <typename T>
        -:  160:class SinglePolicy
        -:  161:{
        -:  162:    SinglePolicy();
        -:  163:    SinglePolicy(const SinglePolicy& other);
        -:  164:    SinglePolicy& operator=(const SinglePolicy& other);
        -:  165:
        -:  166:public:
        -:  167:    static base_any_policy* get_policy();
        -:  168:
        -:  169:private:
        -:  170:    static typename choose_policy<T>::type policy;
        -:  171:};
        -:  172:
        -:  173:template <typename T>
        1:  174:typename choose_policy<T>::type SinglePolicy<T>::policy;
        1:  174-block  0
        1:  174-block  1
        1:  174-block  2
        1:  174-block  3
        1:  174-block  4
        1:  174-block  5
        1:  174-block  6
        1:  174-block  7
        1:  174-block  8
        1:  174-block  9
        1:  174-block 10
        1:  174-block 11
        1:  174-block 12
        1:  174-block 13
        1:  174-block 14
        1:  174-block 15
        1:  174-block 16
        -:  175:
        -:  176:/// This function will return a different policy for each type.
        -:  177:template <typename T>
        -:  178:inline base_any_policy* SinglePolicy<T>::get_policy() { return &policy; }
        -:  179:
        -:  180:} // namespace anyimpl
        -:  181:
        -:  182:struct any
        -:  183:{
        -:  184:private:
        -:  185:    // fields
        -:  186:    anyimpl::base_any_policy* policy;
        -:  187:    void* object;
        -:  188:
        -:  189:public:
        -:  190:    /// Initializing constructor.
        -:  191:    template <typename T>
        -:  192:    any(const T& x)
        -:  193:        : policy(anyimpl::SinglePolicy<anyimpl::empty_any>::get_policy()), object(NULL)
        -:  194:    {
        -:  195:        assign(x);
        -:  196:    }
        -:  197:
        -:  198:    /// Empty constructor.
        -:  199:    any()
        -:  200:        : policy(anyimpl::SinglePolicy<anyimpl::empty_any>::get_policy()), object(NULL)
        -:  201:    { }
        -:  202:
        -:  203:    /// Special initializing constructor for string literals.
        -:  204:    any(const char* x)
        -:  205:        : policy(anyimpl::SinglePolicy<anyimpl::empty_any>::get_policy()), object(NULL)
        -:  206:    {
        -:  207:        assign(x);
        -:  208:    }
        -:  209:
        -:  210:    /// Copy constructor.
        -:  211:    any(const any& x)
        -:  212:        : policy(anyimpl::SinglePolicy<anyimpl::empty_any>::get_policy()), object(NULL)
        -:  213:    {
        -:  214:        assign(x);
        -:  215:    }
        -:  216:
        -:  217:    /// Destructor.
        -:  218:    ~any()
        -:  219:    {
        -:  220:        policy->static_delete(&object);
        -:  221:    }
        -:  222:
        -:  223:    /// Assignment function from another any.
        -:  224:    any& assign(const any& x)
        -:  225:    {
        -:  226:        reset();
        -:  227:        policy = x.policy;
        -:  228:        policy->clone(&x.object, &object);
        -:  229:        return *this;
        -:  230:    }
        -:  231:
        -:  232:    /// Assignment function.
        -:  233:    template <typename T>
        -:  234:    any& assign(const T& x)
        -:  235:    {
        -:  236:        reset();
        -:  237:        policy = anyimpl::SinglePolicy<T>::get_policy();
        -:  238:        policy->copy_from_value(&x, &object);
        -:  239:        return *this;
        -:  240:    }
        -:  241:
        -:  242:    /// Assignment operator.
        -:  243:    template<typename T>
        -:  244:    any& operator=(const T& x)
        -:  245:    {
        -:  246:        return assign(x);
        -:  247:    }
        -:  248:
        -:  249:    /// Assignment operator. Template-based version above doesn't work as expected. We need regular assignment operator here.
        -:  250:    any& operator=(const any& x)
        -:  251:    {
        -:  252:        return assign(x);
        -:  253:    }
        -:  254:
        -:  255:    /// Assignment operator, specialed for literal strings.
        -:  256:    /// They have types like const char [6] which don't work as expected.
        -:  257:    any& operator=(const char* x)
        -:  258:    {
        -:  259:        return assign(x);
        -:  260:    }
        -:  261:
        -:  262:    /// Utility functions
        -:  263:    any& swap(any& x)
        -:  264:    {
        -:  265:        std::swap(policy, x.policy);
        -:  266:        std::swap(object, x.object);
        -:  267:        return *this;
        -:  268:    }
        -:  269:
        -:  270:    /// Cast operator. You can only cast to the original type.
        -:  271:    template<typename T>
        -:  272:    T& cast()
        -:  273:    {
        -:  274:        if (policy->type() != typeid(T)) throw anyimpl::bad_any_cast();
        -:  275:        T* r = reinterpret_cast<T*>(policy->get_value(&object));
        -:  276:        return *r;
        -:  277:    }
        -:  278:
        -:  279:    /// Cast operator. You can only cast to the original type.
        -:  280:    template<typename T>
        -:  281:    const T& cast() const
        -:  282:    {
        -:  283:        if (policy->type() != typeid(T)) throw anyimpl::bad_any_cast();
        -:  284:        const T* r = reinterpret_cast<const T*>(policy->get_value(&object));
        -:  285:        return *r;
        -:  286:    }
        -:  287:
        -:  288:    /// Returns true if the any contains no value.
        -:  289:    bool empty() const
        -:  290:    {
        -:  291:        return policy->type() == typeid(anyimpl::empty_any);
        -:  292:    }
        -:  293:
        -:  294:    /// Frees any allocated memory, and sets the value to NULL.
        -:  295:    void reset()
        -:  296:    {
        -:  297:        policy->static_delete(&object);
        -:  298:        policy = anyimpl::SinglePolicy<anyimpl::empty_any>::get_policy();
        -:  299:    }
        -:  300:
        -:  301:    /// Returns true if the two types are the same.
        -:  302:    bool compatible(const any& x) const
        -:  303:    {
        -:  304:        return policy->type() == x.policy->type();
        -:  305:    }
        -:  306:
        -:  307:    /// Returns if the type is compatible with the policy
        -:  308:    template<typename T>
        -:  309:    bool has_type()
        -:  310:    {
        -:  311:        return policy->type() == typeid(T);
        -:  312:    }
        -:  313:
        -:  314:    const std::type_info& type() const
        -:  315:    {
        -:  316:        return policy->type();
        -:  317:    }
        -:  318:
        -:  319:    friend std::ostream& operator <<(std::ostream& out, const any& any_val);
        -:  320:};
        -:  321:
        -:  322:inline std::ostream& operator <<(std::ostream& out, const any& any_val)
        -:  323:{
        -:  324:    any_val.policy->print(out,&any_val.object);
        -:  325:    return out;
        -:  326:}
        -:  327:
        -:  328:}
        -:  329:
        -:  330:#endif // OPENCV_FLANN_ANY_H_
