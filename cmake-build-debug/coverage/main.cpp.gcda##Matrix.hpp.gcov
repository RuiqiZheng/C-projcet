        -:    0:Source:/Users/bytedance/CLionProjects/C-projcet/code/Matrix.hpp
        -:    0:Graph:/Users/bytedance/CLionProjects/C-projcet/cmake-build-debug/CMakeFiles/cppProject.dir/code/main.cpp.gcno
        -:    0:Data:/Users/bytedance/CLionProjects/C-projcet/cmake-build-debug/CMakeFiles/cppProject.dir/code/main.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#ifndef CPPPROJECT_MATRIX_HPP
        -:    2:#define CPPPROJECT_MATRIX_HPP
        -:    3:
        -:    4:#include "Vector.hpp"
        -:    5:#include <opencv2/core.hpp>
        -:    6:
        -:    7:using namespace std;
        -:    8:using namespace cv;
        -:    9:
        -:   10:template<class T>
       14:   11:class Vector;
        1:   11-block  0
        1:   11-block  1
        5:   11-block  2
        5:   11-block  3
        1:   11-block  4
        1:   11-block  5
        5:   11-block  6
        5:   11-block  7
        1:   11-block  8
        1:   11-block  9
        1:   11-block 10
        1:   11-block 11
        -:   12:
        -:   13:/**
        -:   14: * the class of Matrix
        -:   15: * @authors Zhu Junda Zheng Ruiqi Wang Yifan
        -:   16: * @version 1.0
        -:   17: * @tparam T the data type
        -:   18: */
        -:   19:template<class T>
       51:   20:class Matrix {
       20:   20-block  0
       20:   20-block  1
        1:   20-block  2
        1:   20-block  3
        5:   20-block  4
        5:   20-block  5
       20:   20-block  6
       20:   20-block  7
        5:   20-block  8
        5:   20-block  9
        -:   21:public:
        -:   22:    /**
        -:   23:     * initial a Matrix with row=0,and column=0
        -:   24:     */
        2:   25:    Matrix() {
        1:   25-block  0
        1:   25-block  1
        1:   26:        this->row = 0;
        1:   27:        this->column = 0;
        1:   28:        this->matrix.resize(0);
        1:   28-block  0
        2:   29:    }
        1:   29-block  0
        1:   29-block  1
    $$$$$:   29-block  2
    $$$$$:   29-block  3
        -:   30:
        -:   31:/**
        -:   32: * overload [] to access matrix data
        -:   33: * @param i  the row of the matrix
        -:   34: * @return  the row of the matrix
        -:   35: */
      300:   36:    vector<T> &operator[](int i) {
      264:   36-block  0
       36:   36-block  1
      300:   37:        if (i >= row) {
      264:   37-block  0
       36:   37-block  1
    #####:   38:            cerr << "the input row is lager than row";
    #####:   39:        }
    $$$$$:   39-block  0
    $$$$$:   39-block  1
      300:   40:        return this->matrix[i];
      264:   40-block  0
       36:   40-block  1
        -:   41:    }
        -:   42:
        -:   43:/**
        -:   44: * initial a matrix with certain row and column
        -:   45: * @param row the row of the matrix
        -:   46: * @param column the column of the matrix
        -:   47: */
       12:   48:    Matrix(int row, int column) {
        3:   48-block  0
        3:   48-block  1
        3:   48-block  2
        3:   48-block  3
        6:   49:        this->row = row;
        6:   50:        this->column = column;
        6:   51:        this->matrix.resize(row);
        3:   51-block  0
        3:   51-block  1
       23:   52:        for (int i = 0; i < row; ++i) {
        3:   52-block  0
       12:   52-block  1
        9:   52-block  2
        3:   52-block  3
       11:   52-block  4
        8:   52-block  5
       17:   53:            this->matrix[i].resize(column);
        9:   53-block  0
        8:   53-block  1
       17:   54:        }
        9:   54-block  0
        8:   54-block  1
       12:   55:    }
        3:   55-block  0
    $$$$$:   55-block  1
        3:   55-block  2
    $$$$$:   55-block  3
        3:   55-block  4
    $$$$$:   55-block  5
        3:   55-block  6
    $$$$$:   55-block  7
        -:   56:
        -:   57:/**
        -:   58: * initial a matrix with row equals 1 and column equals length
        -:   59: * like a vector
        -:   60: * @param length the length of the matrix
        -:   61: */
        2:   62:    Matrix(int length) {
        1:   62-block  0
        1:   62-block  1
        1:   63:        this->row = 1;
        1:   64:        this->column = length;
        1:   65:        this->matrix.resize(this->row);
        1:   65-block  0
        1:   66:        this->matrix[0].resize(this->column);
        1:   66-block  0
        2:   67:    }
        1:   67-block  0
        1:   67-block  1
    $$$$$:   67-block  2
    $$$$$:   67-block  3
        -:   68:
        -:   69:/**
        -:   70: * initial a matrix with other matrix
        -:   71: * @param other the other matrix
        -:   72: */
        6:   73:    Matrix(Matrix const &other) {
        2:   73-block  0
        2:   73-block  1
        1:   73-block  2
        1:   73-block  3
        3:   74:        this->row = other.row;
        3:   75:        this->column = other.column;
        3:   76:        this->matrix = other.matrix;
        2:   76-block  0
        1:   76-block  1
        6:   77:    }
        2:   77-block  0
        2:   77-block  1
    $$$$$:   77-block  2
    $$$$$:   77-block  3
        1:   77-block  4
        1:   77-block  5
    $$$$$:   77-block  6
    $$$$$:   77-block  7
        -:   78:
        -:   79:/**
        -:   80: * initial a matrix with a vector
        -:   81: * the matrix has row equals 1 and column equals vector's length
        -:   82: * @param other the vector
        -:   83: */
        -:   84:    Matrix(Vector<T> other) {
        -:   85:        Matrix ans = Matrix(1, other.getLength());
        -:   86:        for (int i = 0; i < other.getLength(); ++i) {
        -:   87:            ans[0][i] = other[i];
        -:   88:        }
        -:   89:        this->row = ans.row;
        -:   90:        this->column = ans.column;
        -:   91:        this->matrix = ans.matrix;
        -:   92:    }
        -:   93:
        -:   94:/**
        -:   95: * a function to get the minimium element of the matrix
        -:   96: * @return  the minimium element of the matrix
        -:   97: */
        2:   98:    T findMin() {
        2:   98-block  0
        2:   99:        if (this->row == 0 || this->column == 0) {
        2:   99-block  0
        2:   99-block  1
    #####:  100:            cerr << "The vector is empty,can not get sum" << endl;
    #####:  101:            return 0;
    $$$$$:  101-block  0
        -:  102:        }
        2:  103:        double ans = this->matrix[0][0];
        8:  104:        for (int i = 0; i < this->row; ++i) {
        2:  104-block  0
        8:  104-block  1
        6:  104-block  2
       24:  105:            for (int j = 0; j < this->column; ++j) {
        6:  105-block  0
       24:  105-block  1
       18:  105-block  2
       18:  106:                ans = min(ans, this->matrix[i][j]);
       18:  107:            }
       18:  107-block  0
        6:  108:        }
        6:  108-block  0
        2:  109:        return ans;
        2:  109-block  0
        2:  110:    }
        2:  110-block  0
        -:  111:
        -:  112:/**
        -:  113: *
        -:  114: * @param row
        -:  115: * @return
        -:  116: */
        3:  117:    T findMinAtRow(int row) {
        3:  117-block  0
        3:  118:        if (this->row == 0 || this->column == 0) {
        3:  118-block  0
        3:  118-block  1
    #####:  119:            cerr << "The vector is empty,can not get sum" << endl;
    #####:  120:            return 0;
    $$$$$:  120-block  0
        -:  121:        }
        3:  122:        double ans = this->matrix[row][0];
       12:  123:        for (int i = 0; i < this->column; ++i) {
        3:  123-block  0
       12:  123-block  1
        9:  123-block  2
        9:  124:            ans = min(ans, this->matrix[row][i]);
        9:  125:        }
        9:  125-block  0
        3:  126:        return ans;
        3:  126-block  0
        3:  127:    }
        3:  127-block  0
        -:  128:
        3:  129:    T findMinAtColumn(int column) {
        3:  129-block  0
        3:  130:        if (this->row == 0 || this->column == 0) {
        3:  130-block  0
        3:  130-block  1
    #####:  131:            cerr << "The vector is empty,can not get sum" << endl;
    #####:  132:            return 0;
    $$$$$:  132-block  0
        -:  133:        }
        3:  134:        double ans = this->matrix[0][column];
       12:  135:        for (int i = 0; i < row; ++i) {
        3:  135-block  0
       12:  135-block  1
        9:  135-block  2
        9:  136:            ans = min(ans, this->matrix[i][column]);
        9:  137:        }
        9:  137-block  0
        3:  138:        return ans;
        3:  138-block  0
        3:  139:    }
        3:  139-block  0
        -:  140:
        2:  141:    T findMax() {
        2:  141-block  0
        2:  142:        if (this->row == 0 || this->column == 0) {
        2:  142-block  0
        2:  142-block  1
    #####:  143:            cerr << "The vector is empty,can not get sum" << endl;
    #####:  144:            return 0;
    $$$$$:  144-block  0
        -:  145:        }
        2:  146:        double ans = this->matrix[0][0];
        8:  147:        for (int i = 0; i < row; ++i) {
        2:  147-block  0
        8:  147-block  1
        6:  147-block  2
       24:  148:            for (int j = 0; j < this->column; ++j) {
        6:  148-block  0
       24:  148-block  1
       18:  148-block  2
       18:  149:                ans = max(ans, this->matrix[i][j]);
       18:  150:            }
       18:  150-block  0
        6:  151:        }
        6:  151-block  0
        2:  152:        return ans;
        2:  152-block  0
        2:  153:    }
        2:  153-block  0
        -:  154:
        6:  155:    T findMaxAtRow(int row) {
        6:  155-block  0
        6:  156:        if (this->row == 0 || this->column == 0) {
        6:  156-block  0
        6:  156-block  1
    #####:  157:            cerr << "The vector is empty,can not get sum" << endl;
    #####:  158:            return 0;
    $$$$$:  158-block  0
        -:  159:        }
        6:  160:        double ans = this->matrix[row][0];
       24:  161:        for (int i = 0; i < this->column; ++i) {
        6:  161-block  0
       24:  161-block  1
       18:  161-block  2
       18:  162:            ans = max(ans, this->matrix[row][i]);
       18:  163:        }
       18:  163-block  0
        6:  164:        return ans;
        6:  164-block  0
        6:  165:    }
        6:  165-block  0
        -:  166:
        6:  167:    T findMaxAtColumn(int column) {
        6:  167-block  0
        6:  168:        if (this->row == 0 || this->column == 0) {
        6:  168-block  0
        6:  168-block  1
    #####:  169:            cerr << "The vector is empty,can not get sum" << endl;
    #####:  170:            return 0;
    $$$$$:  170-block  0
        -:  171:        }
        6:  172:        double ans = this->matrix[0][column];
       24:  173:        for (int i = 0; i < row; ++i) {
        6:  173-block  0
       24:  173-block  1
       18:  173-block  2
       18:  174:            ans = max(ans, this->matrix[i][column]);
       18:  175:        }
       18:  175-block  0
        6:  176:        return ans;
        6:  176-block  0
        6:  177:    }
        6:  177-block  0
        -:  178:
        1:  179:    T findAverage() {
        1:  179-block  0
        1:  180:        T ans = findSum();
        1:  181:        ans /= (row * this->column);
        1:  182:        return ans;
        1:  182-block  0
        -:  183:    }
        -:  184:
        3:  185:    T findAverageAtRow(int row) {
        3:  185-block  0
        3:  186:        T ans = findSumAtRow(row);
        3:  187:        ans /= this->column;
        3:  188:        return ans;
        3:  188-block  0
        -:  189:    }
        -:  190:
        3:  191:    T findAverageAtColumn(int column) {
        3:  191-block  0
        3:  192:        T ans = findSumAtColumn(column);
        3:  193:        ans /= this->row;
        3:  194:        return ans;
        3:  194-block  0
        -:  195:    }
        -:  196:
        2:  197:    T findSum() {
        2:  197-block  0
        2:  198:        if (this->row == 0 || this->column == 0) {
        2:  198-block  0
        2:  198-block  1
    #####:  199:            cerr << "The vector is empty,can not get sum" << endl;
    #####:  200:            return 0;
    $$$$$:  200-block  0
        -:  201:        }
        2:  202:        T ans = 0;
        8:  203:        for (int i = 0; i < row; ++i) {
        2:  203-block  0
        8:  203-block  1
        6:  203-block  2
       24:  204:            for (int j = 0; j < column; ++j) {
        6:  204-block  0
       24:  204-block  1
       18:  204-block  2
       18:  205:                ans += this->matrix[i][j];
       18:  206:            }
       18:  206-block  0
        6:  207:        }
        6:  207-block  0
        2:  208:        return ans;
        2:  208-block  0
        2:  209:    }
        2:  209-block  0
        -:  210:
        6:  211:    T findSumAtRow(int row) {
        6:  211-block  0
        6:  212:        if (this->row < row) {
        6:  212-block  0
    #####:  213:            cerr << "Input row is bigger than the vector size" << endl;
    #####:  214:            return 0;
    $$$$$:  214-block  0
        -:  215:        }
        6:  216:        T ans = 0;
       24:  217:        for (int i = 0; i < column; ++i) {
        6:  217-block  0
       24:  217-block  1
       18:  217-block  2
       18:  218:            ans += this->matrix[row][i];
       18:  219:        }
       18:  219-block  0
        6:  220:        return ans;
        6:  220-block  0
        6:  221:    }
        6:  221-block  0
        -:  222:
        6:  223:    T findSumAtColumn(int column) {
        6:  223-block  0
        6:  224:        if (this->column < column) {
        6:  224-block  0
    #####:  225:            cerr << "Input column is bigger than the vector size" << endl;
    #####:  226:            return 0;
    $$$$$:  226-block  0
        -:  227:        }
        6:  228:        T ans = 0;
       24:  229:        for (int i = 0; i < this->row; ++i) {
        6:  229-block  0
       24:  229-block  1
       18:  229-block  2
       18:  230:            ans += this->matrix[i][column];
       18:  231:        }
       18:  231-block  0
        6:  232:        return ans;
        6:  232-block  0
        6:  233:    }
        6:  233-block  0
        -:  234:
        3:  235:    T cal_traces() {
        3:  235-block  0
        3:  236:        T ans = 0;
        3:  237:        int cur = min(this->row, this->column);
       12:  238:        for (int i = 0; i < cur; ++i) {
        3:  238-block  0
       12:  238-block  1
        9:  238-block  2
        9:  239:            ans += this->matrix[i][i];
        9:  240:        }
        9:  240-block  0
        3:  241:        return ans;
        3:  241-block  0
        -:  242:    }
        -:  243:
        -:  244:    void show() {
        -:  245:        cout << "Row:" << this->row << endl;
        -:  246:        cout << "Column:" << this->column << endl;
        -:  247:        cout << "[";
        -:  248:        for (int i = 0; i < row; ++i) {
        -:  249:            cout << "[";
        -:  250:            for (int j = 0; j < column; ++j) {
        -:  251:                cout << this->matrix[i][j];
        -:  252:                if (j != column - 1) {
        -:  253:                    cout << ",";
        -:  254:                }
        -:  255:            }
        -:  256:            cout << "]";
        -:  257:            if (i != row - 1) {
        -:  258:                cout << endl;
        -:  259:            }
        -:  260:        }
        -:  261:        cout << "]" << endl;
        -:  262:    }
        -:  263:
    #####:  264:    void showSize() {
    $$$$$:  264-block  0
    $$$$$:  264-block  1
    #####:  265:        cout << "Row:" << this->row << "  Column:" << this->column << endl;
    #####:  266:    }
    $$$$$:  266-block  0
    $$$$$:  266-block  1
        -:  267:
        2:  268:    int setRow(int row) {
        2:  268-block  0
        2:  269:        this->row = row;
        2:  270:        this->matrix.resize(row);
        2:  271:        return 1;
        2:  271-block  0
        -:  272:    }
        -:  273:
       12:  274:    int getRow() {
       12:  274-block  0
       12:  275:        return this->row;
       12:  275-block  0
        -:  276:    }
        -:  277:
        2:  278:    int setColumn(int column) {
        2:  278-block  0
        2:  279:        if (this->row == 0) {
        2:  279-block  0
    #####:  280:            return 0;
    $$$$$:  280-block  0
        -:  281:        }
        2:  282:        this->column = column;
        6:  283:        for (int i = 0; i < row; ++i) {
        2:  283-block  0
        6:  283-block  1
        4:  283-block  2
        4:  284:            this->matrix[i].resize(column);
        4:  285:        }
        4:  285-block  0
        2:  286:        return 1;
        2:  286-block  0
        2:  287:    }
        2:  287-block  0
        -:  288:
       39:  289:    int getColumn() {
       39:  289-block  0
       39:  290:        return this->column;
       39:  290-block  0
        -:  291:
        -:  292:    }
        -:  293:
        1:  294:    vector<T> getEigenvalue() {
        1:  294-block  0
        1:  295:        if (this->row != this->column) {
        1:  295-block  0
    #####:  296:            cerr << "The matrix is not a square matrix" << endl;
    #####:  297:            vector<T> k;
    #####:  298:            return k;
    #####:  299:        }
    $$$$$:  299-block  0
    $$$$$:  299-block  1
        -:  300:        class temp {
        -:  301:        public:
        -:  302:            double K1[1000];
        -:  303:            double Ret[1000];
        -:  304:
        1:  305:            void Matrix_Hessenberg(double *A1, int n, double *ret) {
        1:  305-block  0
        -:  306:                int i, j, k, MaxNumber;
        -:  307:                double temp, *A;
        1:  308:                A = new double[n * n];
        4:  309:                for (i = 0; i < n; i++) {
        1:  309-block  0
        4:  309-block  1
        3:  309-block  2
        3:  310:                    k = i * n;
       12:  311:                    for (j = 0; j < n; j++) {
        3:  311-block  0
       12:  311-block  1
        9:  311-block  2
        9:  312:                        A[k + j] = A1[k + j];
        9:  313:                    }
        9:  313-block  0
        3:  314:                }
        3:  314-block  0
        2:  315:                for (k = 1; k < n - 1; k++) {
        1:  315-block  0
        2:  315-block  1
        1:  315-block  2
        1:  316:                    i = k - 1;
        1:  317:                    MaxNumber = k;
        1:  318:                    temp = abs(A[k * n + i]);
        2:  319:                    for (j = k + 1; j < n; j++) {
        1:  319-block  0
        2:  319-block  1
        1:  319-block  2
        1:  320:                        if (abs(A[j * n + i]) > temp) {
        1:  320-block  0
        1:  321:                            temp = abs(A[j * n + i]);
        1:  322:                            MaxNumber = j;
        1:  323:                        }
        1:  323-block  0
        1:  324:                    }
        1:  324-block  0
        1:  325:                    ret[0] = A[MaxNumber * n + i];
        1:  326:                    i = MaxNumber;
        1:  327:                    if (ret[0] != 0) {
        1:  327-block  0
        1:  328:                        if (i != k) {
        1:  328-block  0
        4:  329:                            for (j = k - 1; j < n; j++) {
        1:  329-block  0
        4:  329-block  1
        3:  329-block  2
        3:  330:                                temp = A[i * n + j];
        3:  331:                                A[i * n + j] = A[k * n + j];
        3:  332:                                A[k * n + j] = temp;
        3:  333:                            }
        3:  333-block  0
        4:  334:                            for (j = 0; j < n; j++) {
        1:  334-block  0
        4:  334-block  1
        3:  334-block  2
        3:  335:                                temp = A[j * n + i];
        3:  336:                                A[j * n + i] = A[j * n + k];
        3:  337:                                A[j * n + k] = temp;
        3:  338:                            }
        3:  338-block  0
        1:  339:                        }
        1:  339-block  0
        2:  340:                        for (i = k + 1; i < n; i++) {
        1:  340-block  0
        2:  340-block  1
        1:  340-block  2
        1:  341:                            temp = A[i * n + k - 1] / ret[0];
        1:  342:                            A[i * n + k - 1] = 0;
        3:  343:                            for (j = k; j < n; j++) {
        1:  343-block  0
        3:  343-block  1
        2:  343-block  2
        2:  344:                                A[i * n + j] -= temp * A[k * n + j];
        2:  345:                            }
        2:  345-block  0
        4:  346:                            for (j = 0; j < n; j++) {
        1:  346-block  0
        4:  346-block  1
        3:  346-block  2
        3:  347:                                A[j * n + k] += temp * A[j * n + i];
        3:  348:                            }
        3:  348-block  0
        1:  349:                        }
        1:  349-block  0
        1:  350:                    }
        1:  350-block  0
        -:  351:
        1:  352:                }
        1:  352-block  0
        4:  353:                for (i = 0; i < n; i++) {
        1:  353-block  0
        4:  353-block  1
        3:  353-block  2
        3:  354:                    k = i * n;
       12:  355:                    for (j = 0; j < n; j++) {
        3:  355-block  0
       12:  355-block  1
        9:  355-block  2
        9:  356:                        ret[k + j] = A[k + j];
        9:  357:                    }
        9:  357-block  0
        3:  358:                }
        3:  358-block  0
        1:  359:                delete[]A;
        1:  359-block  0
        1:  359-block  1
        1:  360:            }
        1:  360-block  0
        -:  361:
        1:  362:            bool Matrix_EigenValue(int n, int LoopNumber, double Error1) {
        1:  362-block  0
        -:  363:                int i, j, k, t, m, Loop1;
        -:  364:                double b, c, d, g, xy, p, q, r, x, s, e, f, z, y, temp, *A;
        1:  365:                A = new double[n * n];
        1:  366:                Matrix_Hessenberg(K1, n, A);
        1:  367:                m = n;
        1:  368:                Loop1 = LoopNumber;
        6:  369:                while (m != 0) {
        1:  369-block  0
        6:  369-block  1
        5:  369-block  2
        5:  370:                    t = m - 1;
       12:  371:                    while (t > 0) {
        5:  371-block  0
       12:  371-block  1
        7:  371-block  2
        8:  372:                        temp = abs(A[(t - 1) * n + t - 1]);
        8:  373:                        temp += abs(A[t * n + t]);
        8:  374:                        temp = temp * Error1;
        8:  375:                        if (abs(A[t * n + t - 1]) > temp) {
        8:  375-block  0
        7:  376:                            t--;
        7:  377:                        } else {
        7:  377-block  0
        1:  378:                            break;
        1:  378-block  0
        -:  379:                        }
        -:  380:                    }
        5:  381:                    if (t == m - 1) {
        5:  381-block  0
        1:  382:                        Ret[(m - 1) * 2] = A[(m - 1) * n + m - 1];
        1:  383:                        Ret[(m - 1) * 2 + 1] = 0;
        1:  384:                        m -= 1;
        1:  385:                        Loop1 = LoopNumber;
        5:  386:                    } else if (t == m - 2) {
        1:  386-block  0
        4:  386-block  1
        1:  387:                        b = -A[(m - 1) * n + m - 1] - A[(m - 2) * n + m - 2];
        2:  388:                        c = A[(m - 1) * n + m - 1] * A[(m - 2) * n + m - 2] -
        1:  389:                            A[(m - 1) * n + m - 2] * A[(m - 2) * n + m - 1];
        1:  390:                        d = b * b - 4 * c;
        1:  391:                        y = sqrt(abs(d));
        1:  392:                        if (d > 0) {
        1:  392-block  0
        1:  393:                            xy = 1;
        1:  394:                            if (b < 0) {
        1:  394-block  0
        1:  395:                                xy = -1;
        1:  396:                            }
        1:  396-block  0
        1:  397:                            Ret[(m - 1) * 2] = -(b + xy * y) / 2;
        1:  398:                            Ret[(m - 1) * 2 + 1] = 0;
        1:  399:                            Ret[(m - 2) * 2] = c / Ret[(m - 1) * 2];
        1:  400:                            Ret[(m - 2) * 2 + 1] = 0;
        1:  401:                        } else {
        1:  401-block  0
    #####:  402:                            Ret[(m - 1) * 2] = -b / 2;
    #####:  403:                            Ret[(m - 2) * 2] = -b / 2;
    #####:  404:                            Ret[(m - 1) * 2 + 1] = y / 2;
    #####:  405:                            Ret[(m - 2) * 2 + 1] = -y / 2;
    $$$$$:  405-block  0
        -:  406:                        }
        1:  407:                        m -= 2;
        1:  408:                        Loop1 = LoopNumber;
        1:  409:                    } else {
        1:  409-block  0
        3:  410:                        if (Loop1 < 1) {
        3:  410-block  0
    #####:  411:                            return false;
    $$$$$:  411-block  0
        -:  412:                        }
        3:  413:                        Loop1--;
        3:  414:                        j = t + 2;
        6:  415:                        while (j < m) {
        3:  415-block  0
        6:  415-block  1
        3:  415-block  2
        3:  416:                            A[j * n + j - 2] = 0;
        3:  417:                            j++;
        -:  418:                        }
        3:  419:                        j = t + 3;
        3:  420:                        while (j < m) {
        3:  420-block  0
        3:  420-block  1
    $$$$$:  420-block  2
    #####:  421:                            A[j * n + j - 3] = 0;
    #####:  422:                            j++;
        -:  423:                        }
        3:  424:                        k = t;
        9:  425:                        while (k < m - 1) {
        3:  425-block  0
        9:  425-block  1
        6:  425-block  2
        6:  426:                            if (k != t) {
        6:  426-block  0
        3:  427:                                p = A[k * n + k - 1];
        3:  428:                                q = A[(k + 1) * n + k - 1];
        3:  429:                                if (k != m - 2) {
        3:  429-block  0
    #####:  430:                                    r = A[(k + 2) * n + k - 1];
    #####:  431:                                } else {
    $$$$$:  431-block  0
        3:  432:                                    r = 0;
        3:  432-block  0
        -:  433:                                }
        3:  434:                            } else {
        3:  434-block  0
        3:  435:                                b = A[(m - 1) * n + m - 1];
        3:  436:                                c = A[(m - 2) * n + m - 2];
        3:  437:                                x = b + c;
        3:  438:                                y = b * c - A[(m - 2) * n + m - 1] * A[(m - 1) * n + m - 2];
        3:  439:                                p = A[t * n + t] * (A[t * n + t] - x) + A[t * n + t + 1] * A[(t + 1) * n + t] + y;
        3:  440:                                q = A[(t + 1) * n + t] * (A[t * n + t] + A[(t + 1) * n + t + 1] - x);
        3:  441:                                r = A[(t + 1) * n + t] * A[(t + 2) * n + t + 1];
        3:  441-block  0
        -:  442:                            }
        6:  443:                            if (p != 0 || q != 0 || r != 0) {
        6:  443-block  0
    $$$$$:  443-block  1
    $$$$$:  443-block  2
        6:  444:                                if (p < 0) {
        6:  444-block  0
        2:  445:                                    xy = -1;
        2:  446:                                } else {
        2:  446-block  0
        4:  447:                                    xy = 1;
        4:  447-block  0
        -:  448:                                }
        6:  449:                                s = xy * sqrt(p * p + q * q + r * r);
        6:  450:                                if (k != t) {
        6:  450-block  0
        3:  451:                                    A[k * n + k - 1] = -s;
        3:  452:                                }
        3:  452-block  0
        6:  453:                                e = -q / s;
        6:  454:                                f = -r / s;
        6:  455:                                x = -p / s;
        6:  456:                                y = -x - f * r / (p + s);
        6:  457:                                g = e * r / (p + s);
        6:  458:                                z = -x - e * q / (p + s);
       21:  459:                                for (j = k; j < m; j++) {
        6:  459-block  0
       21:  459-block  1
       15:  459-block  2
       15:  460:                                    b = A[k * n + j];
       15:  461:                                    c = A[(k + 1) * n + j];
       15:  462:                                    p = x * b + e * c;
       15:  463:                                    q = e * b + y * c;
       15:  464:                                    r = f * b + g * c;
       15:  465:                                    if (k != m - 2) {
       15:  465-block  0
        9:  466:                                        b = A[(k + 2) * n + j];
        9:  467:                                        p += f * b;
        9:  468:                                        q += g * b;
        9:  469:                                        r += z * b;
        9:  470:                                        A[(k + 2) * n + j] = r;
        9:  471:                                    }
        9:  471-block  0
       15:  472:                                    A[(k + 1) * n + j] = q;
       15:  473:                                    A[k * n + j] = p;
       15:  474:                                }
       15:  474-block  0
        6:  475:                                j = k + 3;
        6:  476:                                if (j > m - 2) {
        6:  476-block  0
        6:  477:                                    j = m - 1;
        6:  478:                                }
        6:  478-block  0
       24:  479:                                for (i = t; i < j + 1; i++) {
        6:  479-block  0
       24:  479-block  1
       18:  479-block  2
       18:  480:                                    b = A[i * n + k];
       18:  481:                                    c = A[i * n + k + 1];
       18:  482:                                    p = x * b + e * c;
       18:  483:                                    q = e * b + y * c;
       18:  484:                                    r = f * b + g * c;
       18:  485:                                    if (k != m - 2) {
       18:  485-block  0
        9:  486:                                        b = A[i * n + k + 2];
        9:  487:                                        p += f * b;
        9:  488:                                        q += g * b;
        9:  489:                                        r += z * b;
        9:  490:                                        A[i * n + k + 2] = r;
        9:  491:                                    }
        9:  491-block  0
       18:  492:                                    A[i * n + k + 1] = q;
       18:  493:                                    A[i * n + k] = p;
       18:  494:                                }
       18:  494-block  0
        6:  495:                            }
        6:  495-block  0
        6:  496:                            k++;
        -:  497:                        }
        -:  498:                    }
        -:  499:                }
        1:  500:                delete[]A;
        1:  500-block  0
        1:  500-block  1
        1:  501:                return true;
        1:  501-block  0
        1:  502:            }
        1:  502-block  0
        -:  503:        };
        -:  504:        temp ans;
        1:  505:        int count = 0;
        4:  506:        for (int i = 0; i < this->row; ++i) {
        1:  506-block  0
        4:  506-block  1
        3:  506-block  2
       12:  507:            for (int j = 0; j < this->column; ++j) {
        3:  507-block  0
       12:  507-block  1
        9:  507-block  2
        9:  508:                ans.K1[count++] = this->matrix[i][j];
        9:  509:            }
        9:  509-block  0
        3:  510:        }
        3:  510-block  0
        1:  511:        vector<T> result;
        1:  512:        ans.Matrix_EigenValue(this->row, 1000, 0.00001);
        1:  512-block  0
        4:  513:        for (int i = 0; i < this->row; ++i) {
        1:  513-block  0
        4:  513-block  1
        3:  513-block  2
        3:  514:            result.push_back(ans.Ret[i * 2]);
        3:  514-block  0
        3:  515:        }
        3:  515-block  0
        -:  516:
        1:  517:        return result;
        1:  518:    }
    $$$$$:  518-block  0
        1:  518-block  1
        1:  518-block  2
    $$$$$:  518-block  3
        -:  519:
        1:  520:    Matrix transposition() {
        1:  520-block  0
        1:  521:        Matrix ans = Matrix(this->column, this->row);
        3:  522:        for (int i = 0; i < this->row; ++i) {
        1:  522-block  0
        3:  522-block  1
        2:  522-block  2
        6:  523:            for (int j = 0; j < this->column; ++j) {
        2:  523-block  0
        6:  523-block  1
        4:  523-block  2
        4:  524:                ans[j][i] = this->matrix[i][j];
        4:  524-block  0
        4:  525:            }
        4:  525-block  0
        2:  526:        }
        2:  526-block  0
        1:  527:        return ans;
        1:  528:    }
    $$$$$:  528-block  0
        1:  528-block  1
    $$$$$:  528-block  2
        1:  528-block  3
    $$$$$:  528-block  4
        -:  529:
        1:  530:    Matrix transposition_change() {
        1:  530-block  0
        1:  531:        Matrix ans = this->transposition();
        1:  532:        this->row = ans.row;
        1:  533:        this->column = ans.column;
        1:  534:        this->matrix = ans.matrix;
        1:  534-block  0
        1:  535:        return ans;
        1:  536:    }
        1:  536-block  0
    $$$$$:  536-block  1
    $$$$$:  536-block  2
        1:  536-block  3
    $$$$$:  536-block  4
        -:  537:
        -:  538:    Matrix conjugation() {
        -:  539:        Matrix ans = Matrix(this->row, this->column);
        -:  540:        for (int i = 0; i < this->row; ++i) {
        -:  541:            for (int j = 0; j < this->column; ++j) {
        -:  542:                T cur(this->matrix[i][j].real(), -this->matrix[i][j].imag());
        -:  543:                ans[i][j] = cur;
        -:  544:            }
        -:  545:        }
        -:  546:        return ans;
        -:  547:    }
        -:  548:
        -:  549:    Matrix conjugation_change() {
        -:  550:        Matrix ans = this->conjugation();
        -:  551:        this->matrix = ans.matrix;
        -:  552:        return ans;
        -:  553:    }
        -:  554:
        -:  555:    Matrix element_wise_multiplication(Matrix &other) {
        -:  556:        if (this->row != other.row || this->column != other.column) {
        -:  557:            cerr << "the size of these two vector is not equal" << endl;
        -:  558:            cerr << "left size is:";
        -:  559:            this->showSize();
        -:  560:            cerr << "right size is:";
        -:  561:            other.showSize();
        -:  562:            return Matrix(0, 0);
        -:  563:        }
        -:  564:        Matrix ans = Matrix(this->row, this->column);
        -:  565:        for (int i = 0; i < this->row; ++i) {
        -:  566:            for (int j = 0; j < this->column; ++j) {
        -:  567:                ans[i][j] = this->matrix[i][j] * other.matrix[i][j];
        -:  568:            }
        -:  569:        }
        -:  570:        return ans;
        -:  571:    }
        -:  572:
        1:  573:    Matrix element_wise_multiplication_change(Matrix &other) {
        1:  573-block  0
        1:  574:        if (this->row != other.row || this->column != other.column) {
        1:  574-block  0
        1:  574-block  1
    #####:  575:            cerr << "the size of these two vector is not equal" << endl;
    #####:  576:            cerr << "left size is:";
    #####:  577:            this->showSize();
    #####:  578:            cerr << "right size is:";
    #####:  579:            other.showSize();
    #####:  580:            return Matrix(0, 0);
    $$$$$:  580-block  0
        -:  581:        }
        1:  582:        Matrix ans = Matrix(this->row, this->column);
        3:  583:        for (int i = 0; i < this->row; ++i) {
        1:  583-block  0
        3:  583-block  1
        2:  583-block  2
        6:  584:            for (int j = 0; j < this->column; ++j) {
        2:  584-block  0
        6:  584-block  1
        4:  584-block  2
        4:  585:                ans[i][j] = this->matrix[i][j] * other.matrix[i][j];
        4:  585-block  0
        4:  586:            }
        4:  586-block  0
        2:  587:        }
        2:  587-block  0
        1:  588:        this->row = ans.row;
        1:  589:        this->column = ans.column;
        1:  590:        this->matrix = ans.matrix;
        1:  590-block  0
        1:  591:        return ans;
        1:  591-block  0
        1:  592:    }
    $$$$$:  592-block  0
        1:  592-block  1
        1:  592-block  2
    $$$$$:  592-block  3
        -:  593:
        -:  594:    Matrix reshape(int row, int column) {
        -:  595:        Matrix ans = Matrix(row, column);
        -:  596:        int other = row * column;
        -:  597:        int cur = this->row * this->column;
        -:  598:        int count = 0;
        -:  599:        while (count < min(other, cur)) {
        -:  600:            int curRow = count / this->column;
        -:  601:            int curColumn = count % this->column;
        -:  602:            int ansRow = count / column;
        -:  603:            int ansColumn = count % column;
        -:  604:            ans[ansRow][ansColumn] = this->matrix[curRow][curColumn];
        -:  605:            count++;
        -:  606:        }
        -:  607:        return ans;
        -:  608:    }
        -:  609:
        -:  610:    Matrix reshape_change(int row, int column) {
        -:  611:        Matrix ans = this->reshape(row, column);
        -:  612:        this->row = row;
        -:  613:        this->column = column;
        -:  614:        this->matrix = ans.matrix;
        -:  615:        return ans;
        -:  616:    }
        -:  617:
        -:  618:    Vector<T> slicing(int from, int to) {
        -:  619:        Matrix cur = this->reshape(1, this->row * this->column);
        -:  620:        if (to > cur.column) {
        -:  621:            cerr << "slicing error" << endl;
        -:  622:            cerr << "slicing bound is large than matrix size" << endl;
        -:  623:            return Vector<T>(0);
        -:  624:        }
        -:  625:        if (from < 0) {
        -:  626:            cerr << "slicing error" << endl;
        -:  627:            cerr << "slicing left bound is little than 0" << endl;
        -:  628:            return Vector<T>(0);
        -:  629:        }
        -:  630:        Vector<T> ans = Vector<T>(to - from);
        -:  631:        for (int i = 0; i < ans.getLength(); ++i) {
        -:  632:            ans[i] = cur.matrix[0][from + i];
        -:  633:        }
        -:  634:        return ans;
        -:  635:    }
        -:  636:
        1:  637:    Matrix operator+(Matrix &other) {
        1:  637-block  0
        1:  638:        if (this->row != other.row || this->column != other.column) {
        1:  638-block  0
        1:  638-block  1
    #####:  639:            cerr << "the size of these two vector is not equal" << endl;
    #####:  640:            cerr << "left size is:";
    #####:  641:            showSize();
    #####:  642:            cerr << "right size is:";
    #####:  643:            other.showSize();
    #####:  644:            return Matrix(0, 0);
    $$$$$:  644-block  0
        -:  645:        }
        1:  646:        Matrix ans = Matrix(row, column);
        4:  647:        for (int i = 0; i < row; ++i) {
        1:  647-block  0
        4:  647-block  1
        3:  647-block  2
       12:  648:            for (int j = 0; j < column; ++j) {
        3:  648-block  0
       12:  648-block  1
        9:  648-block  2
        9:  649:                ans[i][j] = this->matrix[i][j] + other.matrix[i][j];
        9:  649-block  0
        9:  650:            }
        9:  650-block  0
        3:  651:        }
        3:  651-block  0
        1:  652:        return ans;
        1:  652-block  0
        1:  653:    }
    $$$$$:  653-block  0
        1:  653-block  1
        1:  653-block  2
    $$$$$:  653-block  3
        -:  654:
        -:  655:    Matrix operator+(Vector<T> other) const {
        -:  656:        if (this->column != other.getLength()) {
        -:  657:            cerr << "The column of the matrix is not equal to the vector length" << endl;
        -:  658:            return Matrix(0, 0);
        -:  659:        }
        -:  660:        Matrix ans = Matrix(this->row, this->column);
        -:  661:        for (int i = 0; i < row; ++i) {
        -:  662:            for (int j = 0; j < column; ++j) {
        -:  663:                ans[i][j] = this->matrix[i][j] + other[j];
        -:  664:            }
        -:  665:        }
        -:  666:        return ans;
        -:  667:    }
        -:  668:
        -:  669:    Matrix operator-(const Matrix &other) const {
        -:  670:        if (this->row != other.row || this->column != other.column) {
        -:  671:            cerr << "the size of these two vector is not equal" << endl;
        -:  672:            cerr << "left size is:";
        -:  673:            this->showSize();
        -:  674:            cerr << "right size is:";
        -:  675:            other.showSize();
        -:  676:            return Matrix(0, 0);
        -:  677:        }
        -:  678:        Matrix ans = Matrix(row, column);
        -:  679:        for (int i = 0; i < row; ++i) {
        -:  680:            for (int j = 0; j < column; ++j) {
        -:  681:                ans[i][j] = this->matrix[i][j] - other.matrix[i][j];
        -:  682:            }
        -:  683:        }
        -:  684:        return ans;
        -:  685:    }
        -:  686:
        -:  687:    Matrix operator-(Vector<T> other) const {
        -:  688:        if (this->column != other.getLength()) {
        -:  689:            cerr << "The column of the matrix is not equal to the vector length" << endl;
        -:  690:            return Matrix(0, 0);
        -:  691:        }
        -:  692:        Matrix ans = Matrix(this->row, this->column);
        -:  693:        for (int i = 0; i < row; ++i) {
        -:  694:            for (int j = 0; j < column; ++j) {
        -:  695:                ans[i][j] = this->matrix[i][j] - other[j];
        -:  696:            }
        -:  697:        }
        -:  698:        return ans;
        -:  699:    }
        -:  700:
        -:  701:    Matrix operator*(const Matrix &other) const {
        -:  702:        if (this->column != other.row) {
        -:  703:            cerr << "multiple error!" << endl;
        -:  704:            cerr << "the left matrix column is not equal right matrix row" << endl;
        -:  705:        }
        -:  706:        Matrix ans = Matrix(this->row, other.column);
        -:  707:        for (int i = 0; i < this->row; ++i) {
        -:  708:            for (int j = 0; j < other.column; ++j) {
        -:  709:                for (int k = 0; k < this->column; ++k) {
        -:  710:                    ans[i][j] += this->matrix[i][k] * other.matrix[k][j];
        -:  711:                }
        -:  712:            }
        -:  713:        }
        -:  714:        return ans;
        -:  715:    }
        -:  716:
        -:  717:    Vector<T> operator*(Vector<T> other) const {
        -:  718:        if (this->column != other.getLength()) {
        -:  719:            cerr << "Matrix * Vector error!" << endl;
        -:  720:            cerr << "The left Matrix column is not equal right length" << endl;
        -:  721:            return Vector<T>(0);
        -:  722:        }
        -:  723:        Vector<T> ans = Vector<T>(other.getLength());
        -:  724:        for (int i = 0; i < other.getLength(); ++i) {
        -:  725:            for (int j = 0; j < other.getLength(); ++j) {
        -:  726:                ans[i] += this->matrix[i][j] * other[j];
        -:  727:            }
        -:  728:        }
        -:  729:        return ans;
        -:  730:    }
        -:  731:
        3:  732:    T cal_det() {
        3:  732-block  0
        3:  733:        if (this->row != this->column) {
        3:  733-block  0
    #####:  734:            cerr << "The matrix is not square matrix";
    #####:  735:            return 0;
    $$$$$:  735-block  0
        -:  736:        }
        -:  737:        class temp {
        -:  738:        public:
       30:  739:            double det(int n, double *mm) {
       30:  739-block  0
       30:  740:                if (n == 1)
       30:  740-block  0
       18:  741:                    return mm[0];
       18:  741-block  0
       12:  742:                double *subMat = new double[(n - 1) * (n - 1)];//创建n-1阶的代数余子式阵subMat
       12:  743:                int mov = 0;//判断行是否移动
       12:  744:                double sum = 0.0;//sum为行列式的值
       39:  745:                for (int Matrow = 0; Matrow < n; Matrow++) // Mat的行数把矩阵Mat(nn)赋值到subMat(n-1)
       12:  745-block  0
       39:  745-block  1
       27:  745-block  2
        -:  746:                {
       63:  747:                    for (int subMatrow = 0; subMatrow < n - 1; subMatrow++)//把Mat阵第一列各元素的代数余子式存到subMat
       27:  747-block  0
       63:  747-block  1
       36:  747-block  2
        -:  748:                    {
       36:  749:                        mov = Matrow > subMatrow ? 0 : 1; //subMat中小于Matrow的行，同行赋值，等于的错过，大于的加一
       90:  750:                        for (int j = 0; j < n - 1; j++)  //从Mat的第二列赋值到第n列
       36:  750-block  0
       90:  750-block  1
       54:  750-block  2
        -:  751:                        {
       54:  752:                            subMat[subMatrow * (n - 1) + j] = mm[(subMatrow + mov) * n + j + 1];
       54:  753:                        }
       54:  753-block  0
       36:  754:                    }
       36:  754-block  0
       27:  755:                    int flag = (Matrow % 2 == 0 ? 1 : -1);//因为列数为0，所以行数是偶数时候，代数余子式为1.
       27:  756:                    sum += flag * mm[Matrow * n] * det(n - 1, subMat);//Mat第一列各元素与其代数余子式积的和即为行列式
       27:  757:                }
       27:  757-block  0
       12:  758:                delete[]subMat;
       12:  758-block  0
       12:  758-block  1
       12:  759:                return sum;
       12:  759-block  0
       30:  760:            }
       30:  760-block  0
        -:  761:        };
        3:  762:        double *cur = new double[this->row * this->row];
        3:  763:        int count = 0;
       12:  764:        for (int i = 0; i < this->row; ++i) {
        3:  764-block  0
       12:  764-block  1
        9:  764-block  2
       36:  765:            for (int j = 0; j < this->row; ++j) {
        9:  765-block  0
       36:  765-block  1
       27:  765-block  2
       27:  766:                cur[count++] = this->matrix[i][j];
       27:  767:            }
       27:  767-block  0
        9:  768:        }
        9:  768-block  0
        -:  769:        temp ans;
        3:  770:        return ans.det(this->row, cur);
        3:  770-block  0
        3:  771:    }
        3:  771-block  0
        -:  772:
       14:  773:    Matrix(vector<vector<T>> other);
        -:  774:
        -:  775:    Matrix(Mat other);
        -:  776:
        -:  777:    Mat to_opencv_32FC1();
        -:  778:
        -:  779:    Mat to_opencv_8UC1();
        -:  780:
        1:  781:    Matrix convolution_2D(Matrix &kernel) {
        1:  781-block  0
        -:  782:        // find center position of kernel (half of kernel size)
        1:  783:        int kCenterX = kernel.column / 2;
        1:  784:        int kCenterY = kernel.row / 2;
        1:  785:        Matrix ans = Matrix(this->row, this->column);
        5:  786:        for (int i = 0; i < this->row; ++i) // rows
        1:  786-block  0
        5:  786-block  1
        4:  786-block  2
        -:  787:        {
       20:  788:            for (int j = 0; j < this->column; ++j) // columns
        4:  788-block  0
       20:  788-block  1
       16:  788-block  2
        -:  789:            {
       64:  790:                for (int m = 0; m < kernel.row; ++m) // kernel rows
       16:  790-block  0
       64:  790-block  1
       48:  790-block  2
        -:  791:                {
       48:  792:                    int mm = kernel.row - 1 - m; // row index
        -:  793:
      192:  794:                    for (int n = 0; n < kernel.column; ++n) // kernel columns
       48:  794-block  0
      192:  794-block  1
      144:  794-block  2
        -:  795:                    {
      144:  796:                        int nn = kernel.column - 1 - n; // column index
        -:  797:
        -:  798:                        // index of input signal, used for checking boundary
      144:  799:                        int ii = i + (m - kCenterY);
      144:  800:                        int jj = j + (n - kCenterX);
        -:  801:
        -:  802:                        // ignore input samples which are out of bound
      144:  803:                        if (ii >= 0 && ii < this->row && jj >= 0 && jj < this->column)
      144:  803-block  0
      132:  803-block  1
      120:  803-block  2
      110:  803-block  3
      100:  804:                            ans[i][j] += this->matrix[ii][jj] * kernel[m][n];
      100:  804-block  0
      100:  804-block  1
      100:  804-block  2
      144:  805:                    }
      144:  805-block  0
       48:  806:                }
       48:  806-block  0
       16:  807:            }
       16:  807-block  0
        4:  808:        }
        4:  808-block  0
        1:  809:        return ans;
        -:  810:
        1:  811:    }
    $$$$$:  811-block  0
        1:  811-block  1
    $$$$$:  811-block  2
        1:  811-block  3
    $$$$$:  811-block  4
        -:  812:
        -:  813:private:
        -:  814:    vector<vector<T>> matrix;
       25:  815:    int row{}, column{};
        -:  816:};
        -:  817:
        -:  818:
        -:  819:template<class T>
       28:  820:Matrix<T>::Matrix(vector<vector<T>> other) {
       14:  820-block  0
       14:  820-block  1
       14:  821:    this->row = other.size();
       14:  822:    this->column = other[0].size();
       14:  823:    this->matrix = other;
       14:  823-block  0
       28:  824:}
       14:  824-block  0
       14:  824-block  1
    $$$$$:  824-block  2
    $$$$$:  824-block  3
        -:  825:
        -:  826:template<class T>
        -:  827:Mat Matrix<T>::to_opencv_8UC1() {
        -:  828:    Mat ans = Mat::zeros(Size(this->column, this->row), CV_8UC1);
        -:  829:    for (int i = 0; i < this->row; ++i) {
        -:  830:        for (int j = 0; j < this->column; ++j) {
        -:  831:            ans.at<float>(i, j) = this->matrix[i][j];
        -:  832:        }
        -:  833:    }
        -:  834:    return ans;
        -:  835:}
        -:  836:
        -:  837:template<class T>
        1:  838:Mat Matrix<T>::to_opencv_32FC1() {
        1:  838-block  0
        1:  839:    Mat ans = Mat::zeros(Size(this->column, this->row), CV_32FC1);
        1:  839-block  0
    $$$$$:  839-block  1
    $$$$$:  839-block  2
        4:  840:    for (int i = 0; i < this->row; ++i) {
        1:  840-block  0
        4:  840-block  1
        3:  840-block  2
       12:  841:        for (int j = 0; j < this->column; ++j) {
        3:  841-block  0
       12:  841-block  1
        9:  841-block  2
        9:  842:            ans.at<float>(i, j) = this->matrix[i][j];
        9:  842-block  0
        9:  843:        }
        9:  843-block  0
        3:  844:    }
        3:  844-block  0
        1:  845:    return ans;
        1:  846:}
    $$$$$:  846-block  0
        1:  846-block  1
    $$$$$:  846-block  2
        1:  846-block  3
        -:  847:
        -:  848:template<class T>
        -:  849:Matrix<T>::Matrix(Mat other) {
        -:  850:    Matrix ans = Matrix(other.rows, other.cols);
        -:  851:    if (other.type() == CV_32FC1) {
        -:  852:        for (int i = 0; i < other.rows; ++i) {
        -:  853:            for (int j = 0; j < other.cols; ++j) {
        -:  854:                ans[i][j] = other.at<float>(i, j);
        -:  855:            }
        -:  856:        }
        -:  857:    } else if (other.type() == CV_8UC1) {
        -:  858:        for (int i = 0; i < other.rows; ++i) {
        -:  859:            for (int j = 0; j < other.cols; ++j) {
        -:  860:                ans[i][j] = other.at<uchar>(i, j);
        -:  861:            }
        -:  862:        }
        -:  863:    }
        -:  864:    this->row = ans.row;
        -:  865:    this->column = ans.column;
        -:  866:    this->matrix = ans.matrix;
        -:  867:}
        -:  868:
        -:  869:#endif //CPPPROJECT_MATRIX_HPP
