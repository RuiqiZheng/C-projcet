        -:    0:Source:/usr/local/Cellar/opencv/4.3.0_4/include/opencv4/opencv2/core/mat.inl.hpp
        -:    0:Graph:/Users/bytedance/CLionProjects/C-projcet/cmake-build-debug/CMakeFiles/cppProject.dir/code/main.cpp.gcno
        -:    0:Data:/Users/bytedance/CLionProjects/C-projcet/cmake-build-debug/CMakeFiles/cppProject.dir/code/main.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*M///////////////////////////////////////////////////////////////////////////////////////
        -:    2://
        -:    3://  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
        -:    4://
        -:    5://  By downloading, copying, installing or using the software you agree to this license.
        -:    6://  If you do not agree to this license, do not download, install,
        -:    7://  copy or use the software.
        -:    8://
        -:    9://
        -:   10://                          License Agreement
        -:   11://                For Open Source Computer Vision Library
        -:   12://
        -:   13:// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.
        -:   14:// Copyright (C) 2009, Willow Garage Inc., all rights reserved.
        -:   15:// Copyright (C) 2013, OpenCV Foundation, all rights reserved.
        -:   16:// Copyright (C) 2015, Itseez Inc., all rights reserved.
        -:   17:// Third party copyrights are property of their respective owners.
        -:   18://
        -:   19:// Redistribution and use in source and binary forms, with or without modification,
        -:   20:// are permitted provided that the following conditions are met:
        -:   21://
        -:   22://   * Redistribution's of source code must retain the above copyright notice,
        -:   23://     this list of conditions and the following disclaimer.
        -:   24://
        -:   25://   * Redistribution's in binary form must reproduce the above copyright notice,
        -:   26://     this list of conditions and the following disclaimer in the documentation
        -:   27://     and/or other materials provided with the distribution.
        -:   28://
        -:   29://   * The name of the copyright holders may not be used to endorse or promote products
        -:   30://     derived from this software without specific prior written permission.
        -:   31://
        -:   32:// This software is provided by the copyright holders and contributors "as is" and
        -:   33:// any express or implied warranties, including, but not limited to, the implied
        -:   34:// warranties of merchantability and fitness for a particular purpose are disclaimed.
        -:   35:// In no event shall the Intel Corporation or contributors be liable for any direct,
        -:   36:// indirect, incidental, special, exemplary, or consequential damages
        -:   37:// (including, but not limited to, procurement of substitute goods or services;
        -:   38:// loss of use, data, or profits; or business interruption) however caused
        -:   39:// and on any theory of liability, whether in contract, strict liability,
        -:   40:// or tort (including negligence or otherwise) arising in any way out of
        -:   41:// the use of this software, even if advised of the possibility of such damage.
        -:   42://
        -:   43://M*/
        -:   44:
        -:   45:#ifndef OPENCV_CORE_MATRIX_OPERATIONS_HPP
        -:   46:#define OPENCV_CORE_MATRIX_OPERATIONS_HPP
        -:   47:
        -:   48:#ifndef __cplusplus
        -:   49:#  error mat.inl.hpp header must be compiled as C++
        -:   50:#endif
        -:   51:
        -:   52:#ifdef _MSC_VER
        -:   53:#pragma warning( push )
        -:   54:#pragma warning( disable: 4127 )
        -:   55:#endif
        -:   56:
        -:   57:#if defined(CV_SKIP_DISABLE_CLANG_ENUM_WARNINGS)
        -:   58:  // nothing
        -:   59:#elif defined(CV_FORCE_DISABLE_CLANG_ENUM_WARNINGS)
        -:   60:  #define CV_DISABLE_CLANG_ENUM_WARNINGS
        -:   61:#elif defined(__clang__) && defined(__has_warning)
        -:   62:  #if __has_warning("-Wdeprecated-enum-enum-conversion") && __has_warning("-Wdeprecated-anon-enum-enum-conversion")
        -:   63:    #define CV_DISABLE_CLANG_ENUM_WARNINGS
        -:   64:  #endif
        -:   65:#endif
        -:   66:#ifdef CV_DISABLE_CLANG_ENUM_WARNINGS
        -:   67:#pragma clang diagnostic push
        -:   68:#pragma clang diagnostic ignored "-Wdeprecated-enum-enum-conversion"
        -:   69:#pragma clang diagnostic ignored "-Wdeprecated-anon-enum-enum-conversion"
        -:   70:#endif
        -:   71:
        -:   72:namespace cv
        -:   73:{
        -:   74:CV__DEBUG_NS_BEGIN
        -:   75:
        -:   76:
        -:   77://! @cond IGNORED
        -:   78:
        -:   79:////////////////////////// Custom (raw) type wrapper //////////////////////////
        -:   80:
        -:   81:template<typename _Tp> static inline
        -:   82:int rawType()
        -:   83:{
        -:   84:    CV_StaticAssert(sizeof(_Tp) <= CV_CN_MAX, "sizeof(_Tp) is too large");
        -:   85:    const int elemSize = sizeof(_Tp);
        -:   86:    return (int)CV_MAKETYPE(CV_8U, elemSize);
        -:   87:}
        -:   88:
        -:   89://////////////////////// Input/Output Arrays ////////////////////////
        -:   90:
        -:   91:inline void _InputArray::init(int _flags, const void* _obj)
        -:   92:{ flags = _flags; obj = (void*)_obj; }
        -:   93:
        -:   94:inline void _InputArray::init(int _flags, const void* _obj, Size _sz)
        -:   95:{ flags = _flags; obj = (void*)_obj; sz = _sz; }
        -:   96:
        -:   97:inline void* _InputArray::getObj() const { return obj; }
        -:   98:inline int _InputArray::getFlags() const { return flags; }
        -:   99:inline Size _InputArray::getSz() const { return sz; }
        -:  100:
        -:  101:inline _InputArray::_InputArray() { init(0 + NONE, 0); }
        -:  102:inline _InputArray::_InputArray(int _flags, void* _obj) { init(_flags, _obj); }
        -:  103:inline _InputArray::_InputArray(const Mat& m) { init(MAT+ACCESS_READ, &m); }
        -:  104:inline _InputArray::_InputArray(const std::vector<Mat>& vec) { init(STD_VECTOR_MAT+ACCESS_READ, &vec); }
        -:  105:inline _InputArray::_InputArray(const UMat& m) { init(UMAT+ACCESS_READ, &m); }
        -:  106:inline _InputArray::_InputArray(const std::vector<UMat>& vec) { init(STD_VECTOR_UMAT+ACCESS_READ, &vec); }
        -:  107:
        -:  108:template<typename _Tp> inline
        -:  109:_InputArray::_InputArray(const std::vector<_Tp>& vec)
        -:  110:{ init(FIXED_TYPE + STD_VECTOR + traits::Type<_Tp>::value + ACCESS_READ, &vec); }
        -:  111:
        -:  112:template<typename _Tp, std::size_t _Nm> inline
        -:  113:_InputArray::_InputArray(const std::array<_Tp, _Nm>& arr)
        -:  114:{ init(FIXED_TYPE + FIXED_SIZE + STD_ARRAY + traits::Type<_Tp>::value + ACCESS_READ, arr.data(), Size(1, _Nm)); }
        -:  115:
        -:  116:template<std::size_t _Nm> inline
        -:  117:_InputArray::_InputArray(const std::array<Mat, _Nm>& arr)
        -:  118:{ init(STD_ARRAY_MAT + ACCESS_READ, arr.data(), Size(1, _Nm)); }
        -:  119:
        -:  120:inline
        -:  121:_InputArray::_InputArray(const std::vector<bool>& vec)
        -:  122:{ init(FIXED_TYPE + STD_BOOL_VECTOR + traits::Type<bool>::value + ACCESS_READ, &vec); }
        -:  123:
        -:  124:template<typename _Tp> inline
        -:  125:_InputArray::_InputArray(const std::vector<std::vector<_Tp> >& vec)
        -:  126:{ init(FIXED_TYPE + STD_VECTOR_VECTOR + traits::Type<_Tp>::value + ACCESS_READ, &vec); }
        -:  127:
        -:  128:template<typename _Tp> inline
        -:  129:_InputArray::_InputArray(const std::vector<Mat_<_Tp> >& vec)
        -:  130:{ init(FIXED_TYPE + STD_VECTOR_MAT + traits::Type<_Tp>::value + ACCESS_READ, &vec); }
        -:  131:
        -:  132:template<typename _Tp, int m, int n> inline
        -:  133:_InputArray::_InputArray(const Matx<_Tp, m, n>& mtx)
        -:  134:{ init(FIXED_TYPE + FIXED_SIZE + MATX + traits::Type<_Tp>::value + ACCESS_READ, &mtx, Size(n, m)); }
        -:  135:
        -:  136:template<typename _Tp> inline
        -:  137:_InputArray::_InputArray(const _Tp* vec, int n)
        -:  138:{ init(FIXED_TYPE + FIXED_SIZE + MATX + traits::Type<_Tp>::value + ACCESS_READ, vec, Size(n, 1)); }
        -:  139:
        -:  140:template<typename _Tp> inline
        -:  141:_InputArray::_InputArray(const Mat_<_Tp>& m)
        -:  142:{ init(FIXED_TYPE + MAT + traits::Type<_Tp>::value + ACCESS_READ, &m); }
        -:  143:
        -:  144:inline _InputArray::_InputArray(const double& val)
        -:  145:{ init(FIXED_TYPE + FIXED_SIZE + MATX + CV_64F + ACCESS_READ, &val, Size(1,1)); }
        -:  146:
        -:  147:inline _InputArray::_InputArray(const MatExpr& expr)
        -:  148:{ init(FIXED_TYPE + FIXED_SIZE + EXPR + ACCESS_READ, &expr); }
        -:  149:
        -:  150:inline _InputArray::_InputArray(const cuda::GpuMat& d_mat)
        -:  151:{ init(CUDA_GPU_MAT + ACCESS_READ, &d_mat); }
        -:  152:
        -:  153:inline _InputArray::_InputArray(const std::vector<cuda::GpuMat>& d_mat)
        -:  154:{	init(STD_VECTOR_CUDA_GPU_MAT + ACCESS_READ, &d_mat);}
        -:  155:
        -:  156:inline _InputArray::_InputArray(const ogl::Buffer& buf)
        -:  157:{ init(OPENGL_BUFFER + ACCESS_READ, &buf); }
        -:  158:
        -:  159:inline _InputArray::_InputArray(const cuda::HostMem& cuda_mem)
        -:  160:{ init(CUDA_HOST_MEM + ACCESS_READ, &cuda_mem); }
        -:  161:
        -:  162:template<typename _Tp> inline
        -:  163:_InputArray _InputArray::rawIn(const std::vector<_Tp>& vec)
        -:  164:{
        -:  165:    _InputArray v;
        -:  166:    v.flags = _InputArray::FIXED_TYPE + _InputArray::STD_VECTOR + rawType<_Tp>() + ACCESS_READ;
        -:  167:    v.obj = (void*)&vec;
        -:  168:    return v;
        -:  169:}
        -:  170:
        -:  171:template<typename _Tp, std::size_t _Nm> inline
        -:  172:_InputArray _InputArray::rawIn(const std::array<_Tp, _Nm>& arr)
        -:  173:{
        -:  174:    _InputArray v;
        -:  175:    v.flags = FIXED_TYPE + FIXED_SIZE + STD_ARRAY + traits::Type<_Tp>::value + ACCESS_READ;
        -:  176:    v.obj = (void*)arr.data();
        -:  177:    v.sz = Size(1, _Nm);
        -:  178:    return v;
        -:  179:}
        -:  180:
        -:  181:inline _InputArray::~_InputArray() {}
        -:  182:
        -:  183:inline Mat _InputArray::getMat(int i) const
        -:  184:{
        -:  185:    if( kind() == MAT && i < 0 )
        -:  186:        return *(const Mat*)obj;
        -:  187:    return getMat_(i);
        -:  188:}
        -:  189:
        -:  190:inline bool _InputArray::isMat() const { return kind() == _InputArray::MAT; }
        -:  191:inline bool _InputArray::isUMat() const  { return kind() == _InputArray::UMAT; }
        -:  192:inline bool _InputArray::isMatVector() const { return kind() == _InputArray::STD_VECTOR_MAT; }
        -:  193:inline bool _InputArray::isUMatVector() const  { return kind() == _InputArray::STD_VECTOR_UMAT; }
        -:  194:inline bool _InputArray::isMatx() const { return kind() == _InputArray::MATX; }
        -:  195:inline bool _InputArray::isVector() const { return kind() == _InputArray::STD_VECTOR ||
        -:  196:                                                   kind() == _InputArray::STD_BOOL_VECTOR ||
        -:  197:                                                   kind() == _InputArray::STD_ARRAY; }
        -:  198:inline bool _InputArray::isGpuMat() const { return kind() == _InputArray::CUDA_GPU_MAT; }
        -:  199:inline bool _InputArray::isGpuMatVector() const { return kind() == _InputArray::STD_VECTOR_CUDA_GPU_MAT; }
        -:  200:
        -:  201:////////////////////////////////////////////////////////////////////////////////////////
        -:  202:
        -:  203:inline _OutputArray::_OutputArray() { init(NONE + ACCESS_WRITE, 0); }
        -:  204:inline _OutputArray::_OutputArray(int _flags, void* _obj) { init(_flags + ACCESS_WRITE, _obj); }
        -:  205:inline _OutputArray::_OutputArray(Mat& m) { init(MAT+ACCESS_WRITE, &m); }
        -:  206:inline _OutputArray::_OutputArray(std::vector<Mat>& vec) { init(STD_VECTOR_MAT + ACCESS_WRITE, &vec); }
        -:  207:inline _OutputArray::_OutputArray(UMat& m) { init(UMAT + ACCESS_WRITE, &m); }
        -:  208:inline _OutputArray::_OutputArray(std::vector<UMat>& vec) { init(STD_VECTOR_UMAT + ACCESS_WRITE, &vec); }
        -:  209:
        -:  210:template<typename _Tp> inline
        -:  211:_OutputArray::_OutputArray(std::vector<_Tp>& vec)
        -:  212:{ init(FIXED_TYPE + STD_VECTOR + traits::Type<_Tp>::value + ACCESS_WRITE, &vec); }
        -:  213:
        -:  214:template<typename _Tp, std::size_t _Nm> inline
        -:  215:_OutputArray::_OutputArray(std::array<_Tp, _Nm>& arr)
        -:  216:{ init(FIXED_TYPE + FIXED_SIZE + STD_ARRAY + traits::Type<_Tp>::value + ACCESS_WRITE, arr.data(), Size(1, _Nm)); }
        -:  217:
        -:  218:template<std::size_t _Nm> inline
        -:  219:_OutputArray::_OutputArray(std::array<Mat, _Nm>& arr)
        -:  220:{ init(STD_ARRAY_MAT + ACCESS_WRITE, arr.data(), Size(1, _Nm)); }
        -:  221:
        -:  222:template<typename _Tp> inline
        -:  223:_OutputArray::_OutputArray(std::vector<std::vector<_Tp> >& vec)
        -:  224:{ init(FIXED_TYPE + STD_VECTOR_VECTOR + traits::Type<_Tp>::value + ACCESS_WRITE, &vec); }
        -:  225:
        -:  226:template<typename _Tp> inline
        -:  227:_OutputArray::_OutputArray(std::vector<Mat_<_Tp> >& vec)
        -:  228:{ init(FIXED_TYPE + STD_VECTOR_MAT + traits::Type<_Tp>::value + ACCESS_WRITE, &vec); }
        -:  229:
        -:  230:template<typename _Tp> inline
        -:  231:_OutputArray::_OutputArray(Mat_<_Tp>& m)
        -:  232:{ init(FIXED_TYPE + MAT + traits::Type<_Tp>::value + ACCESS_WRITE, &m); }
        -:  233:
        -:  234:template<typename _Tp, int m, int n> inline
        -:  235:_OutputArray::_OutputArray(Matx<_Tp, m, n>& mtx)
        -:  236:{ init(FIXED_TYPE + FIXED_SIZE + MATX + traits::Type<_Tp>::value + ACCESS_WRITE, &mtx, Size(n, m)); }
        -:  237:
        -:  238:template<typename _Tp> inline
        -:  239:_OutputArray::_OutputArray(_Tp* vec, int n)
        -:  240:{ init(FIXED_TYPE + FIXED_SIZE + MATX + traits::Type<_Tp>::value + ACCESS_WRITE, vec, Size(n, 1)); }
        -:  241:
        -:  242:template<typename _Tp> inline
        -:  243:_OutputArray::_OutputArray(const std::vector<_Tp>& vec)
        -:  244:{ init(FIXED_TYPE + FIXED_SIZE + STD_VECTOR + traits::Type<_Tp>::value + ACCESS_WRITE, &vec); }
        -:  245:
        -:  246:template<typename _Tp, std::size_t _Nm> inline
        -:  247:_OutputArray::_OutputArray(const std::array<_Tp, _Nm>& arr)
        -:  248:{ init(FIXED_TYPE + FIXED_SIZE + STD_ARRAY + traits::Type<_Tp>::value + ACCESS_WRITE, arr.data(), Size(1, _Nm)); }
        -:  249:
        -:  250:template<std::size_t _Nm> inline
        -:  251:_OutputArray::_OutputArray(const std::array<Mat, _Nm>& arr)
        -:  252:{ init(FIXED_SIZE + STD_ARRAY_MAT + ACCESS_WRITE, arr.data(), Size(1, _Nm)); }
        -:  253:
        -:  254:template<typename _Tp> inline
        -:  255:_OutputArray::_OutputArray(const std::vector<std::vector<_Tp> >& vec)
        -:  256:{ init(FIXED_TYPE + FIXED_SIZE + STD_VECTOR_VECTOR + traits::Type<_Tp>::value + ACCESS_WRITE, &vec); }
        -:  257:
        -:  258:template<typename _Tp> inline
        -:  259:_OutputArray::_OutputArray(const std::vector<Mat_<_Tp> >& vec)
        -:  260:{ init(FIXED_TYPE + FIXED_SIZE + STD_VECTOR_MAT + traits::Type<_Tp>::value + ACCESS_WRITE, &vec); }
        -:  261:
        -:  262:template<typename _Tp> inline
        -:  263:_OutputArray::_OutputArray(const Mat_<_Tp>& m)
        -:  264:{ init(FIXED_TYPE + FIXED_SIZE + MAT + traits::Type<_Tp>::value + ACCESS_WRITE, &m); }
        -:  265:
        -:  266:template<typename _Tp, int m, int n> inline
        -:  267:_OutputArray::_OutputArray(const Matx<_Tp, m, n>& mtx)
        -:  268:{ init(FIXED_TYPE + FIXED_SIZE + MATX + traits::Type<_Tp>::value + ACCESS_WRITE, &mtx, Size(n, m)); }
        -:  269:
        -:  270:template<typename _Tp> inline
        -:  271:_OutputArray::_OutputArray(const _Tp* vec, int n)
        -:  272:{ init(FIXED_TYPE + FIXED_SIZE + MATX + traits::Type<_Tp>::value + ACCESS_WRITE, vec, Size(n, 1)); }
        -:  273:
        -:  274:inline _OutputArray::_OutputArray(cuda::GpuMat& d_mat)
        -:  275:{ init(CUDA_GPU_MAT + ACCESS_WRITE, &d_mat); }
        -:  276:
        -:  277:inline _OutputArray::_OutputArray(std::vector<cuda::GpuMat>& d_mat)
        -:  278:{	init(STD_VECTOR_CUDA_GPU_MAT + ACCESS_WRITE, &d_mat);}
        -:  279:
        -:  280:inline _OutputArray::_OutputArray(ogl::Buffer& buf)
        -:  281:{ init(OPENGL_BUFFER + ACCESS_WRITE, &buf); }
        -:  282:
        -:  283:inline _OutputArray::_OutputArray(cuda::HostMem& cuda_mem)
        -:  284:{ init(CUDA_HOST_MEM + ACCESS_WRITE, &cuda_mem); }
        -:  285:
        -:  286:inline _OutputArray::_OutputArray(const Mat& m)
        -:  287:{ init(FIXED_TYPE + FIXED_SIZE + MAT + ACCESS_WRITE, &m); }
        -:  288:
        -:  289:inline _OutputArray::_OutputArray(const std::vector<Mat>& vec)
        -:  290:{ init(FIXED_SIZE + STD_VECTOR_MAT + ACCESS_WRITE, &vec); }
        -:  291:
        -:  292:inline _OutputArray::_OutputArray(const UMat& m)
        -:  293:{ init(FIXED_TYPE + FIXED_SIZE + UMAT + ACCESS_WRITE, &m); }
        -:  294:
        -:  295:inline _OutputArray::_OutputArray(const std::vector<UMat>& vec)
        -:  296:{ init(FIXED_SIZE + STD_VECTOR_UMAT + ACCESS_WRITE, &vec); }
        -:  297:
        -:  298:inline _OutputArray::_OutputArray(const cuda::GpuMat& d_mat)
        -:  299:{ init(FIXED_TYPE + FIXED_SIZE + CUDA_GPU_MAT + ACCESS_WRITE, &d_mat); }
        -:  300:
        -:  301:
        -:  302:inline _OutputArray::_OutputArray(const ogl::Buffer& buf)
        -:  303:{ init(FIXED_TYPE + FIXED_SIZE + OPENGL_BUFFER + ACCESS_WRITE, &buf); }
        -:  304:
        -:  305:inline _OutputArray::_OutputArray(const cuda::HostMem& cuda_mem)
        -:  306:{ init(FIXED_TYPE + FIXED_SIZE + CUDA_HOST_MEM + ACCESS_WRITE, &cuda_mem); }
        -:  307:
        -:  308:template<typename _Tp> inline
        -:  309:_OutputArray _OutputArray::rawOut(std::vector<_Tp>& vec)
        -:  310:{
        -:  311:    _OutputArray v;
        -:  312:    v.flags = _InputArray::FIXED_TYPE + _InputArray::STD_VECTOR + rawType<_Tp>() + ACCESS_WRITE;
        -:  313:    v.obj = (void*)&vec;
        -:  314:    return v;
        -:  315:}
        -:  316:
        -:  317:template<typename _Tp, std::size_t _Nm> inline
        -:  318:_OutputArray _OutputArray::rawOut(std::array<_Tp, _Nm>& arr)
        -:  319:{
        -:  320:    _OutputArray v;
        -:  321:    v.flags = FIXED_TYPE + FIXED_SIZE + STD_ARRAY + traits::Type<_Tp>::value + ACCESS_WRITE;
        -:  322:    v.obj = (void*)arr.data();
        -:  323:    v.sz = Size(1, _Nm);
        -:  324:    return v;
        -:  325:}
        -:  326:
        -:  327:///////////////////////////////////////////////////////////////////////////////////////////
        -:  328:
        -:  329:inline _InputOutputArray::_InputOutputArray() { init(0+ACCESS_RW, 0); }
        -:  330:inline _InputOutputArray::_InputOutputArray(int _flags, void* _obj) { init(_flags+ACCESS_RW, _obj); }
        -:  331:inline _InputOutputArray::_InputOutputArray(Mat& m) { init(MAT+ACCESS_RW, &m); }
        -:  332:inline _InputOutputArray::_InputOutputArray(std::vector<Mat>& vec) { init(STD_VECTOR_MAT+ACCESS_RW, &vec); }
        -:  333:inline _InputOutputArray::_InputOutputArray(UMat& m) { init(UMAT+ACCESS_RW, &m); }
        -:  334:inline _InputOutputArray::_InputOutputArray(std::vector<UMat>& vec) { init(STD_VECTOR_UMAT+ACCESS_RW, &vec); }
        -:  335:
        -:  336:template<typename _Tp> inline
        -:  337:_InputOutputArray::_InputOutputArray(std::vector<_Tp>& vec)
        -:  338:{ init(FIXED_TYPE + STD_VECTOR + traits::Type<_Tp>::value + ACCESS_RW, &vec); }
        -:  339:
        -:  340:template<typename _Tp, std::size_t _Nm> inline
        -:  341:_InputOutputArray::_InputOutputArray(std::array<_Tp, _Nm>& arr)
        -:  342:{ init(FIXED_TYPE + FIXED_SIZE + STD_ARRAY + traits::Type<_Tp>::value + ACCESS_RW, arr.data(), Size(1, _Nm)); }
        -:  343:
        -:  344:template<std::size_t _Nm> inline
        -:  345:_InputOutputArray::_InputOutputArray(std::array<Mat, _Nm>& arr)
        -:  346:{ init(STD_ARRAY_MAT + ACCESS_RW, arr.data(), Size(1, _Nm)); }
        -:  347:
        -:  348:template<typename _Tp> inline
        -:  349:_InputOutputArray::_InputOutputArray(std::vector<std::vector<_Tp> >& vec)
        -:  350:{ init(FIXED_TYPE + STD_VECTOR_VECTOR + traits::Type<_Tp>::value + ACCESS_RW, &vec); }
        -:  351:
        -:  352:template<typename _Tp> inline
        -:  353:_InputOutputArray::_InputOutputArray(std::vector<Mat_<_Tp> >& vec)
        -:  354:{ init(FIXED_TYPE + STD_VECTOR_MAT + traits::Type<_Tp>::value + ACCESS_RW, &vec); }
        -:  355:
        -:  356:template<typename _Tp> inline
        -:  357:_InputOutputArray::_InputOutputArray(Mat_<_Tp>& m)
        -:  358:{ init(FIXED_TYPE + MAT + traits::Type<_Tp>::value + ACCESS_RW, &m); }
        -:  359:
        -:  360:template<typename _Tp, int m, int n> inline
        -:  361:_InputOutputArray::_InputOutputArray(Matx<_Tp, m, n>& mtx)
        -:  362:{ init(FIXED_TYPE + FIXED_SIZE + MATX + traits::Type<_Tp>::value + ACCESS_RW, &mtx, Size(n, m)); }
        -:  363:
        -:  364:template<typename _Tp> inline
        -:  365:_InputOutputArray::_InputOutputArray(_Tp* vec, int n)
        -:  366:{ init(FIXED_TYPE + FIXED_SIZE + MATX + traits::Type<_Tp>::value + ACCESS_RW, vec, Size(n, 1)); }
        -:  367:
        -:  368:template<typename _Tp> inline
        -:  369:_InputOutputArray::_InputOutputArray(const std::vector<_Tp>& vec)
        -:  370:{ init(FIXED_TYPE + FIXED_SIZE + STD_VECTOR + traits::Type<_Tp>::value + ACCESS_RW, &vec); }
        -:  371:
        -:  372:template<typename _Tp, std::size_t _Nm> inline
        -:  373:_InputOutputArray::_InputOutputArray(const std::array<_Tp, _Nm>& arr)
        -:  374:{ init(FIXED_TYPE + FIXED_SIZE + STD_ARRAY + traits::Type<_Tp>::value + ACCESS_RW, arr.data(), Size(1, _Nm)); }
        -:  375:
        -:  376:template<std::size_t _Nm> inline
        -:  377:_InputOutputArray::_InputOutputArray(const std::array<Mat, _Nm>& arr)
        -:  378:{ init(FIXED_SIZE + STD_ARRAY_MAT + ACCESS_RW, arr.data(), Size(1, _Nm)); }
        -:  379:
        -:  380:template<typename _Tp> inline
        -:  381:_InputOutputArray::_InputOutputArray(const std::vector<std::vector<_Tp> >& vec)
        -:  382:{ init(FIXED_TYPE + FIXED_SIZE + STD_VECTOR_VECTOR + traits::Type<_Tp>::value + ACCESS_RW, &vec); }
        -:  383:
        -:  384:template<typename _Tp> inline
        -:  385:_InputOutputArray::_InputOutputArray(const std::vector<Mat_<_Tp> >& vec)
        -:  386:{ init(FIXED_TYPE + FIXED_SIZE + STD_VECTOR_MAT + traits::Type<_Tp>::value + ACCESS_RW, &vec); }
        -:  387:
        -:  388:template<typename _Tp> inline
        -:  389:_InputOutputArray::_InputOutputArray(const Mat_<_Tp>& m)
        -:  390:{ init(FIXED_TYPE + FIXED_SIZE + MAT + traits::Type<_Tp>::value + ACCESS_RW, &m); }
        -:  391:
        -:  392:template<typename _Tp, int m, int n> inline
        -:  393:_InputOutputArray::_InputOutputArray(const Matx<_Tp, m, n>& mtx)
        -:  394:{ init(FIXED_TYPE + FIXED_SIZE + MATX + traits::Type<_Tp>::value + ACCESS_RW, &mtx, Size(n, m)); }
        -:  395:
        -:  396:template<typename _Tp> inline
        -:  397:_InputOutputArray::_InputOutputArray(const _Tp* vec, int n)
        -:  398:{ init(FIXED_TYPE + FIXED_SIZE + MATX + traits::Type<_Tp>::value + ACCESS_RW, vec, Size(n, 1)); }
        -:  399:
        -:  400:inline _InputOutputArray::_InputOutputArray(cuda::GpuMat& d_mat)
        -:  401:{ init(CUDA_GPU_MAT + ACCESS_RW, &d_mat); }
        -:  402:
        -:  403:inline _InputOutputArray::_InputOutputArray(ogl::Buffer& buf)
        -:  404:{ init(OPENGL_BUFFER + ACCESS_RW, &buf); }
        -:  405:
        -:  406:inline _InputOutputArray::_InputOutputArray(cuda::HostMem& cuda_mem)
        -:  407:{ init(CUDA_HOST_MEM + ACCESS_RW, &cuda_mem); }
        -:  408:
        -:  409:inline _InputOutputArray::_InputOutputArray(const Mat& m)
        -:  410:{ init(FIXED_TYPE + FIXED_SIZE + MAT + ACCESS_RW, &m); }
        -:  411:
        -:  412:inline _InputOutputArray::_InputOutputArray(const std::vector<Mat>& vec)
        -:  413:{ init(FIXED_SIZE + STD_VECTOR_MAT + ACCESS_RW, &vec); }
        -:  414:
        -:  415:inline _InputOutputArray::_InputOutputArray(const UMat& m)
        -:  416:{ init(FIXED_TYPE + FIXED_SIZE + UMAT + ACCESS_RW, &m); }
        -:  417:
        -:  418:inline _InputOutputArray::_InputOutputArray(const std::vector<UMat>& vec)
        -:  419:{ init(FIXED_SIZE + STD_VECTOR_UMAT + ACCESS_RW, &vec); }
        -:  420:
        -:  421:inline _InputOutputArray::_InputOutputArray(const cuda::GpuMat& d_mat)
        -:  422:{ init(FIXED_TYPE + FIXED_SIZE + CUDA_GPU_MAT + ACCESS_RW, &d_mat); }
        -:  423:
        -:  424:inline _InputOutputArray::_InputOutputArray(const std::vector<cuda::GpuMat>& d_mat)
        -:  425:{ init(FIXED_TYPE + FIXED_SIZE + STD_VECTOR_CUDA_GPU_MAT + ACCESS_RW, &d_mat);}
        -:  426:
        -:  427:template<> inline _InputOutputArray::_InputOutputArray(std::vector<cuda::GpuMat>& d_mat)
        -:  428:{ init(FIXED_TYPE + FIXED_SIZE + STD_VECTOR_CUDA_GPU_MAT + ACCESS_RW, &d_mat);}
        -:  429:
        -:  430:inline _InputOutputArray::_InputOutputArray(const ogl::Buffer& buf)
        -:  431:{ init(FIXED_TYPE + FIXED_SIZE + OPENGL_BUFFER + ACCESS_RW, &buf); }
        -:  432:
        -:  433:inline _InputOutputArray::_InputOutputArray(const cuda::HostMem& cuda_mem)
        -:  434:{ init(FIXED_TYPE + FIXED_SIZE + CUDA_HOST_MEM + ACCESS_RW, &cuda_mem); }
        -:  435:
        -:  436:template<typename _Tp> inline
        -:  437:_InputOutputArray _InputOutputArray::rawInOut(std::vector<_Tp>& vec)
        -:  438:{
        -:  439:    _InputOutputArray v;
        -:  440:    v.flags = _InputArray::FIXED_TYPE + _InputArray::STD_VECTOR + rawType<_Tp>() + ACCESS_RW;
        -:  441:    v.obj = (void*)&vec;
        -:  442:    return v;
        -:  443:}
        -:  444:
        -:  445:template<typename _Tp, std::size_t _Nm> inline
        -:  446:_InputOutputArray _InputOutputArray::rawInOut(std::array<_Tp, _Nm>& arr)
        -:  447:{
        -:  448:    _InputOutputArray v;
        -:  449:    v.flags = FIXED_TYPE + FIXED_SIZE + STD_ARRAY + traits::Type<_Tp>::value + ACCESS_RW;
        -:  450:    v.obj = (void*)arr.data();
        -:  451:    v.sz = Size(1, _Nm);
        -:  452:    return v;
        -:  453:}
        -:  454:
        -:  455:
        -:  456:template<typename _Tp> static inline _InputArray rawIn(_Tp& v) { return _InputArray::rawIn(v); }
        -:  457:template<typename _Tp> static inline _OutputArray rawOut(_Tp& v) { return _OutputArray::rawOut(v); }
        -:  458:template<typename _Tp> static inline _InputOutputArray rawInOut(_Tp& v) { return _InputOutputArray::rawInOut(v); }
        -:  459:
        -:  460:CV__DEBUG_NS_END
        -:  461:
        -:  462://////////////////////////////////////////// Mat //////////////////////////////////////////
        -:  463:
        -:  464:inline
        2:  465:Mat::Mat()
        1:  465-block  0
        1:  465-block  1
        1:  466:    : flags(MAGIC_VAL), dims(0), rows(0), cols(0), data(0), datastart(0), dataend(0),
        1:  467:      datalimit(0), allocator(0), u(0), size(&rows), step(0)
        2:  468:{}
        1:  468-block  0
        1:  468-block  1
        -:  469:
        -:  470:inline
        -:  471:Mat::Mat(int _rows, int _cols, int _type)
        -:  472:    : flags(MAGIC_VAL), dims(0), rows(0), cols(0), data(0), datastart(0), dataend(0),
        -:  473:      datalimit(0), allocator(0), u(0), size(&rows), step(0)
        -:  474:{
        -:  475:    create(_rows, _cols, _type);
        -:  476:}
        -:  477:
        -:  478:inline
        -:  479:Mat::Mat(int _rows, int _cols, int _type, const Scalar& _s)
        -:  480:    : flags(MAGIC_VAL), dims(0), rows(0), cols(0), data(0), datastart(0), dataend(0),
        -:  481:      datalimit(0), allocator(0), u(0), size(&rows), step(0)
        -:  482:{
        -:  483:    create(_rows, _cols, _type);
        -:  484:    *this = _s;
        -:  485:}
        -:  486:
        -:  487:inline
        -:  488:Mat::Mat(Size _sz, int _type)
        -:  489:    : flags(MAGIC_VAL), dims(0), rows(0), cols(0), data(0), datastart(0), dataend(0),
        -:  490:      datalimit(0), allocator(0), u(0), size(&rows), step(0)
        -:  491:{
        -:  492:    create( _sz.height, _sz.width, _type );
        -:  493:}
        -:  494:
        -:  495:inline
        -:  496:Mat::Mat(Size _sz, int _type, const Scalar& _s)
        -:  497:    : flags(MAGIC_VAL), dims(0), rows(0), cols(0), data(0), datastart(0), dataend(0),
        -:  498:      datalimit(0), allocator(0), u(0), size(&rows), step(0)
        -:  499:{
        -:  500:    create(_sz.height, _sz.width, _type);
        -:  501:    *this = _s;
        -:  502:}
        -:  503:
        -:  504:inline
        -:  505:Mat::Mat(int _dims, const int* _sz, int _type)
        -:  506:    : flags(MAGIC_VAL), dims(0), rows(0), cols(0), data(0), datastart(0), dataend(0),
        -:  507:      datalimit(0), allocator(0), u(0), size(&rows), step(0)
        -:  508:{
        -:  509:    create(_dims, _sz, _type);
        -:  510:}
        -:  511:
        -:  512:inline
        -:  513:Mat::Mat(int _dims, const int* _sz, int _type, const Scalar& _s)
        -:  514:    : flags(MAGIC_VAL), dims(0), rows(0), cols(0), data(0), datastart(0), dataend(0),
        -:  515:      datalimit(0), allocator(0), u(0), size(&rows), step(0)
        -:  516:{
        -:  517:    create(_dims, _sz, _type);
        -:  518:    *this = _s;
        -:  519:}
        -:  520:
        -:  521:inline
        -:  522:Mat::Mat(const std::vector<int>& _sz, int _type)
        -:  523:    : flags(MAGIC_VAL), dims(0), rows(0), cols(0), data(0), datastart(0), dataend(0),
        -:  524:      datalimit(0), allocator(0), u(0), size(&rows), step(0)
        -:  525:{
        -:  526:    create(_sz, _type);
        -:  527:}
        -:  528:
        -:  529:inline
        -:  530:Mat::Mat(const std::vector<int>& _sz, int _type, const Scalar& _s)
        -:  531:    : flags(MAGIC_VAL), dims(0), rows(0), cols(0), data(0), datastart(0), dataend(0),
        -:  532:      datalimit(0), allocator(0), u(0), size(&rows), step(0)
        -:  533:{
        -:  534:    create(_sz, _type);
        -:  535:    *this = _s;
        -:  536:}
        -:  537:
        -:  538:inline
        -:  539:Mat::Mat(const Mat& m)
        -:  540:    : flags(m.flags), dims(m.dims), rows(m.rows), cols(m.cols), data(m.data),
        -:  541:      datastart(m.datastart), dataend(m.dataend), datalimit(m.datalimit), allocator(m.allocator),
        -:  542:      u(m.u), size(&rows), step(0)
        -:  543:{
        -:  544:    if( u )
        -:  545:        CV_XADD(&u->refcount, 1);
        -:  546:    if( m.dims <= 2 )
        -:  547:    {
        -:  548:        step[0] = m.step[0]; step[1] = m.step[1];
        -:  549:    }
        -:  550:    else
        -:  551:    {
        -:  552:        dims = 0;
        -:  553:        copySize(m);
        -:  554:    }
        -:  555:}
        -:  556:
        -:  557:inline
        -:  558:Mat::Mat(int _rows, int _cols, int _type, void* _data, size_t _step)
        -:  559:    : flags(MAGIC_VAL + (_type & TYPE_MASK)), dims(2), rows(_rows), cols(_cols),
        -:  560:      data((uchar*)_data), datastart((uchar*)_data), dataend(0), datalimit(0),
        -:  561:      allocator(0), u(0), size(&rows)
        -:  562:{
        -:  563:    CV_Assert(total() == 0 || data != NULL);
        -:  564:
        -:  565:    size_t esz = CV_ELEM_SIZE(_type), esz1 = CV_ELEM_SIZE1(_type);
        -:  566:    size_t minstep = cols * esz;
        -:  567:    if( _step == AUTO_STEP )
        -:  568:    {
        -:  569:        _step = minstep;
        -:  570:    }
        -:  571:    else
        -:  572:    {
        -:  573:        CV_DbgAssert( _step >= minstep );
        -:  574:        if (_step % esz1 != 0)
        -:  575:        {
        -:  576:            CV_Error(Error::BadStep, "Step must be a multiple of esz1");
        -:  577:        }
        -:  578:    }
        -:  579:    step[0] = _step;
        -:  580:    step[1] = esz;
        -:  581:    datalimit = datastart + _step * rows;
        -:  582:    dataend = datalimit - _step + minstep;
        -:  583:    updateContinuityFlag();
        -:  584:}
        -:  585:
        -:  586:inline
        -:  587:Mat::Mat(Size _sz, int _type, void* _data, size_t _step)
        -:  588:    : flags(MAGIC_VAL + (_type & TYPE_MASK)), dims(2), rows(_sz.height), cols(_sz.width),
        -:  589:      data((uchar*)_data), datastart((uchar*)_data), dataend(0), datalimit(0),
        -:  590:      allocator(0), u(0), size(&rows)
        -:  591:{
        -:  592:    CV_Assert(total() == 0 || data != NULL);
        -:  593:
        -:  594:    size_t esz = CV_ELEM_SIZE(_type), esz1 = CV_ELEM_SIZE1(_type);
        -:  595:    size_t minstep = cols*esz;
        -:  596:    if( _step == AUTO_STEP )
        -:  597:    {
        -:  598:        _step = minstep;
        -:  599:    }
        -:  600:    else
        -:  601:    {
        -:  602:        CV_DbgAssert( _step >= minstep );
        -:  603:
        -:  604:        if (_step % esz1 != 0)
        -:  605:        {
        -:  606:            CV_Error(Error::BadStep, "Step must be a multiple of esz1");
        -:  607:        }
        -:  608:    }
        -:  609:    step[0] = _step;
        -:  610:    step[1] = esz;
        -:  611:    datalimit = datastart + _step*rows;
        -:  612:    dataend = datalimit - _step + minstep;
        -:  613:    updateContinuityFlag();
        -:  614:}
        -:  615:
        -:  616:template<typename _Tp> inline
        -:  617:Mat::Mat(const std::vector<_Tp>& vec, bool copyData)
        -:  618:    : flags(MAGIC_VAL + traits::Type<_Tp>::value + CV_MAT_CONT_FLAG), dims(2), rows((int)vec.size()),
        -:  619:      cols(1), data(0), datastart(0), dataend(0), datalimit(0), allocator(0), u(0), size(&rows), step(0)
        -:  620:{
        -:  621:    if(vec.empty())
        -:  622:        return;
        -:  623:    if( !copyData )
        -:  624:    {
        -:  625:        step[0] = step[1] = sizeof(_Tp);
        -:  626:        datastart = data = (uchar*)&vec[0];
        -:  627:        datalimit = dataend = datastart + rows * step[0];
        -:  628:    }
        -:  629:    else
        -:  630:        Mat((int)vec.size(), 1, traits::Type<_Tp>::value, (uchar*)&vec[0]).copyTo(*this);
        -:  631:}
        -:  632:
        -:  633:template<typename _Tp, typename> inline
        -:  634:Mat::Mat(const std::initializer_list<_Tp> list)
        -:  635:    : Mat()
        -:  636:{
        -:  637:    CV_Assert(list.size() != 0);
        -:  638:    Mat((int)list.size(), 1, traits::Type<_Tp>::value, (uchar*)list.begin()).copyTo(*this);
        -:  639:}
        -:  640:
        -:  641:template<typename _Tp> inline
        -:  642:Mat::Mat(const std::initializer_list<int> sizes, const std::initializer_list<_Tp> list)
        -:  643:    : Mat()
        -:  644:{
        -:  645:    size_t size_total = 1;
        -:  646:    for(auto s : sizes)
        -:  647:        size_total *= s;
        -:  648:    CV_Assert(list.size() != 0);
        -:  649:    CV_Assert(size_total == list.size());
        -:  650:    Mat((int)sizes.size(), (int*)sizes.begin(), traits::Type<_Tp>::value, (uchar*)list.begin()).copyTo(*this);
        -:  651:}
        -:  652:
        -:  653:template<typename _Tp, std::size_t _Nm> inline
        -:  654:Mat::Mat(const std::array<_Tp, _Nm>& arr, bool copyData)
        -:  655:    : flags(MAGIC_VAL + traits::Type<_Tp>::value + CV_MAT_CONT_FLAG), dims(2), rows((int)arr.size()),
        -:  656:      cols(1), data(0), datastart(0), dataend(0), datalimit(0), allocator(0), u(0), size(&rows), step(0)
        -:  657:{
        -:  658:    if(arr.empty())
        -:  659:        return;
        -:  660:    if( !copyData )
        -:  661:    {
        -:  662:        step[0] = step[1] = sizeof(_Tp);
        -:  663:        datastart = data = (uchar*)arr.data();
        -:  664:        datalimit = dataend = datastart + rows * step[0];
        -:  665:    }
        -:  666:    else
        -:  667:        Mat((int)arr.size(), 1, traits::Type<_Tp>::value, (uchar*)arr.data()).copyTo(*this);
        -:  668:}
        -:  669:
        -:  670:template<typename _Tp, int n> inline
        -:  671:Mat::Mat(const Vec<_Tp, n>& vec, bool copyData)
        -:  672:    : flags(MAGIC_VAL + traits::Type<_Tp>::value + CV_MAT_CONT_FLAG), dims(2), rows(n), cols(1), data(0),
        -:  673:      datastart(0), dataend(0), datalimit(0), allocator(0), u(0), size(&rows), step(0)
        -:  674:{
        -:  675:    if( !copyData )
        -:  676:    {
        -:  677:        step[0] = step[1] = sizeof(_Tp);
        -:  678:        datastart = data = (uchar*)vec.val;
        -:  679:        datalimit = dataend = datastart + rows * step[0];
        -:  680:    }
        -:  681:    else
        -:  682:        Mat(n, 1, traits::Type<_Tp>::value, (void*)vec.val).copyTo(*this);
        -:  683:}
        -:  684:
        -:  685:
        -:  686:template<typename _Tp, int m, int n> inline
        -:  687:Mat::Mat(const Matx<_Tp,m,n>& M, bool copyData)
        -:  688:    : flags(MAGIC_VAL + traits::Type<_Tp>::value + CV_MAT_CONT_FLAG), dims(2), rows(m), cols(n), data(0),
        -:  689:      datastart(0), dataend(0), datalimit(0), allocator(0), u(0), size(&rows), step(0)
        -:  690:{
        -:  691:    if( !copyData )
        -:  692:    {
        -:  693:        step[0] = cols * sizeof(_Tp);
        -:  694:        step[1] = sizeof(_Tp);
        -:  695:        datastart = data = (uchar*)M.val;
        -:  696:        datalimit = dataend = datastart + rows * step[0];
        -:  697:    }
        -:  698:    else
        -:  699:        Mat(m, n, traits::Type<_Tp>::value, (uchar*)M.val).copyTo(*this);
        -:  700:}
        -:  701:
        -:  702:template<typename _Tp> inline
        -:  703:Mat::Mat(const Point_<_Tp>& pt, bool copyData)
        -:  704:    : flags(MAGIC_VAL + traits::Type<_Tp>::value + CV_MAT_CONT_FLAG), dims(2), rows(2), cols(1), data(0),
        -:  705:      datastart(0), dataend(0), datalimit(0), allocator(0), u(0), size(&rows), step(0)
        -:  706:{
        -:  707:    if( !copyData )
        -:  708:    {
        -:  709:        step[0] = step[1] = sizeof(_Tp);
        -:  710:        datastart = data = (uchar*)&pt.x;
        -:  711:        datalimit = dataend = datastart + rows * step[0];
        -:  712:    }
        -:  713:    else
        -:  714:    {
        -:  715:        create(2, 1, traits::Type<_Tp>::value);
        -:  716:        ((_Tp*)data)[0] = pt.x;
        -:  717:        ((_Tp*)data)[1] = pt.y;
        -:  718:    }
        -:  719:}
        -:  720:
        -:  721:template<typename _Tp> inline
        -:  722:Mat::Mat(const Point3_<_Tp>& pt, bool copyData)
        -:  723:    : flags(MAGIC_VAL + traits::Type<_Tp>::value + CV_MAT_CONT_FLAG), dims(2), rows(3), cols(1), data(0),
        -:  724:      datastart(0), dataend(0), datalimit(0), allocator(0), u(0), size(&rows), step(0)
        -:  725:{
        -:  726:    if( !copyData )
        -:  727:    {
        -:  728:        step[0] = step[1] = sizeof(_Tp);
        -:  729:        datastart = data = (uchar*)&pt.x;
        -:  730:        datalimit = dataend = datastart + rows * step[0];
        -:  731:    }
        -:  732:    else
        -:  733:    {
        -:  734:        create(3, 1, traits::Type<_Tp>::value);
        -:  735:        ((_Tp*)data)[0] = pt.x;
        -:  736:        ((_Tp*)data)[1] = pt.y;
        -:  737:        ((_Tp*)data)[2] = pt.z;
        -:  738:    }
        -:  739:}
        -:  740:
        -:  741:template<typename _Tp> inline
        -:  742:Mat::Mat(const MatCommaInitializer_<_Tp>& commaInitializer)
        -:  743:    : flags(MAGIC_VAL + traits::Type<_Tp>::value + CV_MAT_CONT_FLAG), dims(0), rows(0), cols(0), data(0),
        -:  744:      datastart(0), dataend(0), allocator(0), u(0), size(&rows)
        -:  745:{
        -:  746:    *this = commaInitializer.operator Mat_<_Tp>();
        -:  747:}
        -:  748:
        -:  749:inline
        8:  750:Mat::~Mat()
        4:  750-block  0
        4:  750-block  1
        4:  751:{
        4:  752:    release();
        4:  752-block  0
    $$$$$:  752-block  1
        4:  753:    if( step.p != step.buf )
        4:  753-block  0
    #####:  754:        fastFree(step.p);
    $$$$$:  754-block  0
    $$$$$:  754-block  1
        8:  755:}
        4:  755-block  0
        4:  755-block  1
        -:  756:
        -:  757:inline
        -:  758:Mat& Mat::operator = (const Mat& m)
        -:  759:{
        -:  760:    if( this != &m )
        -:  761:    {
        -:  762:        if( m.u )
        -:  763:            CV_XADD(&m.u->refcount, 1);
        -:  764:        release();
        -:  765:        flags = m.flags;
        -:  766:        if( dims <= 2 && m.dims <= 2 )
        -:  767:        {
        -:  768:            dims = m.dims;
        -:  769:            rows = m.rows;
        -:  770:            cols = m.cols;
        -:  771:            step[0] = m.step[0];
        -:  772:            step[1] = m.step[1];
        -:  773:        }
        -:  774:        else
        -:  775:            copySize(m);
        -:  776:        data = m.data;
        -:  777:        datastart = m.datastart;
        -:  778:        dataend = m.dataend;
        -:  779:        datalimit = m.datalimit;
        -:  780:        allocator = m.allocator;
        -:  781:        u = m.u;
        -:  782:    }
        -:  783:    return *this;
        -:  784:}
        -:  785:
        -:  786:inline
        -:  787:Mat Mat::row(int y) const
        -:  788:{
        -:  789:    return Mat(*this, Range(y, y + 1), Range::all());
        -:  790:}
        -:  791:
        -:  792:inline
        -:  793:Mat Mat::col(int x) const
        -:  794:{
        -:  795:    return Mat(*this, Range::all(), Range(x, x + 1));
        -:  796:}
        -:  797:
        -:  798:inline
        -:  799:Mat Mat::rowRange(int startrow, int endrow) const
        -:  800:{
        -:  801:    return Mat(*this, Range(startrow, endrow), Range::all());
        -:  802:}
        -:  803:
        -:  804:inline
        -:  805:Mat Mat::rowRange(const Range& r) const
        -:  806:{
        -:  807:    return Mat(*this, r, Range::all());
        -:  808:}
        -:  809:
        -:  810:inline
        -:  811:Mat Mat::colRange(int startcol, int endcol) const
        -:  812:{
        -:  813:    return Mat(*this, Range::all(), Range(startcol, endcol));
        -:  814:}
        -:  815:
        -:  816:inline
        -:  817:Mat Mat::colRange(const Range& r) const
        -:  818:{
        -:  819:    return Mat(*this, Range::all(), r);
        -:  820:}
        -:  821:
        -:  822:inline
        -:  823:Mat Mat::clone() const
        -:  824:{
        -:  825:    Mat m;
        -:  826:    copyTo(m);
        -:  827:    return m;
        -:  828:}
        -:  829:
        -:  830:inline
        -:  831:void Mat::assignTo( Mat& m, int _type ) const
        -:  832:{
        -:  833:    if( _type < 0 )
        -:  834:        m = *this;
        -:  835:    else
        -:  836:        convertTo(m, _type);
        -:  837:}
        -:  838:
        -:  839:inline
        -:  840:void Mat::create(int _rows, int _cols, int _type)
        -:  841:{
        -:  842:    _type &= TYPE_MASK;
        -:  843:    if( dims <= 2 && rows == _rows && cols == _cols && type() == _type && data )
        -:  844:        return;
        -:  845:    int sz[] = {_rows, _cols};
        -:  846:    create(2, sz, _type);
        -:  847:}
        -:  848:
        -:  849:inline
        -:  850:void Mat::create(Size _sz, int _type)
        -:  851:{
        -:  852:    create(_sz.height, _sz.width, _type);
        -:  853:}
        -:  854:
        -:  855:inline
        -:  856:void Mat::addref()
        -:  857:{
        -:  858:    if( u )
        -:  859:        CV_XADD(&u->refcount, 1);
        -:  860:}
        -:  861:
        -:  862:inline
        4:  863:void Mat::release()
        4:  863-block  0
        -:  864:{
        4:  865:    if( u && CV_XADD(&u->refcount, -1) == 1 )
        4:  865-block  0
        1:  865-block  1
        1:  866:        deallocate();
        1:  866-block  0
        4:  867:    u = NULL;
        4:  868:    datastart = dataend = datalimit = data = 0;
        8:  869:    for(int i = 0; i < dims; i++)
        4:  869-block  0
        8:  869-block  1
        4:  869-block  2
        4:  870:        size.p[i] = 0;
        4:  870-block  0
        -:  871:#ifdef _DEBUG
        -:  872:    flags = MAGIC_VAL;
        -:  873:    dims = rows = cols = 0;
        -:  874:    if(step.p != step.buf)
        -:  875:    {
        -:  876:        fastFree(step.p);
        -:  877:        step.p = step.buf;
        -:  878:        size.p = &rows;
        -:  879:    }
        -:  880:#endif
        4:  881:}
        4:  881-block  0
        -:  882:
        -:  883:inline
        -:  884:Mat Mat::operator()( Range _rowRange, Range _colRange ) const
        -:  885:{
        -:  886:    return Mat(*this, _rowRange, _colRange);
        -:  887:}
        -:  888:
        -:  889:inline
        -:  890:Mat Mat::operator()( const Rect& roi ) const
        -:  891:{
        -:  892:    return Mat(*this, roi);
        -:  893:}
        -:  894:
        -:  895:inline
        -:  896:Mat Mat::operator()(const Range* ranges) const
        -:  897:{
        -:  898:    return Mat(*this, ranges);
        -:  899:}
        -:  900:
        -:  901:inline
        -:  902:Mat Mat::operator()(const std::vector<Range>& ranges) const
        -:  903:{
        -:  904:    return Mat(*this, ranges);
        -:  905:}
        -:  906:
        -:  907:inline
        -:  908:bool Mat::isContinuous() const
        -:  909:{
        -:  910:    return (flags & CONTINUOUS_FLAG) != 0;
        -:  911:}
        -:  912:
        -:  913:inline
        -:  914:bool Mat::isSubmatrix() const
        -:  915:{
        -:  916:    return (flags & SUBMATRIX_FLAG) != 0;
        -:  917:}
        -:  918:
        -:  919:inline
        -:  920:size_t Mat::elemSize() const
        -:  921:{
        -:  922:    size_t res = dims > 0 ? step.p[dims - 1] : 0;
        -:  923:    CV_DbgAssert(res != 0);
        -:  924:    return res;
        -:  925:}
        -:  926:
        -:  927:inline
        -:  928:size_t Mat::elemSize1() const
        -:  929:{
        -:  930:    return CV_ELEM_SIZE1(flags);
        -:  931:}
        -:  932:
        -:  933:inline
        -:  934:int Mat::type() const
        -:  935:{
        -:  936:    return CV_MAT_TYPE(flags);
        -:  937:}
        -:  938:
        -:  939:inline
        -:  940:int Mat::depth() const
        -:  941:{
        -:  942:    return CV_MAT_DEPTH(flags);
        -:  943:}
        -:  944:
        -:  945:inline
        -:  946:int Mat::channels() const
        -:  947:{
        -:  948:    return CV_MAT_CN(flags);
        -:  949:}
        -:  950:
        -:  951:inline
        -:  952:size_t Mat::step1(int i) const
        -:  953:{
        -:  954:    return step.p[i] / elemSize1();
        -:  955:}
        -:  956:
        -:  957:inline
        -:  958:bool Mat::empty() const
        -:  959:{
        -:  960:    return data == 0 || total() == 0 || dims == 0;
        -:  961:}
        -:  962:
        -:  963:inline
        -:  964:size_t Mat::total() const
        -:  965:{
        -:  966:    if( dims <= 2 )
        -:  967:        return (size_t)rows * cols;
        -:  968:    size_t p = 1;
        -:  969:    for( int i = 0; i < dims; i++ )
        -:  970:        p *= size[i];
        -:  971:    return p;
        -:  972:}
        -:  973:
        -:  974:inline
        -:  975:size_t Mat::total(int startDim, int endDim) const
        -:  976:{
        -:  977:    CV_Assert( 0 <= startDim && startDim <= endDim);
        -:  978:    size_t p = 1;
        -:  979:    int endDim_ = endDim <= dims ? endDim : dims;
        -:  980:    for( int i = startDim; i < endDim_; i++ )
        -:  981:        p *= size[i];
        -:  982:    return p;
        -:  983:}
        -:  984:
        -:  985:inline
        -:  986:uchar* Mat::ptr(int y)
        -:  987:{
        -:  988:    CV_DbgAssert( y == 0 || (data && dims >= 1 && (unsigned)y < (unsigned)size.p[0]) );
        -:  989:    return data + step.p[0] * y;
        -:  990:}
        -:  991:
        -:  992:inline
        -:  993:const uchar* Mat::ptr(int y) const
        -:  994:{
        -:  995:    CV_DbgAssert( y == 0 || (data && dims >= 1 && (unsigned)y < (unsigned)size.p[0]) );
        -:  996:    return data + step.p[0] * y;
        -:  997:}
        -:  998:
        -:  999:template<typename _Tp> inline
        -: 1000:_Tp* Mat::ptr(int y)
        -: 1001:{
        -: 1002:    CV_DbgAssert( y == 0 || (data && dims >= 1 && (unsigned)y < (unsigned)size.p[0]) );
        -: 1003:    return (_Tp*)(data + step.p[0] * y);
        -: 1004:}
        -: 1005:
        -: 1006:template<typename _Tp> inline
        -: 1007:const _Tp* Mat::ptr(int y) const
        -: 1008:{
        -: 1009:    CV_DbgAssert( y == 0 || (data && dims >= 1 && (unsigned)y < (unsigned)size.p[0]) );
        -: 1010:    return (const _Tp*)(data + step.p[0] * y);
        -: 1011:}
        -: 1012:
        -: 1013:inline
        -: 1014:uchar* Mat::ptr(int i0, int i1)
        -: 1015:{
        -: 1016:    CV_DbgAssert(dims >= 2);
        -: 1017:    CV_DbgAssert(data);
        -: 1018:    CV_DbgAssert((unsigned)i0 < (unsigned)size.p[0]);
        -: 1019:    CV_DbgAssert((unsigned)i1 < (unsigned)size.p[1]);
        -: 1020:    return data + i0 * step.p[0] + i1 * step.p[1];
        -: 1021:}
        -: 1022:
        -: 1023:inline
        -: 1024:const uchar* Mat::ptr(int i0, int i1) const
        -: 1025:{
        -: 1026:    CV_DbgAssert(dims >= 2);
        -: 1027:    CV_DbgAssert(data);
        -: 1028:    CV_DbgAssert((unsigned)i0 < (unsigned)size.p[0]);
        -: 1029:    CV_DbgAssert((unsigned)i1 < (unsigned)size.p[1]);
        -: 1030:    return data + i0 * step.p[0] + i1 * step.p[1];
        -: 1031:}
        -: 1032:
        -: 1033:template<typename _Tp> inline
        -: 1034:_Tp* Mat::ptr(int i0, int i1)
        -: 1035:{
        -: 1036:    CV_DbgAssert(dims >= 2);
        -: 1037:    CV_DbgAssert(data);
        -: 1038:    CV_DbgAssert((unsigned)i0 < (unsigned)size.p[0]);
        -: 1039:    CV_DbgAssert((unsigned)i1 < (unsigned)size.p[1]);
        -: 1040:    return (_Tp*)(data + i0 * step.p[0] + i1 * step.p[1]);
        -: 1041:}
        -: 1042:
        -: 1043:template<typename _Tp> inline
        -: 1044:const _Tp* Mat::ptr(int i0, int i1) const
        -: 1045:{
        -: 1046:    CV_DbgAssert(dims >= 2);
        -: 1047:    CV_DbgAssert(data);
        -: 1048:    CV_DbgAssert((unsigned)i0 < (unsigned)size.p[0]);
        -: 1049:    CV_DbgAssert((unsigned)i1 < (unsigned)size.p[1]);
        -: 1050:    return (const _Tp*)(data + i0 * step.p[0] + i1 * step.p[1]);
        -: 1051:}
        -: 1052:
        -: 1053:inline
        -: 1054:uchar* Mat::ptr(int i0, int i1, int i2)
        -: 1055:{
        -: 1056:    CV_DbgAssert(dims >= 3);
        -: 1057:    CV_DbgAssert(data);
        -: 1058:    CV_DbgAssert((unsigned)i0 < (unsigned)size.p[0]);
        -: 1059:    CV_DbgAssert((unsigned)i1 < (unsigned)size.p[1]);
        -: 1060:    CV_DbgAssert((unsigned)i2 < (unsigned)size.p[2]);
        -: 1061:    return data + i0 * step.p[0] + i1 * step.p[1] + i2 * step.p[2];
        -: 1062:}
        -: 1063:
        -: 1064:inline
        -: 1065:const uchar* Mat::ptr(int i0, int i1, int i2) const
        -: 1066:{
        -: 1067:    CV_DbgAssert(dims >= 3);
        -: 1068:    CV_DbgAssert(data);
        -: 1069:    CV_DbgAssert((unsigned)i0 < (unsigned)size.p[0]);
        -: 1070:    CV_DbgAssert((unsigned)i1 < (unsigned)size.p[1]);
        -: 1071:    CV_DbgAssert((unsigned)i2 < (unsigned)size.p[2]);
        -: 1072:    return data + i0 * step.p[0] + i1 * step.p[1] + i2 * step.p[2];
        -: 1073:}
        -: 1074:
        -: 1075:template<typename _Tp> inline
        -: 1076:_Tp* Mat::ptr(int i0, int i1, int i2)
        -: 1077:{
        -: 1078:    CV_DbgAssert(dims >= 3);
        -: 1079:    CV_DbgAssert(data);
        -: 1080:    CV_DbgAssert((unsigned)i0 < (unsigned)size.p[0]);
        -: 1081:    CV_DbgAssert((unsigned)i1 < (unsigned)size.p[1]);
        -: 1082:    CV_DbgAssert((unsigned)i2 < (unsigned)size.p[2]);
        -: 1083:    return (_Tp*)(data + i0 * step.p[0] + i1 * step.p[1] + i2 * step.p[2]);
        -: 1084:}
        -: 1085:
        -: 1086:template<typename _Tp> inline
        -: 1087:const _Tp* Mat::ptr(int i0, int i1, int i2) const
        -: 1088:{
        -: 1089:    CV_DbgAssert(dims >= 3);
        -: 1090:    CV_DbgAssert(data);
        -: 1091:    CV_DbgAssert((unsigned)i0 < (unsigned)size.p[0]);
        -: 1092:    CV_DbgAssert((unsigned)i1 < (unsigned)size.p[1]);
        -: 1093:    CV_DbgAssert((unsigned)i2 < (unsigned)size.p[2]);
        -: 1094:    return (const _Tp*)(data + i0 * step.p[0] + i1 * step.p[1] + i2 * step.p[2]);
        -: 1095:}
        -: 1096:
        -: 1097:inline
        -: 1098:uchar* Mat::ptr(const int* idx)
        -: 1099:{
        -: 1100:    int i, d = dims;
        -: 1101:    uchar* p = data;
        -: 1102:    CV_DbgAssert( d >= 1 && p );
        -: 1103:    for( i = 0; i < d; i++ )
        -: 1104:    {
        -: 1105:        CV_DbgAssert( (unsigned)idx[i] < (unsigned)size.p[i] );
        -: 1106:        p += idx[i] * step.p[i];
        -: 1107:    }
        -: 1108:    return p;
        -: 1109:}
        -: 1110:
        -: 1111:inline
        -: 1112:const uchar* Mat::ptr(const int* idx) const
        -: 1113:{
        -: 1114:    int i, d = dims;
        -: 1115:    uchar* p = data;
        -: 1116:    CV_DbgAssert( d >= 1 && p );
        -: 1117:    for( i = 0; i < d; i++ )
        -: 1118:    {
        -: 1119:        CV_DbgAssert( (unsigned)idx[i] < (unsigned)size.p[i] );
        -: 1120:        p += idx[i] * step.p[i];
        -: 1121:    }
        -: 1122:    return p;
        -: 1123:}
        -: 1124:
        -: 1125:template<typename _Tp> inline
        -: 1126:_Tp* Mat::ptr(const int* idx)
        -: 1127:{
        -: 1128:    int i, d = dims;
        -: 1129:    uchar* p = data;
        -: 1130:    CV_DbgAssert( d >= 1 && p );
        -: 1131:    for( i = 0; i < d; i++ )
        -: 1132:    {
        -: 1133:        CV_DbgAssert( (unsigned)idx[i] < (unsigned)size.p[i] );
        -: 1134:        p += idx[i] * step.p[i];
        -: 1135:    }
        -: 1136:    return (_Tp*)p;
        -: 1137:}
        -: 1138:
        -: 1139:template<typename _Tp> inline
        -: 1140:const _Tp* Mat::ptr(const int* idx) const
        -: 1141:{
        -: 1142:    int i, d = dims;
        -: 1143:    uchar* p = data;
        -: 1144:    CV_DbgAssert( d >= 1 && p );
        -: 1145:    for( i = 0; i < d; i++ )
        -: 1146:    {
        -: 1147:        CV_DbgAssert( (unsigned)idx[i] < (unsigned)size.p[i] );
        -: 1148:        p += idx[i] * step.p[i];
        -: 1149:    }
        -: 1150:    return (const _Tp*)p;
        -: 1151:}
        -: 1152:
        -: 1153:template<typename _Tp> inline
       18: 1154:_Tp& Mat::at(int i0, int i1)
       18: 1154-block  0
        -: 1155:{
        -: 1156:    CV_DbgAssert(dims <= 2);
        -: 1157:    CV_DbgAssert(data);
        -: 1158:    CV_DbgAssert((unsigned)i0 < (unsigned)size.p[0]);
        -: 1159:    CV_DbgAssert((unsigned)(i1 * DataType<_Tp>::channels) < (unsigned)(size.p[1] * channels()));
        -: 1160:    CV_DbgAssert(CV_ELEM_SIZE1(traits::Depth<_Tp>::value) == elemSize1());
       18: 1161:    return ((_Tp*)(data + step.p[0] * i0))[i1];
       18: 1161-block  0
        -: 1162:}
        -: 1163:
        -: 1164:template<typename _Tp> inline
        -: 1165:const _Tp& Mat::at(int i0, int i1) const
        -: 1166:{
        -: 1167:    CV_DbgAssert(dims <= 2);
        -: 1168:    CV_DbgAssert(data);
        -: 1169:    CV_DbgAssert((unsigned)i0 < (unsigned)size.p[0]);
        -: 1170:    CV_DbgAssert((unsigned)(i1 * DataType<_Tp>::channels) < (unsigned)(size.p[1] * channels()));
        -: 1171:    CV_DbgAssert(CV_ELEM_SIZE1(traits::Depth<_Tp>::value) == elemSize1());
        -: 1172:    return ((const _Tp*)(data + step.p[0] * i0))[i1];
        -: 1173:}
        -: 1174:
        -: 1175:template<typename _Tp> inline
        -: 1176:_Tp& Mat::at(Point pt)
        -: 1177:{
        -: 1178:    CV_DbgAssert(dims <= 2);
        -: 1179:    CV_DbgAssert(data);
        -: 1180:    CV_DbgAssert((unsigned)pt.y < (unsigned)size.p[0]);
        -: 1181:    CV_DbgAssert((unsigned)(pt.x * DataType<_Tp>::channels) < (unsigned)(size.p[1] * channels()));
        -: 1182:    CV_DbgAssert(CV_ELEM_SIZE1(traits::Depth<_Tp>::value) == elemSize1());
        -: 1183:    return ((_Tp*)(data + step.p[0] * pt.y))[pt.x];
        -: 1184:}
        -: 1185:
        -: 1186:template<typename _Tp> inline
        -: 1187:const _Tp& Mat::at(Point pt) const
        -: 1188:{
        -: 1189:    CV_DbgAssert(dims <= 2);
        -: 1190:    CV_DbgAssert(data);
        -: 1191:    CV_DbgAssert((unsigned)pt.y < (unsigned)size.p[0]);
        -: 1192:    CV_DbgAssert((unsigned)(pt.x * DataType<_Tp>::channels) < (unsigned)(size.p[1] * channels()));
        -: 1193:    CV_DbgAssert(CV_ELEM_SIZE1(traits::Depth<_Tp>::value) == elemSize1());
        -: 1194:    return ((const _Tp*)(data + step.p[0] * pt.y))[pt.x];
        -: 1195:}
        -: 1196:
        -: 1197:template<typename _Tp> inline
        -: 1198:_Tp& Mat::at(int i0)
        -: 1199:{
        -: 1200:    CV_DbgAssert(dims <= 2);
        -: 1201:    CV_DbgAssert(data);
        -: 1202:    CV_DbgAssert((unsigned)i0 < (unsigned)(size.p[0] * size.p[1]));
        -: 1203:    CV_DbgAssert(elemSize() == sizeof(_Tp));
        -: 1204:    if( isContinuous() || size.p[0] == 1 )
        -: 1205:        return ((_Tp*)data)[i0];
        -: 1206:    if( size.p[1] == 1 )
        -: 1207:        return *(_Tp*)(data + step.p[0] * i0);
        -: 1208:    int i = i0 / cols, j = i0 - i * cols;
        -: 1209:    return ((_Tp*)(data + step.p[0] * i))[j];
        -: 1210:}
        -: 1211:
        -: 1212:template<typename _Tp> inline
        -: 1213:const _Tp& Mat::at(int i0) const
        -: 1214:{
        -: 1215:    CV_DbgAssert(dims <= 2);
        -: 1216:    CV_DbgAssert(data);
        -: 1217:    CV_DbgAssert((unsigned)i0 < (unsigned)(size.p[0] * size.p[1]));
        -: 1218:    CV_DbgAssert(elemSize() == sizeof(_Tp));
        -: 1219:    if( isContinuous() || size.p[0] == 1 )
        -: 1220:        return ((const _Tp*)data)[i0];
        -: 1221:    if( size.p[1] == 1 )
        -: 1222:        return *(const _Tp*)(data + step.p[0] * i0);
        -: 1223:    int i = i0 / cols, j = i0 - i * cols;
        -: 1224:    return ((const _Tp*)(data + step.p[0] * i))[j];
        -: 1225:}
        -: 1226:
        -: 1227:template<typename _Tp> inline
        -: 1228:_Tp& Mat::at(int i0, int i1, int i2)
        -: 1229:{
        -: 1230:    CV_DbgAssert( elemSize() == sizeof(_Tp) );
        -: 1231:    return *(_Tp*)ptr(i0, i1, i2);
        -: 1232:}
        -: 1233:
        -: 1234:template<typename _Tp> inline
        -: 1235:const _Tp& Mat::at(int i0, int i1, int i2) const
        -: 1236:{
        -: 1237:    CV_DbgAssert( elemSize() == sizeof(_Tp) );
        -: 1238:    return *(const _Tp*)ptr(i0, i1, i2);
        -: 1239:}
        -: 1240:
        -: 1241:template<typename _Tp> inline
        -: 1242:_Tp& Mat::at(const int* idx)
        -: 1243:{
        -: 1244:    CV_DbgAssert( elemSize() == sizeof(_Tp) );
        -: 1245:    return *(_Tp*)ptr(idx);
        -: 1246:}
        -: 1247:
        -: 1248:template<typename _Tp> inline
        -: 1249:const _Tp& Mat::at(const int* idx) const
        -: 1250:{
        -: 1251:    CV_DbgAssert( elemSize() == sizeof(_Tp) );
        -: 1252:    return *(const _Tp*)ptr(idx);
        -: 1253:}
        -: 1254:
        -: 1255:template<typename _Tp, int n> inline
        -: 1256:_Tp& Mat::at(const Vec<int, n>& idx)
        -: 1257:{
        -: 1258:    CV_DbgAssert( elemSize() == sizeof(_Tp) );
        -: 1259:    return *(_Tp*)ptr(idx.val);
        -: 1260:}
        -: 1261:
        -: 1262:template<typename _Tp, int n> inline
        -: 1263:const _Tp& Mat::at(const Vec<int, n>& idx) const
        -: 1264:{
        -: 1265:    CV_DbgAssert( elemSize() == sizeof(_Tp) );
        -: 1266:    return *(const _Tp*)ptr(idx.val);
        -: 1267:}
        -: 1268:
        -: 1269:template<typename _Tp> inline
        -: 1270:MatConstIterator_<_Tp> Mat::begin() const
        -: 1271:{
        -: 1272:    if (empty())
        -: 1273:        return MatConstIterator_<_Tp>();
        -: 1274:    CV_DbgAssert( elemSize() == sizeof(_Tp) );
        -: 1275:    return MatConstIterator_<_Tp>((const Mat_<_Tp>*)this);
        -: 1276:}
        -: 1277:
        -: 1278:template<typename _Tp> inline
        -: 1279:MatConstIterator_<_Tp> Mat::end() const
        -: 1280:{
        -: 1281:    if (empty())
        -: 1282:        return MatConstIterator_<_Tp>();
        -: 1283:    CV_DbgAssert( elemSize() == sizeof(_Tp) );
        -: 1284:    MatConstIterator_<_Tp> it((const Mat_<_Tp>*)this);
        -: 1285:    it += total();
        -: 1286:    return it;
        -: 1287:}
        -: 1288:
        -: 1289:template<typename _Tp> inline
        -: 1290:MatIterator_<_Tp> Mat::begin()
        -: 1291:{
        -: 1292:    if (empty())
        -: 1293:        return MatIterator_<_Tp>();
        -: 1294:    CV_DbgAssert( elemSize() == sizeof(_Tp) );
        -: 1295:    return MatIterator_<_Tp>((Mat_<_Tp>*)this);
        -: 1296:}
        -: 1297:
        -: 1298:template<typename _Tp> inline
        -: 1299:MatIterator_<_Tp> Mat::end()
        -: 1300:{
        -: 1301:    if (empty())
        -: 1302:        return MatIterator_<_Tp>();
        -: 1303:    CV_DbgAssert( elemSize() == sizeof(_Tp) );
        -: 1304:    MatIterator_<_Tp> it((Mat_<_Tp>*)this);
        -: 1305:    it += total();
        -: 1306:    return it;
        -: 1307:}
        -: 1308:
        -: 1309:template<typename _Tp, typename Functor> inline
        -: 1310:void Mat::forEach(const Functor& operation) {
        -: 1311:    this->forEach_impl<_Tp>(operation);
        -: 1312:}
        -: 1313:
        -: 1314:template<typename _Tp, typename Functor> inline
        -: 1315:void Mat::forEach(const Functor& operation) const {
        -: 1316:    // call as not const
        -: 1317:    (const_cast<Mat*>(this))->forEach<_Tp>(operation);
        -: 1318:}
        -: 1319:
        -: 1320:template<typename _Tp> inline
        -: 1321:Mat::operator std::vector<_Tp>() const
        -: 1322:{
        -: 1323:    std::vector<_Tp> v;
        -: 1324:    copyTo(v);
        -: 1325:    return v;
        -: 1326:}
        -: 1327:
        -: 1328:template<typename _Tp, std::size_t _Nm> inline
        -: 1329:Mat::operator std::array<_Tp, _Nm>() const
        -: 1330:{
        -: 1331:    std::array<_Tp, _Nm> v;
        -: 1332:    copyTo(v);
        -: 1333:    return v;
        -: 1334:}
        -: 1335:
        -: 1336:template<typename _Tp, int n> inline
        -: 1337:Mat::operator Vec<_Tp, n>() const
        -: 1338:{
        -: 1339:    CV_Assert( data && dims <= 2 && (rows == 1 || cols == 1) &&
        -: 1340:               rows + cols - 1 == n && channels() == 1 );
        -: 1341:
        -: 1342:    if( isContinuous() && type() == traits::Type<_Tp>::value )
        -: 1343:        return Vec<_Tp, n>((_Tp*)data);
        -: 1344:    Vec<_Tp, n> v;
        -: 1345:    Mat tmp(rows, cols, traits::Type<_Tp>::value, v.val);
        -: 1346:    convertTo(tmp, tmp.type());
        -: 1347:    return v;
        -: 1348:}
        -: 1349:
        -: 1350:template<typename _Tp, int m, int n> inline
        -: 1351:Mat::operator Matx<_Tp, m, n>() const
        -: 1352:{
        -: 1353:    CV_Assert( data && dims <= 2 && rows == m && cols == n && channels() == 1 );
        -: 1354:
        -: 1355:    if( isContinuous() && type() == traits::Type<_Tp>::value )
        -: 1356:        return Matx<_Tp, m, n>((_Tp*)data);
        -: 1357:    Matx<_Tp, m, n> mtx;
        -: 1358:    Mat tmp(rows, cols, traits::Type<_Tp>::value, mtx.val);
        -: 1359:    convertTo(tmp, tmp.type());
        -: 1360:    return mtx;
        -: 1361:}
        -: 1362:
        -: 1363:template<typename _Tp> inline
        -: 1364:void Mat::push_back(const _Tp& elem)
        -: 1365:{
        -: 1366:    if( !data )
        -: 1367:    {
        -: 1368:        *this = Mat(1, 1, traits::Type<_Tp>::value, (void*)&elem).clone();
        -: 1369:        return;
        -: 1370:    }
        -: 1371:    CV_Assert(traits::Type<_Tp>::value == type() && cols == 1
        -: 1372:              /* && dims == 2 (cols == 1 implies dims == 2) */);
        -: 1373:    const uchar* tmp = dataend + step[0];
        -: 1374:    if( !isSubmatrix() && isContinuous() && tmp <= datalimit )
        -: 1375:    {
        -: 1376:        *(_Tp*)(data + (size.p[0]++) * step.p[0]) = elem;
        -: 1377:        dataend = tmp;
        -: 1378:    }
        -: 1379:    else
        -: 1380:        push_back_(&elem);
        -: 1381:}
        -: 1382:
        -: 1383:template<typename _Tp> inline
        -: 1384:void Mat::push_back(const Mat_<_Tp>& m)
        -: 1385:{
        -: 1386:    push_back((const Mat&)m);
        -: 1387:}
        -: 1388:
        -: 1389:template<> inline
        -: 1390:void Mat::push_back(const MatExpr& expr)
        -: 1391:{
        -: 1392:    push_back(static_cast<Mat>(expr));
        -: 1393:}
        -: 1394:
        -: 1395:
        -: 1396:template<typename _Tp> inline
        -: 1397:void Mat::push_back(const std::vector<_Tp>& v)
        -: 1398:{
        -: 1399:    push_back(Mat(v));
        -: 1400:}
        -: 1401:
        -: 1402:inline
        -: 1403:Mat::Mat(Mat&& m)
        -: 1404:    : flags(m.flags), dims(m.dims), rows(m.rows), cols(m.cols), data(m.data),
        -: 1405:      datastart(m.datastart), dataend(m.dataend), datalimit(m.datalimit), allocator(m.allocator),
        -: 1406:      u(m.u), size(&rows)
        -: 1407:{
        -: 1408:    if (m.dims <= 2)  // move new step/size info
        -: 1409:    {
        -: 1410:        step[0] = m.step[0];
        -: 1411:        step[1] = m.step[1];
        -: 1412:    }
        -: 1413:    else
        -: 1414:    {
        -: 1415:        CV_DbgAssert(m.step.p != m.step.buf);
        -: 1416:        step.p = m.step.p;
        -: 1417:        size.p = m.size.p;
        -: 1418:        m.step.p = m.step.buf;
        -: 1419:        m.size.p = &m.rows;
        -: 1420:    }
        -: 1421:    m.flags = MAGIC_VAL; m.dims = m.rows = m.cols = 0;
        -: 1422:    m.data = NULL; m.datastart = NULL; m.dataend = NULL; m.datalimit = NULL;
        -: 1423:    m.allocator = NULL;
        -: 1424:    m.u = NULL;
        -: 1425:}
        -: 1426:
        -: 1427:inline
        -: 1428:Mat& Mat::operator = (Mat&& m)
        -: 1429:{
        -: 1430:    if (this == &m)
        -: 1431:      return *this;
        -: 1432:
        -: 1433:    release();
        -: 1434:    flags = m.flags; dims = m.dims; rows = m.rows; cols = m.cols; data = m.data;
        -: 1435:    datastart = m.datastart; dataend = m.dataend; datalimit = m.datalimit; allocator = m.allocator;
        -: 1436:    u = m.u;
        -: 1437:    if (step.p != step.buf) // release self step/size
        -: 1438:    {
        -: 1439:        fastFree(step.p);
        -: 1440:        step.p = step.buf;
        -: 1441:        size.p = &rows;
        -: 1442:    }
        -: 1443:    if (m.dims <= 2) // move new step/size info
        -: 1444:    {
        -: 1445:        step[0] = m.step[0];
        -: 1446:        step[1] = m.step[1];
        -: 1447:    }
        -: 1448:    else
        -: 1449:    {
        -: 1450:        CV_DbgAssert(m.step.p != m.step.buf);
        -: 1451:        step.p = m.step.p;
        -: 1452:        size.p = m.size.p;
        -: 1453:        m.step.p = m.step.buf;
        -: 1454:        m.size.p = &m.rows;
        -: 1455:    }
        -: 1456:    m.flags = MAGIC_VAL; m.dims = m.rows = m.cols = 0;
        -: 1457:    m.data = NULL; m.datastart = NULL; m.dataend = NULL; m.datalimit = NULL;
        -: 1458:    m.allocator = NULL;
        -: 1459:    m.u = NULL;
        -: 1460:    return *this;
        -: 1461:}
        -: 1462:
        -: 1463:
        -: 1464:///////////////////////////// MatSize ////////////////////////////
        -: 1465:
        -: 1466:inline
        2: 1467:MatSize::MatSize(int* _p)
        1: 1467-block  0
        1: 1467-block  1
        2: 1468:    : p(_p) {}
        1: 1468-block  0
        1: 1468-block  1
        -: 1469:
        -: 1470:inline
        -: 1471:int MatSize::dims() const
        -: 1472:{
        -: 1473:    return (p - 1)[0];
        -: 1474:}
        -: 1475:
        -: 1476:inline
        -: 1477:Size MatSize::operator()() const
        -: 1478:{
        -: 1479:    CV_DbgAssert(dims() <= 2);
        -: 1480:    return Size(p[1], p[0]);
        -: 1481:}
        -: 1482:
        -: 1483:inline
        -: 1484:const int& MatSize::operator[](int i) const
        -: 1485:{
        -: 1486:    CV_DbgAssert(i < dims());
        -: 1487:#ifdef __OPENCV_BUILD
        -: 1488:    CV_DbgAssert(i >= 0);
        -: 1489:#endif
        -: 1490:    return p[i];
        -: 1491:}
        -: 1492:
        -: 1493:inline
        -: 1494:int& MatSize::operator[](int i)
        -: 1495:{
        -: 1496:    CV_DbgAssert(i < dims());
        -: 1497:#ifdef __OPENCV_BUILD
        -: 1498:    CV_DbgAssert(i >= 0);
        -: 1499:#endif
        -: 1500:    return p[i];
        -: 1501:}
        -: 1502:
        -: 1503:inline
        -: 1504:MatSize::operator const int*() const
        -: 1505:{
        -: 1506:    return p;
        -: 1507:}
        -: 1508:
        -: 1509:inline
        -: 1510:bool MatSize::operator == (const MatSize& sz) const
        -: 1511:{
        -: 1512:    int d = dims();
        -: 1513:    int dsz = sz.dims();
        -: 1514:    if( d != dsz )
        -: 1515:        return false;
        -: 1516:    if( d == 2 )
        -: 1517:        return p[0] == sz.p[0] && p[1] == sz.p[1];
        -: 1518:
        -: 1519:    for( int i = 0; i < d; i++ )
        -: 1520:        if( p[i] != sz.p[i] )
        -: 1521:            return false;
        -: 1522:    return true;
        -: 1523:}
        -: 1524:
        -: 1525:inline
        -: 1526:bool MatSize::operator != (const MatSize& sz) const
        -: 1527:{
        -: 1528:    return !(*this == sz);
        -: 1529:}
        -: 1530:
        -: 1531:
        -: 1532:
        -: 1533:///////////////////////////// MatStep ////////////////////////////
        -: 1534:
        -: 1535:inline
        -: 1536:MatStep::MatStep()
        -: 1537:{
        -: 1538:    p = buf; p[0] = p[1] = 0;
        -: 1539:}
        -: 1540:
        -: 1541:inline
        2: 1542:MatStep::MatStep(size_t s)
        1: 1542-block  0
        1: 1542-block  1
        1: 1543:{
        1: 1544:    p = buf; p[0] = s; p[1] = 0;
        2: 1545:}
        1: 1545-block  0
        1: 1545-block  1
        -: 1546:
        -: 1547:inline
        -: 1548:const size_t& MatStep::operator[](int i) const
        -: 1549:{
        -: 1550:    return p[i];
        -: 1551:}
        -: 1552:
        -: 1553:inline
        -: 1554:size_t& MatStep::operator[](int i)
        -: 1555:{
        -: 1556:    return p[i];
        -: 1557:}
        -: 1558:
        -: 1559:inline MatStep::operator size_t() const
        -: 1560:{
        -: 1561:    CV_DbgAssert( p == buf );
        -: 1562:    return buf[0];
        -: 1563:}
        -: 1564:
        -: 1565:inline MatStep& MatStep::operator = (size_t s)
        -: 1566:{
        -: 1567:    CV_DbgAssert( p == buf );
        -: 1568:    buf[0] = s;
        -: 1569:    return *this;
        -: 1570:}
        -: 1571:
        -: 1572:
        -: 1573:
        -: 1574:////////////////////////////// Mat_<_Tp> ////////////////////////////
        -: 1575:
        -: 1576:template<typename _Tp> inline
        -: 1577:Mat_<_Tp>::Mat_()
        -: 1578:    : Mat()
        -: 1579:{
        -: 1580:    flags = (flags & ~CV_MAT_TYPE_MASK) + traits::Type<_Tp>::value;
        -: 1581:}
        -: 1582:
        -: 1583:template<typename _Tp> inline
        -: 1584:Mat_<_Tp>::Mat_(int _rows, int _cols)
        -: 1585:    : Mat(_rows, _cols, traits::Type<_Tp>::value)
        -: 1586:{
        -: 1587:}
        -: 1588:
        -: 1589:template<typename _Tp> inline
        -: 1590:Mat_<_Tp>::Mat_(int _rows, int _cols, const _Tp& value)
        -: 1591:    : Mat(_rows, _cols, traits::Type<_Tp>::value)
        -: 1592:{
        -: 1593:    *this = value;
        -: 1594:}
        -: 1595:
        -: 1596:template<typename _Tp> inline
        -: 1597:Mat_<_Tp>::Mat_(Size _sz)
        -: 1598:    : Mat(_sz.height, _sz.width, traits::Type<_Tp>::value)
        -: 1599:{}
        -: 1600:
        -: 1601:template<typename _Tp> inline
        -: 1602:Mat_<_Tp>::Mat_(Size _sz, const _Tp& value)
        -: 1603:    : Mat(_sz.height, _sz.width, traits::Type<_Tp>::value)
        -: 1604:{
        -: 1605:    *this = value;
        -: 1606:}
        -: 1607:
        -: 1608:template<typename _Tp> inline
        -: 1609:Mat_<_Tp>::Mat_(int _dims, const int* _sz)
        -: 1610:    : Mat(_dims, _sz, traits::Type<_Tp>::value)
        -: 1611:{}
        -: 1612:
        -: 1613:template<typename _Tp> inline
        -: 1614:Mat_<_Tp>::Mat_(int _dims, const int* _sz, const _Tp& _s)
        -: 1615:    : Mat(_dims, _sz, traits::Type<_Tp>::value, Scalar(_s))
        -: 1616:{}
        -: 1617:
        -: 1618:template<typename _Tp> inline
        -: 1619:Mat_<_Tp>::Mat_(int _dims, const int* _sz, _Tp* _data, const size_t* _steps)
        -: 1620:    : Mat(_dims, _sz, traits::Type<_Tp>::value, _data, _steps)
        -: 1621:{}
        -: 1622:
        -: 1623:template<typename _Tp> inline
        -: 1624:Mat_<_Tp>::Mat_(const Mat_<_Tp>& m, const Range* ranges)
        -: 1625:    : Mat(m, ranges)
        -: 1626:{}
        -: 1627:
        -: 1628:template<typename _Tp> inline
        -: 1629:Mat_<_Tp>::Mat_(const Mat_<_Tp>& m, const std::vector<Range>& ranges)
        -: 1630:    : Mat(m, ranges)
        -: 1631:{}
        -: 1632:
        -: 1633:template<typename _Tp> inline
        -: 1634:Mat_<_Tp>::Mat_(const Mat& m)
        -: 1635:    : Mat()
        -: 1636:{
        -: 1637:    flags = (flags & ~CV_MAT_TYPE_MASK) + traits::Type<_Tp>::value;
        -: 1638:    *this = m;
        -: 1639:}
        -: 1640:
        -: 1641:template<typename _Tp> inline
        -: 1642:Mat_<_Tp>::Mat_(const Mat_& m)
        -: 1643:    : Mat(m)
        -: 1644:{}
        -: 1645:
        -: 1646:template<typename _Tp> inline
        -: 1647:Mat_<_Tp>::Mat_(int _rows, int _cols, _Tp* _data, size_t steps)
        -: 1648:    : Mat(_rows, _cols, traits::Type<_Tp>::value, _data, steps)
        -: 1649:{}
        -: 1650:
        -: 1651:template<typename _Tp> inline
        -: 1652:Mat_<_Tp>::Mat_(const Mat_& m, const Range& _rowRange, const Range& _colRange)
        -: 1653:    : Mat(m, _rowRange, _colRange)
        -: 1654:{}
        -: 1655:
        -: 1656:template<typename _Tp> inline
        -: 1657:Mat_<_Tp>::Mat_(const Mat_& m, const Rect& roi)
        -: 1658:    : Mat(m, roi)
        -: 1659:{}
        -: 1660:
        -: 1661:template<typename _Tp> template<int n> inline
        -: 1662:Mat_<_Tp>::Mat_(const Vec<typename DataType<_Tp>::channel_type, n>& vec, bool copyData)
        -: 1663:    : Mat(n / DataType<_Tp>::channels, 1, traits::Type<_Tp>::value, (void*)&vec)
        -: 1664:{
        -: 1665:    CV_Assert(n%DataType<_Tp>::channels == 0);
        -: 1666:    if( copyData )
        -: 1667:        *this = clone();
        -: 1668:}
        -: 1669:
        -: 1670:template<typename _Tp> template<int m, int n> inline
        -: 1671:Mat_<_Tp>::Mat_(const Matx<typename DataType<_Tp>::channel_type, m, n>& M, bool copyData)
        -: 1672:    : Mat(m, n / DataType<_Tp>::channels, traits::Type<_Tp>::value, (void*)&M)
        -: 1673:{
        -: 1674:    CV_Assert(n % DataType<_Tp>::channels == 0);
        -: 1675:    if( copyData )
        -: 1676:        *this = clone();
        -: 1677:}
        -: 1678:
        -: 1679:template<typename _Tp> inline
        -: 1680:Mat_<_Tp>::Mat_(const Point_<typename DataType<_Tp>::channel_type>& pt, bool copyData)
        -: 1681:    : Mat(2 / DataType<_Tp>::channels, 1, traits::Type<_Tp>::value, (void*)&pt)
        -: 1682:{
        -: 1683:    CV_Assert(2 % DataType<_Tp>::channels == 0);
        -: 1684:    if( copyData )
        -: 1685:        *this = clone();
        -: 1686:}
        -: 1687:
        -: 1688:template<typename _Tp> inline
        -: 1689:Mat_<_Tp>::Mat_(const Point3_<typename DataType<_Tp>::channel_type>& pt, bool copyData)
        -: 1690:    : Mat(3 / DataType<_Tp>::channels, 1, traits::Type<_Tp>::value, (void*)&pt)
        -: 1691:{
        -: 1692:    CV_Assert(3 % DataType<_Tp>::channels == 0);
        -: 1693:    if( copyData )
        -: 1694:        *this = clone();
        -: 1695:}
        -: 1696:
        -: 1697:template<typename _Tp> inline
        -: 1698:Mat_<_Tp>::Mat_(const MatCommaInitializer_<_Tp>& commaInitializer)
        -: 1699:    : Mat(commaInitializer)
        -: 1700:{}
        -: 1701:
        -: 1702:template<typename _Tp> inline
        -: 1703:Mat_<_Tp>::Mat_(const std::vector<_Tp>& vec, bool copyData)
        -: 1704:    : Mat(vec, copyData)
        -: 1705:{}
        -: 1706:
        -: 1707:template<typename _Tp> inline
        -: 1708:Mat_<_Tp>::Mat_(std::initializer_list<_Tp> list)
        -: 1709:    : Mat(list)
        -: 1710:{}
        -: 1711:
        -: 1712:template<typename _Tp> inline
        -: 1713:Mat_<_Tp>::Mat_(const std::initializer_list<int> sizes, std::initializer_list<_Tp> list)
        -: 1714:    : Mat(sizes, list)
        -: 1715:{}
        -: 1716:
        -: 1717:template<typename _Tp> template<std::size_t _Nm> inline
        -: 1718:Mat_<_Tp>::Mat_(const std::array<_Tp, _Nm>& arr, bool copyData)
        -: 1719:    : Mat(arr, copyData)
        -: 1720:{}
        -: 1721:
        -: 1722:template<typename _Tp> inline
        -: 1723:Mat_<_Tp>& Mat_<_Tp>::operator = (const Mat& m)
        -: 1724:{
        -: 1725:    if (m.empty())
        -: 1726:    {
        -: 1727:        release();
        -: 1728:        return *this;
        -: 1729:    }
        -: 1730:    if( traits::Type<_Tp>::value == m.type() )
        -: 1731:    {
        -: 1732:        Mat::operator = (m);
        -: 1733:        return *this;
        -: 1734:    }
        -: 1735:    if( traits::Depth<_Tp>::value == m.depth() )
        -: 1736:    {
        -: 1737:        return (*this = m.reshape(DataType<_Tp>::channels, m.dims, 0));
        -: 1738:    }
        -: 1739:    CV_Assert(DataType<_Tp>::channels == m.channels() || m.empty());
        -: 1740:    m.convertTo(*this, type());
        -: 1741:    return *this;
        -: 1742:}
        -: 1743:
        -: 1744:template<typename _Tp> inline
        -: 1745:Mat_<_Tp>& Mat_<_Tp>::operator = (const Mat_& m)
        -: 1746:{
        -: 1747:    Mat::operator=(m);
        -: 1748:    return *this;
        -: 1749:}
        -: 1750:
        -: 1751:template<typename _Tp> inline
        -: 1752:Mat_<_Tp>& Mat_<_Tp>::operator = (const _Tp& s)
        -: 1753:{
        -: 1754:    typedef typename DataType<_Tp>::vec_type VT;
        -: 1755:    Mat::operator=(Scalar((const VT&)s));
        -: 1756:    return *this;
        -: 1757:}
        -: 1758:
        -: 1759:template<typename _Tp> inline
        -: 1760:void Mat_<_Tp>::create(int _rows, int _cols)
        -: 1761:{
        -: 1762:    Mat::create(_rows, _cols, traits::Type<_Tp>::value);
        -: 1763:}
        -: 1764:
        -: 1765:template<typename _Tp> inline
        -: 1766:void Mat_<_Tp>::create(Size _sz)
        -: 1767:{
        -: 1768:    Mat::create(_sz, traits::Type<_Tp>::value);
        -: 1769:}
        -: 1770:
        -: 1771:template<typename _Tp> inline
        -: 1772:void Mat_<_Tp>::create(int _dims, const int* _sz)
        -: 1773:{
        -: 1774:    Mat::create(_dims, _sz, traits::Type<_Tp>::value);
        -: 1775:}
        -: 1776:
        -: 1777:template<typename _Tp> inline
        -: 1778:void Mat_<_Tp>::release()
        -: 1779:{
        -: 1780:    Mat::release();
        -: 1781:#ifdef _DEBUG
        -: 1782:    flags = (flags & ~CV_MAT_TYPE_MASK) + traits::Type<_Tp>::value;
        -: 1783:#endif
        -: 1784:}
        -: 1785:
        -: 1786:template<typename _Tp> inline
        -: 1787:Mat_<_Tp> Mat_<_Tp>::cross(const Mat_& m) const
        -: 1788:{
        -: 1789:    return Mat_<_Tp>(Mat::cross(m));
        -: 1790:}
        -: 1791:
        -: 1792:template<typename _Tp> template<typename T2> inline
        -: 1793:Mat_<_Tp>::operator Mat_<T2>() const
        -: 1794:{
        -: 1795:    return Mat_<T2>(static_cast<const Mat&>(*this));
        -: 1796:}
        -: 1797:
        -: 1798:template<typename _Tp> inline
        -: 1799:Mat_<_Tp> Mat_<_Tp>::row(int y) const
        -: 1800:{
        -: 1801:    return Mat_(*this, Range(y, y+1), Range::all());
        -: 1802:}
        -: 1803:
        -: 1804:template<typename _Tp> inline
        -: 1805:Mat_<_Tp> Mat_<_Tp>::col(int x) const
        -: 1806:{
        -: 1807:    return Mat_(*this, Range::all(), Range(x, x+1));
        -: 1808:}
        -: 1809:
        -: 1810:template<typename _Tp> inline
        -: 1811:Mat_<_Tp> Mat_<_Tp>::diag(int d) const
        -: 1812:{
        -: 1813:    return Mat_(Mat::diag(d));
        -: 1814:}
        -: 1815:
        -: 1816:template<typename _Tp> inline
        -: 1817:Mat_<_Tp> Mat_<_Tp>::clone() const
        -: 1818:{
        -: 1819:    return Mat_(Mat::clone());
        -: 1820:}
        -: 1821:
        -: 1822:template<typename _Tp> inline
        -: 1823:size_t Mat_<_Tp>::elemSize() const
        -: 1824:{
        -: 1825:    CV_DbgAssert( Mat::elemSize() == sizeof(_Tp) );
        -: 1826:    return sizeof(_Tp);
        -: 1827:}
        -: 1828:
        -: 1829:template<typename _Tp> inline
        -: 1830:size_t Mat_<_Tp>::elemSize1() const
        -: 1831:{
        -: 1832:    CV_DbgAssert( Mat::elemSize1() == sizeof(_Tp) / DataType<_Tp>::channels );
        -: 1833:    return sizeof(_Tp) / DataType<_Tp>::channels;
        -: 1834:}
        -: 1835:
        -: 1836:template<typename _Tp> inline
        -: 1837:int Mat_<_Tp>::type() const
        -: 1838:{
        -: 1839:    CV_DbgAssert( Mat::type() == traits::Type<_Tp>::value );
        -: 1840:    return traits::Type<_Tp>::value;
        -: 1841:}
        -: 1842:
        -: 1843:template<typename _Tp> inline
        -: 1844:int Mat_<_Tp>::depth() const
        -: 1845:{
        -: 1846:    CV_DbgAssert( Mat::depth() == traits::Depth<_Tp>::value );
        -: 1847:    return traits::Depth<_Tp>::value;
        -: 1848:}
        -: 1849:
        -: 1850:template<typename _Tp> inline
        -: 1851:int Mat_<_Tp>::channels() const
        -: 1852:{
        -: 1853:    CV_DbgAssert( Mat::channels() == DataType<_Tp>::channels );
        -: 1854:    return DataType<_Tp>::channels;
        -: 1855:}
        -: 1856:
        -: 1857:template<typename _Tp> inline
        -: 1858:size_t Mat_<_Tp>::stepT(int i) const
        -: 1859:{
        -: 1860:    return step.p[i] / elemSize();
        -: 1861:}
        -: 1862:
        -: 1863:template<typename _Tp> inline
        -: 1864:size_t Mat_<_Tp>::step1(int i) const
        -: 1865:{
        -: 1866:    return step.p[i] / elemSize1();
        -: 1867:}
        -: 1868:
        -: 1869:template<typename _Tp> inline
        -: 1870:Mat_<_Tp>& Mat_<_Tp>::adjustROI( int dtop, int dbottom, int dleft, int dright )
        -: 1871:{
        -: 1872:    return (Mat_<_Tp>&)(Mat::adjustROI(dtop, dbottom, dleft, dright));
        -: 1873:}
        -: 1874:
        -: 1875:template<typename _Tp> inline
        -: 1876:Mat_<_Tp> Mat_<_Tp>::operator()( const Range& _rowRange, const Range& _colRange ) const
        -: 1877:{
        -: 1878:    return Mat_<_Tp>(*this, _rowRange, _colRange);
        -: 1879:}
        -: 1880:
        -: 1881:template<typename _Tp> inline
        -: 1882:Mat_<_Tp> Mat_<_Tp>::operator()( const Rect& roi ) const
        -: 1883:{
        -: 1884:    return Mat_<_Tp>(*this, roi);
        -: 1885:}
        -: 1886:
        -: 1887:template<typename _Tp> inline
        -: 1888:Mat_<_Tp> Mat_<_Tp>::operator()( const Range* ranges ) const
        -: 1889:{
        -: 1890:    return Mat_<_Tp>(*this, ranges);
        -: 1891:}
        -: 1892:
        -: 1893:template<typename _Tp> inline
        -: 1894:Mat_<_Tp> Mat_<_Tp>::operator()(const std::vector<Range>& ranges) const
        -: 1895:{
        -: 1896:    return Mat_<_Tp>(*this, ranges);
        -: 1897:}
        -: 1898:
        -: 1899:template<typename _Tp> inline
        -: 1900:_Tp* Mat_<_Tp>::operator [](int y)
        -: 1901:{
        -: 1902:    CV_DbgAssert( 0 <= y && y < size.p[0] );
        -: 1903:    return (_Tp*)(data + y*step.p[0]);
        -: 1904:}
        -: 1905:
        -: 1906:template<typename _Tp> inline
        -: 1907:const _Tp* Mat_<_Tp>::operator [](int y) const
        -: 1908:{
        -: 1909:    CV_DbgAssert( 0 <= y && y < size.p[0] );
        -: 1910:    return (const _Tp*)(data + y*step.p[0]);
        -: 1911:}
        -: 1912:
        -: 1913:template<typename _Tp> inline
        -: 1914:_Tp& Mat_<_Tp>::operator ()(int i0, int i1)
        -: 1915:{
        -: 1916:    CV_DbgAssert(dims <= 2);
        -: 1917:    CV_DbgAssert(data);
        -: 1918:    CV_DbgAssert((unsigned)i0 < (unsigned)size.p[0]);
        -: 1919:    CV_DbgAssert((unsigned)i1 < (unsigned)size.p[1]);
        -: 1920:    CV_DbgAssert(type() == traits::Type<_Tp>::value);
        -: 1921:    return ((_Tp*)(data + step.p[0] * i0))[i1];
        -: 1922:}
        -: 1923:
        -: 1924:template<typename _Tp> inline
        -: 1925:const _Tp& Mat_<_Tp>::operator ()(int i0, int i1) const
        -: 1926:{
        -: 1927:    CV_DbgAssert(dims <= 2);
        -: 1928:    CV_DbgAssert(data);
        -: 1929:    CV_DbgAssert((unsigned)i0 < (unsigned)size.p[0]);
        -: 1930:    CV_DbgAssert((unsigned)i1 < (unsigned)size.p[1]);
        -: 1931:    CV_DbgAssert(type() == traits::Type<_Tp>::value);
        -: 1932:    return ((const _Tp*)(data + step.p[0] * i0))[i1];
        -: 1933:}
        -: 1934:
        -: 1935:template<typename _Tp> inline
        -: 1936:_Tp& Mat_<_Tp>::operator ()(Point pt)
        -: 1937:{
        -: 1938:    CV_DbgAssert(dims <= 2);
        -: 1939:    CV_DbgAssert(data);
        -: 1940:    CV_DbgAssert((unsigned)pt.y < (unsigned)size.p[0]);
        -: 1941:    CV_DbgAssert((unsigned)pt.x < (unsigned)size.p[1]);
        -: 1942:    CV_DbgAssert(type() == traits::Type<_Tp>::value);
        -: 1943:    return ((_Tp*)(data + step.p[0] * pt.y))[pt.x];
        -: 1944:}
        -: 1945:
        -: 1946:template<typename _Tp> inline
        -: 1947:const _Tp& Mat_<_Tp>::operator ()(Point pt) const
        -: 1948:{
        -: 1949:    CV_DbgAssert(dims <= 2);
        -: 1950:    CV_DbgAssert(data);
        -: 1951:    CV_DbgAssert((unsigned)pt.y < (unsigned)size.p[0]);
        -: 1952:    CV_DbgAssert((unsigned)pt.x < (unsigned)size.p[1]);
        -: 1953:    CV_DbgAssert(type() == traits::Type<_Tp>::value);
        -: 1954:    return ((const _Tp*)(data + step.p[0] * pt.y))[pt.x];
        -: 1955:}
        -: 1956:
        -: 1957:template<typename _Tp> inline
        -: 1958:_Tp& Mat_<_Tp>::operator ()(const int* idx)
        -: 1959:{
        -: 1960:    return Mat::at<_Tp>(idx);
        -: 1961:}
        -: 1962:
        -: 1963:template<typename _Tp> inline
        -: 1964:const _Tp& Mat_<_Tp>::operator ()(const int* idx) const
        -: 1965:{
        -: 1966:    return Mat::at<_Tp>(idx);
        -: 1967:}
        -: 1968:
        -: 1969:template<typename _Tp> template<int n> inline
        -: 1970:_Tp& Mat_<_Tp>::operator ()(const Vec<int, n>& idx)
        -: 1971:{
        -: 1972:    return Mat::at<_Tp>(idx);
        -: 1973:}
        -: 1974:
        -: 1975:template<typename _Tp> template<int n> inline
        -: 1976:const _Tp& Mat_<_Tp>::operator ()(const Vec<int, n>& idx) const
        -: 1977:{
        -: 1978:    return Mat::at<_Tp>(idx);
        -: 1979:}
        -: 1980:
        -: 1981:template<typename _Tp> inline
        -: 1982:_Tp& Mat_<_Tp>::operator ()(int i0)
        -: 1983:{
        -: 1984:    return this->at<_Tp>(i0);
        -: 1985:}
        -: 1986:
        -: 1987:template<typename _Tp> inline
        -: 1988:const _Tp& Mat_<_Tp>::operator ()(int i0) const
        -: 1989:{
        -: 1990:    return this->at<_Tp>(i0);
        -: 1991:}
        -: 1992:
        -: 1993:template<typename _Tp> inline
        -: 1994:_Tp& Mat_<_Tp>::operator ()(int i0, int i1, int i2)
        -: 1995:{
        -: 1996:    return this->at<_Tp>(i0, i1, i2);
        -: 1997:}
        -: 1998:
        -: 1999:template<typename _Tp> inline
        -: 2000:const _Tp& Mat_<_Tp>::operator ()(int i0, int i1, int i2) const
        -: 2001:{
        -: 2002:    return this->at<_Tp>(i0, i1, i2);
        -: 2003:}
        -: 2004:
        -: 2005:template<typename _Tp> inline
        -: 2006:Mat_<_Tp>::operator std::vector<_Tp>() const
        -: 2007:{
        -: 2008:    std::vector<_Tp> v;
        -: 2009:    copyTo(v);
        -: 2010:    return v;
        -: 2011:}
        -: 2012:
        -: 2013:template<typename _Tp> template<std::size_t _Nm> inline
        -: 2014:Mat_<_Tp>::operator std::array<_Tp, _Nm>() const
        -: 2015:{
        -: 2016:    std::array<_Tp, _Nm> a;
        -: 2017:    copyTo(a);
        -: 2018:    return a;
        -: 2019:}
        -: 2020:
        -: 2021:template<typename _Tp> template<int n> inline
        -: 2022:Mat_<_Tp>::operator Vec<typename DataType<_Tp>::channel_type, n>() const
        -: 2023:{
        -: 2024:    CV_Assert(n % DataType<_Tp>::channels == 0);
        -: 2025:
        -: 2026:#if defined _MSC_VER
        -: 2027:    const Mat* pMat = (const Mat*)this; // workaround for MSVS <= 2012 compiler bugs (but GCC 4.6 dislikes this workaround)
        -: 2028:    return pMat->operator Vec<typename DataType<_Tp>::channel_type, n>();
        -: 2029:#else
        -: 2030:    return this->Mat::operator Vec<typename DataType<_Tp>::channel_type, n>();
        -: 2031:#endif
        -: 2032:}
        -: 2033:
        -: 2034:template<typename _Tp> template<int m, int n> inline
        -: 2035:Mat_<_Tp>::operator Matx<typename DataType<_Tp>::channel_type, m, n>() const
        -: 2036:{
        -: 2037:    CV_Assert(n % DataType<_Tp>::channels == 0);
        -: 2038:
        -: 2039:#if defined _MSC_VER
        -: 2040:    const Mat* pMat = (const Mat*)this; // workaround for MSVS <= 2012 compiler bugs (but GCC 4.6 dislikes this workaround)
        -: 2041:    Matx<typename DataType<_Tp>::channel_type, m, n> res = pMat->operator Matx<typename DataType<_Tp>::channel_type, m, n>();
        -: 2042:    return res;
        -: 2043:#else
        -: 2044:    Matx<typename DataType<_Tp>::channel_type, m, n> res = this->Mat::operator Matx<typename DataType<_Tp>::channel_type, m, n>();
        -: 2045:    return res;
        -: 2046:#endif
        -: 2047:}
        -: 2048:
        -: 2049:template<typename _Tp> inline
        -: 2050:MatConstIterator_<_Tp> Mat_<_Tp>::begin() const
        -: 2051:{
        -: 2052:    return Mat::begin<_Tp>();
        -: 2053:}
        -: 2054:
        -: 2055:template<typename _Tp> inline
        -: 2056:MatConstIterator_<_Tp> Mat_<_Tp>::end() const
        -: 2057:{
        -: 2058:    return Mat::end<_Tp>();
        -: 2059:}
        -: 2060:
        -: 2061:template<typename _Tp> inline
        -: 2062:MatIterator_<_Tp> Mat_<_Tp>::begin()
        -: 2063:{
        -: 2064:    return Mat::begin<_Tp>();
        -: 2065:}
        -: 2066:
        -: 2067:template<typename _Tp> inline
        -: 2068:MatIterator_<_Tp> Mat_<_Tp>::end()
        -: 2069:{
        -: 2070:    return Mat::end<_Tp>();
        -: 2071:}
        -: 2072:
        -: 2073:template<typename _Tp> template<typename Functor> inline
        -: 2074:void Mat_<_Tp>::forEach(const Functor& operation) {
        -: 2075:    Mat::forEach<_Tp, Functor>(operation);
        -: 2076:}
        -: 2077:
        -: 2078:template<typename _Tp> template<typename Functor> inline
        -: 2079:void Mat_<_Tp>::forEach(const Functor& operation) const {
        -: 2080:    Mat::forEach<_Tp, Functor>(operation);
        -: 2081:}
        -: 2082:
        -: 2083:template<typename _Tp> inline
        -: 2084:Mat_<_Tp>::Mat_(Mat_&& m)
        -: 2085:    : Mat(std::move(m))
        -: 2086:{
        -: 2087:}
        -: 2088:
        -: 2089:template<typename _Tp> inline
        -: 2090:Mat_<_Tp>& Mat_<_Tp>::operator = (Mat_&& m)
        -: 2091:{
        -: 2092:    Mat::operator = (std::move(m));
        -: 2093:    return *this;
        -: 2094:}
        -: 2095:
        -: 2096:template<typename _Tp> inline
        -: 2097:Mat_<_Tp>::Mat_(Mat&& m)
        -: 2098:    : Mat()
        -: 2099:{
        -: 2100:    flags = (flags & ~CV_MAT_TYPE_MASK) + traits::Type<_Tp>::value;
        -: 2101:    *this = std::move(m);
        -: 2102:}
        -: 2103:
        -: 2104:template<typename _Tp> inline
        -: 2105:Mat_<_Tp>& Mat_<_Tp>::operator = (Mat&& m)
        -: 2106:{
        -: 2107:    if (m.empty())
        -: 2108:    {
        -: 2109:        release();
        -: 2110:        return *this;
        -: 2111:    }
        -: 2112:    if( traits::Type<_Tp>::value == m.type() )
        -: 2113:    {
        -: 2114:        Mat::operator = ((Mat&&)m);
        -: 2115:        return *this;
        -: 2116:    }
        -: 2117:    if( traits::Depth<_Tp>::value == m.depth() )
        -: 2118:    {
        -: 2119:        Mat::operator = ((Mat&&)m.reshape(DataType<_Tp>::channels, m.dims, 0));
        -: 2120:        return *this;
        -: 2121:    }
        -: 2122:    CV_DbgAssert(DataType<_Tp>::channels == m.channels());
        -: 2123:    m.convertTo(*this, type());
        -: 2124:    return *this;
        -: 2125:}
        -: 2126:
        -: 2127:template<typename _Tp> inline
        -: 2128:Mat_<_Tp>::Mat_(MatExpr&& e)
        -: 2129:    : Mat()
        -: 2130:{
        -: 2131:    flags = (flags & ~CV_MAT_TYPE_MASK) + traits::Type<_Tp>::value;
        -: 2132:    *this = Mat(e);
        -: 2133:}
        -: 2134:
        -: 2135:
        -: 2136:///////////////////////////// SparseMat /////////////////////////////
        -: 2137:
        -: 2138:inline
        -: 2139:SparseMat::SparseMat()
        -: 2140:    : flags(MAGIC_VAL), hdr(0)
        -: 2141:{}
        -: 2142:
        -: 2143:inline
        -: 2144:SparseMat::SparseMat(int _dims, const int* _sizes, int _type)
        -: 2145:    : flags(MAGIC_VAL), hdr(0)
        -: 2146:{
        -: 2147:    create(_dims, _sizes, _type);
        -: 2148:}
        -: 2149:
        -: 2150:inline
        -: 2151:SparseMat::SparseMat(const SparseMat& m)
        -: 2152:    : flags(m.flags), hdr(m.hdr)
        -: 2153:{
        -: 2154:    addref();
        -: 2155:}
        -: 2156:
        -: 2157:inline
        -: 2158:SparseMat::~SparseMat()
        -: 2159:{
        -: 2160:    release();
        -: 2161:}
        -: 2162:
        -: 2163:inline
        -: 2164:SparseMat& SparseMat::operator = (const SparseMat& m)
        -: 2165:{
        -: 2166:    if( this != &m )
        -: 2167:    {
        -: 2168:        if( m.hdr )
        -: 2169:            CV_XADD(&m.hdr->refcount, 1);
        -: 2170:        release();
        -: 2171:        flags = m.flags;
        -: 2172:        hdr = m.hdr;
        -: 2173:    }
        -: 2174:    return *this;
        -: 2175:}
        -: 2176:
        -: 2177:inline
        -: 2178:SparseMat& SparseMat::operator = (const Mat& m)
        -: 2179:{
        -: 2180:    return (*this = SparseMat(m));
        -: 2181:}
        -: 2182:
        -: 2183:inline
        -: 2184:SparseMat SparseMat::clone() const
        -: 2185:{
        -: 2186:    SparseMat temp;
        -: 2187:    this->copyTo(temp);
        -: 2188:    return temp;
        -: 2189:}
        -: 2190:
        -: 2191:inline
        -: 2192:void SparseMat::assignTo( SparseMat& m, int _type ) const
        -: 2193:{
        -: 2194:    if( _type < 0 )
        -: 2195:        m = *this;
        -: 2196:    else
        -: 2197:        convertTo(m, _type);
        -: 2198:}
        -: 2199:
        -: 2200:inline
        -: 2201:void SparseMat::addref()
        -: 2202:{
        -: 2203:    if( hdr )
        -: 2204:        CV_XADD(&hdr->refcount, 1);
        -: 2205:}
        -: 2206:
        -: 2207:inline
        -: 2208:void SparseMat::release()
        -: 2209:{
        -: 2210:    if( hdr && CV_XADD(&hdr->refcount, -1) == 1 )
        -: 2211:        delete hdr;
        -: 2212:    hdr = 0;
        -: 2213:}
        -: 2214:
        -: 2215:inline
        -: 2216:size_t SparseMat::elemSize() const
        -: 2217:{
        -: 2218:    return CV_ELEM_SIZE(flags);
        -: 2219:}
        -: 2220:
        -: 2221:inline
        -: 2222:size_t SparseMat::elemSize1() const
        -: 2223:{
        -: 2224:    return CV_ELEM_SIZE1(flags);
        -: 2225:}
        -: 2226:
        -: 2227:inline
        -: 2228:int SparseMat::type() const
        -: 2229:{
        -: 2230:    return CV_MAT_TYPE(flags);
        -: 2231:}
        -: 2232:
        -: 2233:inline
        -: 2234:int SparseMat::depth() const
        -: 2235:{
        -: 2236:    return CV_MAT_DEPTH(flags);
        -: 2237:}
        -: 2238:
        -: 2239:inline
        -: 2240:int SparseMat::channels() const
        -: 2241:{
        -: 2242:    return CV_MAT_CN(flags);
        -: 2243:}
        -: 2244:
        -: 2245:inline
        -: 2246:const int* SparseMat::size() const
        -: 2247:{
        -: 2248:    return hdr ? hdr->size : 0;
        -: 2249:}
        -: 2250:
        -: 2251:inline
        -: 2252:int SparseMat::size(int i) const
        -: 2253:{
        -: 2254:    if( hdr )
        -: 2255:    {
        -: 2256:        CV_DbgAssert((unsigned)i < (unsigned)hdr->dims);
        -: 2257:        return hdr->size[i];
        -: 2258:    }
        -: 2259:    return 0;
        -: 2260:}
        -: 2261:
        -: 2262:inline
        -: 2263:int SparseMat::dims() const
        -: 2264:{
        -: 2265:    return hdr ? hdr->dims : 0;
        -: 2266:}
        -: 2267:
        -: 2268:inline
        -: 2269:size_t SparseMat::nzcount() const
        -: 2270:{
        -: 2271:    return hdr ? hdr->nodeCount : 0;
        -: 2272:}
        -: 2273:
        -: 2274:inline
        -: 2275:size_t SparseMat::hash(int i0) const
        -: 2276:{
        -: 2277:    return (size_t)i0;
        -: 2278:}
        -: 2279:
        -: 2280:inline
        -: 2281:size_t SparseMat::hash(int i0, int i1) const
        -: 2282:{
        -: 2283:    return (size_t)(unsigned)i0 * HASH_SCALE + (unsigned)i1;
        -: 2284:}
        -: 2285:
        -: 2286:inline
        -: 2287:size_t SparseMat::hash(int i0, int i1, int i2) const
        -: 2288:{
        -: 2289:    return ((size_t)(unsigned)i0 * HASH_SCALE + (unsigned)i1) * HASH_SCALE + (unsigned)i2;
        -: 2290:}
        -: 2291:
        -: 2292:inline
        -: 2293:size_t SparseMat::hash(const int* idx) const
        -: 2294:{
        -: 2295:    size_t h = (unsigned)idx[0];
        -: 2296:    if( !hdr )
        -: 2297:        return 0;
        -: 2298:    int d = hdr->dims;
        -: 2299:    for(int i = 1; i < d; i++ )
        -: 2300:        h = h * HASH_SCALE + (unsigned)idx[i];
        -: 2301:    return h;
        -: 2302:}
        -: 2303:
        -: 2304:template<typename _Tp> inline
        -: 2305:_Tp& SparseMat::ref(int i0, size_t* hashval)
        -: 2306:{
        -: 2307:    return *(_Tp*)((SparseMat*)this)->ptr(i0, true, hashval);
        -: 2308:}
        -: 2309:
        -: 2310:template<typename _Tp> inline
        -: 2311:_Tp& SparseMat::ref(int i0, int i1, size_t* hashval)
        -: 2312:{
        -: 2313:    return *(_Tp*)((SparseMat*)this)->ptr(i0, i1, true, hashval);
        -: 2314:}
        -: 2315:
        -: 2316:template<typename _Tp> inline
        -: 2317:_Tp& SparseMat::ref(int i0, int i1, int i2, size_t* hashval)
        -: 2318:{
        -: 2319:    return *(_Tp*)((SparseMat*)this)->ptr(i0, i1, i2, true, hashval);
        -: 2320:}
        -: 2321:
        -: 2322:template<typename _Tp> inline
        -: 2323:_Tp& SparseMat::ref(const int* idx, size_t* hashval)
        -: 2324:{
        -: 2325:    return *(_Tp*)((SparseMat*)this)->ptr(idx, true, hashval);
        -: 2326:}
        -: 2327:
        -: 2328:template<typename _Tp> inline
        -: 2329:_Tp SparseMat::value(int i0, size_t* hashval) const
        -: 2330:{
        -: 2331:    const _Tp* p = (const _Tp*)((SparseMat*)this)->ptr(i0, false, hashval);
        -: 2332:    return p ? *p : _Tp();
        -: 2333:}
        -: 2334:
        -: 2335:template<typename _Tp> inline
        -: 2336:_Tp SparseMat::value(int i0, int i1, size_t* hashval) const
        -: 2337:{
        -: 2338:    const _Tp* p = (const _Tp*)((SparseMat*)this)->ptr(i0, i1, false, hashval);
        -: 2339:    return p ? *p : _Tp();
        -: 2340:}
        -: 2341:
        -: 2342:template<typename _Tp> inline
        -: 2343:_Tp SparseMat::value(int i0, int i1, int i2, size_t* hashval) const
        -: 2344:{
        -: 2345:    const _Tp* p = (const _Tp*)((SparseMat*)this)->ptr(i0, i1, i2, false, hashval);
        -: 2346:    return p ? *p : _Tp();
        -: 2347:}
        -: 2348:
        -: 2349:template<typename _Tp> inline
        -: 2350:_Tp SparseMat::value(const int* idx, size_t* hashval) const
        -: 2351:{
        -: 2352:    const _Tp* p = (const _Tp*)((SparseMat*)this)->ptr(idx, false, hashval);
        -: 2353:    return p ? *p : _Tp();
        -: 2354:}
        -: 2355:
        -: 2356:template<typename _Tp> inline
        -: 2357:const _Tp* SparseMat::find(int i0, size_t* hashval) const
        -: 2358:{
        -: 2359:    return (const _Tp*)((SparseMat*)this)->ptr(i0, false, hashval);
        -: 2360:}
        -: 2361:
        -: 2362:template<typename _Tp> inline
        -: 2363:const _Tp* SparseMat::find(int i0, int i1, size_t* hashval) const
        -: 2364:{
        -: 2365:    return (const _Tp*)((SparseMat*)this)->ptr(i0, i1, false, hashval);
        -: 2366:}
        -: 2367:
        -: 2368:template<typename _Tp> inline
        -: 2369:const _Tp* SparseMat::find(int i0, int i1, int i2, size_t* hashval) const
        -: 2370:{
        -: 2371:    return (const _Tp*)((SparseMat*)this)->ptr(i0, i1, i2, false, hashval);
        -: 2372:}
        -: 2373:
        -: 2374:template<typename _Tp> inline
        -: 2375:const _Tp* SparseMat::find(const int* idx, size_t* hashval) const
        -: 2376:{
        -: 2377:    return (const _Tp*)((SparseMat*)this)->ptr(idx, false, hashval);
        -: 2378:}
        -: 2379:
        -: 2380:template<typename _Tp> inline
        -: 2381:_Tp& SparseMat::value(Node* n)
        -: 2382:{
        -: 2383:    return *(_Tp*)((uchar*)n + hdr->valueOffset);
        -: 2384:}
        -: 2385:
        -: 2386:template<typename _Tp> inline
        -: 2387:const _Tp& SparseMat::value(const Node* n) const
        -: 2388:{
        -: 2389:    return *(const _Tp*)((const uchar*)n + hdr->valueOffset);
        -: 2390:}
        -: 2391:
        -: 2392:inline
        -: 2393:SparseMat::Node* SparseMat::node(size_t nidx)
        -: 2394:{
        -: 2395:    return (Node*)(void*)&hdr->pool[nidx];
        -: 2396:}
        -: 2397:
        -: 2398:inline
        -: 2399:const SparseMat::Node* SparseMat::node(size_t nidx) const
        -: 2400:{
        -: 2401:    return (const Node*)(const void*)&hdr->pool[nidx];
        -: 2402:}
        -: 2403:
        -: 2404:inline
        -: 2405:SparseMatIterator SparseMat::begin()
        -: 2406:{
        -: 2407:    return SparseMatIterator(this);
        -: 2408:}
        -: 2409:
        -: 2410:inline
        -: 2411:SparseMatConstIterator SparseMat::begin() const
        -: 2412:{
        -: 2413:    return SparseMatConstIterator(this);
        -: 2414:}
        -: 2415:
        -: 2416:inline
        -: 2417:SparseMatIterator SparseMat::end()
        -: 2418:{
        -: 2419:    SparseMatIterator it(this);
        -: 2420:    it.seekEnd();
        -: 2421:    return it;
        -: 2422:}
        -: 2423:
        -: 2424:inline
        -: 2425:SparseMatConstIterator SparseMat::end() const
        -: 2426:{
        -: 2427:    SparseMatConstIterator it(this);
        -: 2428:    it.seekEnd();
        -: 2429:    return it;
        -: 2430:}
        -: 2431:
        -: 2432:template<typename _Tp> inline
        -: 2433:SparseMatIterator_<_Tp> SparseMat::begin()
        -: 2434:{
        -: 2435:    return SparseMatIterator_<_Tp>(this);
        -: 2436:}
        -: 2437:
        -: 2438:template<typename _Tp> inline
        -: 2439:SparseMatConstIterator_<_Tp> SparseMat::begin() const
        -: 2440:{
        -: 2441:    return SparseMatConstIterator_<_Tp>(this);
        -: 2442:}
        -: 2443:
        -: 2444:template<typename _Tp> inline
        -: 2445:SparseMatIterator_<_Tp> SparseMat::end()
        -: 2446:{
        -: 2447:    SparseMatIterator_<_Tp> it(this);
        -: 2448:    it.seekEnd();
        -: 2449:    return it;
        -: 2450:}
        -: 2451:
        -: 2452:template<typename _Tp> inline
        -: 2453:SparseMatConstIterator_<_Tp> SparseMat::end() const
        -: 2454:{
        -: 2455:    SparseMatConstIterator_<_Tp> it(this);
        -: 2456:    it.seekEnd();
        -: 2457:    return it;
        -: 2458:}
        -: 2459:
        -: 2460:
        -: 2461:
        -: 2462:///////////////////////////// SparseMat_ ////////////////////////////
        -: 2463:
        -: 2464:template<typename _Tp> inline
        -: 2465:SparseMat_<_Tp>::SparseMat_()
        -: 2466:{
        -: 2467:    flags = MAGIC_VAL + traits::Type<_Tp>::value;
        -: 2468:}
        -: 2469:
        -: 2470:template<typename _Tp> inline
        -: 2471:SparseMat_<_Tp>::SparseMat_(int _dims, const int* _sizes)
        -: 2472:    : SparseMat(_dims, _sizes, traits::Type<_Tp>::value)
        -: 2473:{}
        -: 2474:
        -: 2475:template<typename _Tp> inline
        -: 2476:SparseMat_<_Tp>::SparseMat_(const SparseMat& m)
        -: 2477:{
        -: 2478:    if( m.type() == traits::Type<_Tp>::value )
        -: 2479:        *this = (const SparseMat_<_Tp>&)m;
        -: 2480:    else
        -: 2481:        m.convertTo(*this, traits::Type<_Tp>::value);
        -: 2482:}
        -: 2483:
        -: 2484:template<typename _Tp> inline
        -: 2485:SparseMat_<_Tp>::SparseMat_(const SparseMat_<_Tp>& m)
        -: 2486:{
        -: 2487:    this->flags = m.flags;
        -: 2488:    this->hdr = m.hdr;
        -: 2489:    if( this->hdr )
        -: 2490:        CV_XADD(&this->hdr->refcount, 1);
        -: 2491:}
        -: 2492:
        -: 2493:template<typename _Tp> inline
        -: 2494:SparseMat_<_Tp>::SparseMat_(const Mat& m)
        -: 2495:{
        -: 2496:    SparseMat sm(m);
        -: 2497:    *this = sm;
        -: 2498:}
        -: 2499:
        -: 2500:template<typename _Tp> inline
        -: 2501:SparseMat_<_Tp>& SparseMat_<_Tp>::operator = (const SparseMat_<_Tp>& m)
        -: 2502:{
        -: 2503:    if( this != &m )
        -: 2504:    {
        -: 2505:        if( m.hdr ) CV_XADD(&m.hdr->refcount, 1);
        -: 2506:        release();
        -: 2507:        flags = m.flags;
        -: 2508:        hdr = m.hdr;
        -: 2509:    }
        -: 2510:    return *this;
        -: 2511:}
        -: 2512:
        -: 2513:template<typename _Tp> inline
        -: 2514:SparseMat_<_Tp>& SparseMat_<_Tp>::operator = (const SparseMat& m)
        -: 2515:{
        -: 2516:    if( m.type() == traits::Type<_Tp>::value )
        -: 2517:        return (*this = (const SparseMat_<_Tp>&)m);
        -: 2518:    m.convertTo(*this, traits::Type<_Tp>::value);
        -: 2519:    return *this;
        -: 2520:}
        -: 2521:
        -: 2522:template<typename _Tp> inline
        -: 2523:SparseMat_<_Tp>& SparseMat_<_Tp>::operator = (const Mat& m)
        -: 2524:{
        -: 2525:    return (*this = SparseMat(m));
        -: 2526:}
        -: 2527:
        -: 2528:template<typename _Tp> inline
        -: 2529:SparseMat_<_Tp> SparseMat_<_Tp>::clone() const
        -: 2530:{
        -: 2531:    SparseMat_<_Tp> m;
        -: 2532:    this->copyTo(m);
        -: 2533:    return m;
        -: 2534:}
        -: 2535:
        -: 2536:template<typename _Tp> inline
        -: 2537:void SparseMat_<_Tp>::create(int _dims, const int* _sizes)
        -: 2538:{
        -: 2539:    SparseMat::create(_dims, _sizes, traits::Type<_Tp>::value);
        -: 2540:}
        -: 2541:
        -: 2542:template<typename _Tp> inline
        -: 2543:int SparseMat_<_Tp>::type() const
        -: 2544:{
        -: 2545:    return traits::Type<_Tp>::value;
        -: 2546:}
        -: 2547:
        -: 2548:template<typename _Tp> inline
        -: 2549:int SparseMat_<_Tp>::depth() const
        -: 2550:{
        -: 2551:    return traits::Depth<_Tp>::value;
        -: 2552:}
        -: 2553:
        -: 2554:template<typename _Tp> inline
        -: 2555:int SparseMat_<_Tp>::channels() const
        -: 2556:{
        -: 2557:    return DataType<_Tp>::channels;
        -: 2558:}
        -: 2559:
        -: 2560:template<typename _Tp> inline
        -: 2561:_Tp& SparseMat_<_Tp>::ref(int i0, size_t* hashval)
        -: 2562:{
        -: 2563:    return SparseMat::ref<_Tp>(i0, hashval);
        -: 2564:}
        -: 2565:
        -: 2566:template<typename _Tp> inline
        -: 2567:_Tp SparseMat_<_Tp>::operator()(int i0, size_t* hashval) const
        -: 2568:{
        -: 2569:    return SparseMat::value<_Tp>(i0, hashval);
        -: 2570:}
        -: 2571:
        -: 2572:template<typename _Tp> inline
        -: 2573:_Tp& SparseMat_<_Tp>::ref(int i0, int i1, size_t* hashval)
        -: 2574:{
        -: 2575:    return SparseMat::ref<_Tp>(i0, i1, hashval);
        -: 2576:}
        -: 2577:
        -: 2578:template<typename _Tp> inline
        -: 2579:_Tp SparseMat_<_Tp>::operator()(int i0, int i1, size_t* hashval) const
        -: 2580:{
        -: 2581:    return SparseMat::value<_Tp>(i0, i1, hashval);
        -: 2582:}
        -: 2583:
        -: 2584:template<typename _Tp> inline
        -: 2585:_Tp& SparseMat_<_Tp>::ref(int i0, int i1, int i2, size_t* hashval)
        -: 2586:{
        -: 2587:    return SparseMat::ref<_Tp>(i0, i1, i2, hashval);
        -: 2588:}
        -: 2589:
        -: 2590:template<typename _Tp> inline
        -: 2591:_Tp SparseMat_<_Tp>::operator()(int i0, int i1, int i2, size_t* hashval) const
        -: 2592:{
        -: 2593:    return SparseMat::value<_Tp>(i0, i1, i2, hashval);
        -: 2594:}
        -: 2595:
        -: 2596:template<typename _Tp> inline
        -: 2597:_Tp& SparseMat_<_Tp>::ref(const int* idx, size_t* hashval)
        -: 2598:{
        -: 2599:    return SparseMat::ref<_Tp>(idx, hashval);
        -: 2600:}
        -: 2601:
        -: 2602:template<typename _Tp> inline
        -: 2603:_Tp SparseMat_<_Tp>::operator()(const int* idx, size_t* hashval) const
        -: 2604:{
        -: 2605:    return SparseMat::value<_Tp>(idx, hashval);
        -: 2606:}
        -: 2607:
        -: 2608:template<typename _Tp> inline
        -: 2609:SparseMatIterator_<_Tp> SparseMat_<_Tp>::begin()
        -: 2610:{
        -: 2611:    return SparseMatIterator_<_Tp>(this);
        -: 2612:}
        -: 2613:
        -: 2614:template<typename _Tp> inline
        -: 2615:SparseMatConstIterator_<_Tp> SparseMat_<_Tp>::begin() const
        -: 2616:{
        -: 2617:    return SparseMatConstIterator_<_Tp>(this);
        -: 2618:}
        -: 2619:
        -: 2620:template<typename _Tp> inline
        -: 2621:SparseMatIterator_<_Tp> SparseMat_<_Tp>::end()
        -: 2622:{
        -: 2623:    SparseMatIterator_<_Tp> it(this);
        -: 2624:    it.seekEnd();
        -: 2625:    return it;
        -: 2626:}
        -: 2627:
        -: 2628:template<typename _Tp> inline
        -: 2629:SparseMatConstIterator_<_Tp> SparseMat_<_Tp>::end() const
        -: 2630:{
        -: 2631:    SparseMatConstIterator_<_Tp> it(this);
        -: 2632:    it.seekEnd();
        -: 2633:    return it;
        -: 2634:}
        -: 2635:
        -: 2636:
        -: 2637:
        -: 2638:////////////////////////// MatConstIterator /////////////////////////
        -: 2639:
        -: 2640:inline
        -: 2641:MatConstIterator::MatConstIterator()
        -: 2642:    : m(0), elemSize(0), ptr(0), sliceStart(0), sliceEnd(0)
        -: 2643:{}
        -: 2644:
        -: 2645:inline
        -: 2646:MatConstIterator::MatConstIterator(const Mat* _m)
        -: 2647:    : m(_m), elemSize(_m->elemSize()), ptr(0), sliceStart(0), sliceEnd(0)
        -: 2648:{
        -: 2649:    if( m && m->isContinuous() )
        -: 2650:    {
        -: 2651:        CV_Assert(!m->empty());
        -: 2652:        sliceStart = m->ptr();
        -: 2653:        sliceEnd = sliceStart + m->total()*elemSize;
        -: 2654:    }
        -: 2655:    seek((const int*)0);
        -: 2656:}
        -: 2657:
        -: 2658:inline
        -: 2659:MatConstIterator::MatConstIterator(const Mat* _m, int _row, int _col)
        -: 2660:    : m(_m), elemSize(_m->elemSize()), ptr(0), sliceStart(0), sliceEnd(0)
        -: 2661:{
        -: 2662:    CV_Assert(m && m->dims <= 2);
        -: 2663:    if( m->isContinuous() )
        -: 2664:    {
        -: 2665:        CV_Assert(!m->empty());
        -: 2666:        sliceStart = m->ptr();
        -: 2667:        sliceEnd = sliceStart + m->total()*elemSize;
        -: 2668:    }
        -: 2669:    int idx[] = {_row, _col};
        -: 2670:    seek(idx);
        -: 2671:}
        -: 2672:
        -: 2673:inline
        -: 2674:MatConstIterator::MatConstIterator(const Mat* _m, Point _pt)
        -: 2675:    : m(_m), elemSize(_m->elemSize()), ptr(0), sliceStart(0), sliceEnd(0)
        -: 2676:{
        -: 2677:    CV_Assert(m && m->dims <= 2);
        -: 2678:    if( m->isContinuous() )
        -: 2679:    {
        -: 2680:        CV_Assert(!m->empty());
        -: 2681:        sliceStart = m->ptr();
        -: 2682:        sliceEnd = sliceStart + m->total()*elemSize;
        -: 2683:    }
        -: 2684:    int idx[] = {_pt.y, _pt.x};
        -: 2685:    seek(idx);
        -: 2686:}
        -: 2687:
        -: 2688:inline
        -: 2689:MatConstIterator::MatConstIterator(const MatConstIterator& it)
        -: 2690:    : m(it.m), elemSize(it.elemSize), ptr(it.ptr), sliceStart(it.sliceStart), sliceEnd(it.sliceEnd)
        -: 2691:{}
        -: 2692:
        -: 2693:inline
        -: 2694:MatConstIterator& MatConstIterator::operator = (const MatConstIterator& it )
        -: 2695:{
        -: 2696:    m = it.m; elemSize = it.elemSize; ptr = it.ptr;
        -: 2697:    sliceStart = it.sliceStart; sliceEnd = it.sliceEnd;
        -: 2698:    return *this;
        -: 2699:}
        -: 2700:
        -: 2701:inline
        -: 2702:const uchar* MatConstIterator::operator *() const
        -: 2703:{
        -: 2704:    return ptr;
        -: 2705:}
        -: 2706:
        -: 2707:inline MatConstIterator& MatConstIterator::operator += (ptrdiff_t ofs)
        -: 2708:{
        -: 2709:    if( !m || ofs == 0 )
        -: 2710:        return *this;
        -: 2711:    ptrdiff_t ofsb = ofs*elemSize;
        -: 2712:    ptr += ofsb;
        -: 2713:    if( ptr < sliceStart || sliceEnd <= ptr )
        -: 2714:    {
        -: 2715:        ptr -= ofsb;
        -: 2716:        seek(ofs, true);
        -: 2717:    }
        -: 2718:    return *this;
        -: 2719:}
        -: 2720:
        -: 2721:inline
        -: 2722:MatConstIterator& MatConstIterator::operator -= (ptrdiff_t ofs)
        -: 2723:{
        -: 2724:    return (*this += -ofs);
        -: 2725:}
        -: 2726:
        -: 2727:inline
        -: 2728:MatConstIterator& MatConstIterator::operator --()
        -: 2729:{
        -: 2730:    if( m && (ptr -= elemSize) < sliceStart )
        -: 2731:    {
        -: 2732:        ptr += elemSize;
        -: 2733:        seek(-1, true);
        -: 2734:    }
        -: 2735:    return *this;
        -: 2736:}
        -: 2737:
        -: 2738:inline
        -: 2739:MatConstIterator MatConstIterator::operator --(int)
        -: 2740:{
        -: 2741:    MatConstIterator b = *this;
        -: 2742:    *this += -1;
        -: 2743:    return b;
        -: 2744:}
        -: 2745:
        -: 2746:inline
        -: 2747:MatConstIterator& MatConstIterator::operator ++()
        -: 2748:{
        -: 2749:    if( m && (ptr += elemSize) >= sliceEnd )
        -: 2750:    {
        -: 2751:        ptr -= elemSize;
        -: 2752:        seek(1, true);
        -: 2753:    }
        -: 2754:    return *this;
        -: 2755:}
        -: 2756:
        -: 2757:inline MatConstIterator MatConstIterator::operator ++(int)
        -: 2758:{
        -: 2759:    MatConstIterator b = *this;
        -: 2760:    *this += 1;
        -: 2761:    return b;
        -: 2762:}
        -: 2763:
        -: 2764:
        -: 2765:static inline
        -: 2766:bool operator == (const MatConstIterator& a, const MatConstIterator& b)
        -: 2767:{
        -: 2768:    return a.m == b.m && a.ptr == b.ptr;
        -: 2769:}
        -: 2770:
        -: 2771:static inline
        -: 2772:bool operator != (const MatConstIterator& a, const MatConstIterator& b)
        -: 2773:{
        -: 2774:    return !(a == b);
        -: 2775:}
        -: 2776:
        -: 2777:static inline
        -: 2778:bool operator < (const MatConstIterator& a, const MatConstIterator& b)
        -: 2779:{
        -: 2780:    return a.ptr < b.ptr;
        -: 2781:}
        -: 2782:
        -: 2783:static inline
        -: 2784:bool operator > (const MatConstIterator& a, const MatConstIterator& b)
        -: 2785:{
        -: 2786:    return a.ptr > b.ptr;
        -: 2787:}
        -: 2788:
        -: 2789:static inline
        -: 2790:bool operator <= (const MatConstIterator& a, const MatConstIterator& b)
        -: 2791:{
        -: 2792:    return a.ptr <= b.ptr;
        -: 2793:}
        -: 2794:
        -: 2795:static inline
        -: 2796:bool operator >= (const MatConstIterator& a, const MatConstIterator& b)
        -: 2797:{
        -: 2798:    return a.ptr >= b.ptr;
        -: 2799:}
        -: 2800:
        -: 2801:static inline
        -: 2802:ptrdiff_t operator - (const MatConstIterator& b, const MatConstIterator& a)
        -: 2803:{
        -: 2804:    if( a.m != b.m )
        -: 2805:        return ((size_t)(-1) >> 1);
        -: 2806:    if( a.sliceEnd == b.sliceEnd )
        -: 2807:        return (b.ptr - a.ptr)/static_cast<ptrdiff_t>(b.elemSize);
        -: 2808:
        -: 2809:    return b.lpos() - a.lpos();
        -: 2810:}
        -: 2811:
        -: 2812:static inline
        -: 2813:MatConstIterator operator + (const MatConstIterator& a, ptrdiff_t ofs)
        -: 2814:{
        -: 2815:    MatConstIterator b = a;
        -: 2816:    return b += ofs;
        -: 2817:}
        -: 2818:
        -: 2819:static inline
        -: 2820:MatConstIterator operator + (ptrdiff_t ofs, const MatConstIterator& a)
        -: 2821:{
        -: 2822:    MatConstIterator b = a;
        -: 2823:    return b += ofs;
        -: 2824:}
        -: 2825:
        -: 2826:static inline
        -: 2827:MatConstIterator operator - (const MatConstIterator& a, ptrdiff_t ofs)
        -: 2828:{
        -: 2829:    MatConstIterator b = a;
        -: 2830:    return b += -ofs;
        -: 2831:}
        -: 2832:
        -: 2833:
        -: 2834:inline
        -: 2835:const uchar* MatConstIterator::operator [](ptrdiff_t i) const
        -: 2836:{
        -: 2837:    return *(*this + i);
        -: 2838:}
        -: 2839:
        -: 2840:
        -: 2841:
        -: 2842:///////////////////////// MatConstIterator_ /////////////////////////
        -: 2843:
        -: 2844:template<typename _Tp> inline
        -: 2845:MatConstIterator_<_Tp>::MatConstIterator_()
        -: 2846:{}
        -: 2847:
        -: 2848:template<typename _Tp> inline
        -: 2849:MatConstIterator_<_Tp>::MatConstIterator_(const Mat_<_Tp>* _m)
        -: 2850:    : MatConstIterator(_m)
        -: 2851:{}
        -: 2852:
        -: 2853:template<typename _Tp> inline
        -: 2854:MatConstIterator_<_Tp>::MatConstIterator_(const Mat_<_Tp>* _m, int _row, int _col)
        -: 2855:    : MatConstIterator(_m, _row, _col)
        -: 2856:{}
        -: 2857:
        -: 2858:template<typename _Tp> inline
        -: 2859:MatConstIterator_<_Tp>::MatConstIterator_(const Mat_<_Tp>* _m, Point _pt)
        -: 2860:    : MatConstIterator(_m, _pt)
        -: 2861:{}
        -: 2862:
        -: 2863:template<typename _Tp> inline
        -: 2864:MatConstIterator_<_Tp>::MatConstIterator_(const MatConstIterator_& it)
        -: 2865:    : MatConstIterator(it)
        -: 2866:{}
        -: 2867:
        -: 2868:template<typename _Tp> inline
        -: 2869:MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator = (const MatConstIterator_& it )
        -: 2870:{
        -: 2871:    MatConstIterator::operator = (it);
        -: 2872:    return *this;
        -: 2873:}
        -: 2874:
        -: 2875:template<typename _Tp> inline
        -: 2876:const _Tp& MatConstIterator_<_Tp>::operator *() const
        -: 2877:{
        -: 2878:    return *(_Tp*)(this->ptr);
        -: 2879:}
        -: 2880:
        -: 2881:template<typename _Tp> inline
        -: 2882:MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator += (ptrdiff_t ofs)
        -: 2883:{
        -: 2884:    MatConstIterator::operator += (ofs);
        -: 2885:    return *this;
        -: 2886:}
        -: 2887:
        -: 2888:template<typename _Tp> inline
        -: 2889:MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator -= (ptrdiff_t ofs)
        -: 2890:{
        -: 2891:    return (*this += -ofs);
        -: 2892:}
        -: 2893:
        -: 2894:template<typename _Tp> inline
        -: 2895:MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator --()
        -: 2896:{
        -: 2897:    MatConstIterator::operator --();
        -: 2898:    return *this;
        -: 2899:}
        -: 2900:
        -: 2901:template<typename _Tp> inline
        -: 2902:MatConstIterator_<_Tp> MatConstIterator_<_Tp>::operator --(int)
        -: 2903:{
        -: 2904:    MatConstIterator_ b = *this;
        -: 2905:    MatConstIterator::operator --();
        -: 2906:    return b;
        -: 2907:}
        -: 2908:
        -: 2909:template<typename _Tp> inline
        -: 2910:MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator ++()
        -: 2911:{
        -: 2912:    MatConstIterator::operator ++();
        -: 2913:    return *this;
        -: 2914:}
        -: 2915:
        -: 2916:template<typename _Tp> inline
        -: 2917:MatConstIterator_<_Tp> MatConstIterator_<_Tp>::operator ++(int)
        -: 2918:{
        -: 2919:    MatConstIterator_ b = *this;
        -: 2920:    MatConstIterator::operator ++();
        -: 2921:    return b;
        -: 2922:}
        -: 2923:
        -: 2924:
        -: 2925:template<typename _Tp> inline
        -: 2926:Point MatConstIterator_<_Tp>::pos() const
        -: 2927:{
        -: 2928:    if( !m )
        -: 2929:        return Point();
        -: 2930:    CV_DbgAssert( m->dims <= 2 );
        -: 2931:    if( m->isContinuous() )
        -: 2932:    {
        -: 2933:        ptrdiff_t ofs = (const _Tp*)ptr - (const _Tp*)m->data;
        -: 2934:        int y = (int)(ofs / m->cols);
        -: 2935:        int x = (int)(ofs - (ptrdiff_t)y * m->cols);
        -: 2936:        return Point(x, y);
        -: 2937:    }
        -: 2938:    else
        -: 2939:    {
        -: 2940:        ptrdiff_t ofs = (uchar*)ptr - m->data;
        -: 2941:        int y = (int)(ofs / m->step);
        -: 2942:        int x = (int)((ofs - y * m->step)/sizeof(_Tp));
        -: 2943:        return Point(x, y);
        -: 2944:    }
        -: 2945:}
        -: 2946:
        -: 2947:
        -: 2948:template<typename _Tp> static inline
        -: 2949:bool operator == (const MatConstIterator_<_Tp>& a, const MatConstIterator_<_Tp>& b)
        -: 2950:{
        -: 2951:    return a.m == b.m && a.ptr == b.ptr;
        -: 2952:}
        -: 2953:
        -: 2954:template<typename _Tp> static inline
        -: 2955:bool operator != (const MatConstIterator_<_Tp>& a, const MatConstIterator_<_Tp>& b)
        -: 2956:{
        -: 2957:    return a.m != b.m || a.ptr != b.ptr;
        -: 2958:}
        -: 2959:
        -: 2960:template<typename _Tp> static inline
        -: 2961:MatConstIterator_<_Tp> operator + (const MatConstIterator_<_Tp>& a, ptrdiff_t ofs)
        -: 2962:{
        -: 2963:    MatConstIterator t = (const MatConstIterator&)a + ofs;
        -: 2964:    return (MatConstIterator_<_Tp>&)t;
        -: 2965:}
        -: 2966:
        -: 2967:template<typename _Tp> static inline
        -: 2968:MatConstIterator_<_Tp> operator + (ptrdiff_t ofs, const MatConstIterator_<_Tp>& a)
        -: 2969:{
        -: 2970:    MatConstIterator t = (const MatConstIterator&)a + ofs;
        -: 2971:    return (MatConstIterator_<_Tp>&)t;
        -: 2972:}
        -: 2973:
        -: 2974:template<typename _Tp> static inline
        -: 2975:MatConstIterator_<_Tp> operator - (const MatConstIterator_<_Tp>& a, ptrdiff_t ofs)
        -: 2976:{
        -: 2977:    MatConstIterator t = (const MatConstIterator&)a - ofs;
        -: 2978:    return (MatConstIterator_<_Tp>&)t;
        -: 2979:}
        -: 2980:
        -: 2981:template<typename _Tp> inline
        -: 2982:const _Tp& MatConstIterator_<_Tp>::operator [](ptrdiff_t i) const
        -: 2983:{
        -: 2984:    return *(_Tp*)MatConstIterator::operator [](i);
        -: 2985:}
        -: 2986:
        -: 2987:
        -: 2988:
        -: 2989://////////////////////////// MatIterator_ ///////////////////////////
        -: 2990:
        -: 2991:template<typename _Tp> inline
        -: 2992:MatIterator_<_Tp>::MatIterator_()
        -: 2993:    : MatConstIterator_<_Tp>()
        -: 2994:{}
        -: 2995:
        -: 2996:template<typename _Tp> inline
        -: 2997:MatIterator_<_Tp>::MatIterator_(Mat_<_Tp>* _m)
        -: 2998:    : MatConstIterator_<_Tp>(_m)
        -: 2999:{}
        -: 3000:
        -: 3001:template<typename _Tp> inline
        -: 3002:MatIterator_<_Tp>::MatIterator_(Mat_<_Tp>* _m, int _row, int _col)
        -: 3003:    : MatConstIterator_<_Tp>(_m, _row, _col)
        -: 3004:{}
        -: 3005:
        -: 3006:template<typename _Tp> inline
        -: 3007:MatIterator_<_Tp>::MatIterator_(Mat_<_Tp>* _m, Point _pt)
        -: 3008:    : MatConstIterator_<_Tp>(_m, _pt)
        -: 3009:{}
        -: 3010:
        -: 3011:template<typename _Tp> inline
        -: 3012:MatIterator_<_Tp>::MatIterator_(Mat_<_Tp>* _m, const int* _idx)
        -: 3013:    : MatConstIterator_<_Tp>(_m, _idx)
        -: 3014:{}
        -: 3015:
        -: 3016:template<typename _Tp> inline
        -: 3017:MatIterator_<_Tp>::MatIterator_(const MatIterator_& it)
        -: 3018:    : MatConstIterator_<_Tp>(it)
        -: 3019:{}
        -: 3020:
        -: 3021:template<typename _Tp> inline
        -: 3022:MatIterator_<_Tp>& MatIterator_<_Tp>::operator = (const MatIterator_<_Tp>& it )
        -: 3023:{
        -: 3024:    MatConstIterator::operator = (it);
        -: 3025:    return *this;
        -: 3026:}
        -: 3027:
        -: 3028:template<typename _Tp> inline
        -: 3029:_Tp& MatIterator_<_Tp>::operator *() const
        -: 3030:{
        -: 3031:    return *(_Tp*)(this->ptr);
        -: 3032:}
        -: 3033:
        -: 3034:template<typename _Tp> inline
        -: 3035:MatIterator_<_Tp>& MatIterator_<_Tp>::operator += (ptrdiff_t ofs)
        -: 3036:{
        -: 3037:    MatConstIterator::operator += (ofs);
        -: 3038:    return *this;
        -: 3039:}
        -: 3040:
        -: 3041:template<typename _Tp> inline
        -: 3042:MatIterator_<_Tp>& MatIterator_<_Tp>::operator -= (ptrdiff_t ofs)
        -: 3043:{
        -: 3044:    MatConstIterator::operator += (-ofs);
        -: 3045:    return *this;
        -: 3046:}
        -: 3047:
        -: 3048:template<typename _Tp> inline
        -: 3049:MatIterator_<_Tp>& MatIterator_<_Tp>::operator --()
        -: 3050:{
        -: 3051:    MatConstIterator::operator --();
        -: 3052:    return *this;
        -: 3053:}
        -: 3054:
        -: 3055:template<typename _Tp> inline
        -: 3056:MatIterator_<_Tp> MatIterator_<_Tp>::operator --(int)
        -: 3057:{
        -: 3058:    MatIterator_ b = *this;
        -: 3059:    MatConstIterator::operator --();
        -: 3060:    return b;
        -: 3061:}
        -: 3062:
        -: 3063:template<typename _Tp> inline
        -: 3064:MatIterator_<_Tp>& MatIterator_<_Tp>::operator ++()
        -: 3065:{
        -: 3066:    MatConstIterator::operator ++();
        -: 3067:    return *this;
        -: 3068:}
        -: 3069:
        -: 3070:template<typename _Tp> inline
        -: 3071:MatIterator_<_Tp> MatIterator_<_Tp>::operator ++(int)
        -: 3072:{
        -: 3073:    MatIterator_ b = *this;
        -: 3074:    MatConstIterator::operator ++();
        -: 3075:    return b;
        -: 3076:}
        -: 3077:
        -: 3078:template<typename _Tp> inline
        -: 3079:_Tp& MatIterator_<_Tp>::operator [](ptrdiff_t i) const
        -: 3080:{
        -: 3081:    return *(*this + i);
        -: 3082:}
        -: 3083:
        -: 3084:
        -: 3085:template<typename _Tp> static inline
        -: 3086:bool operator == (const MatIterator_<_Tp>& a, const MatIterator_<_Tp>& b)
        -: 3087:{
        -: 3088:    return a.m == b.m && a.ptr == b.ptr;
        -: 3089:}
        -: 3090:
        -: 3091:template<typename _Tp> static inline
        -: 3092:bool operator != (const MatIterator_<_Tp>& a, const MatIterator_<_Tp>& b)
        -: 3093:{
        -: 3094:    return a.m != b.m || a.ptr != b.ptr;
        -: 3095:}
        -: 3096:
        -: 3097:template<typename _Tp> static inline
        -: 3098:MatIterator_<_Tp> operator + (const MatIterator_<_Tp>& a, ptrdiff_t ofs)
        -: 3099:{
        -: 3100:    MatConstIterator t = (const MatConstIterator&)a + ofs;
        -: 3101:    return (MatIterator_<_Tp>&)t;
        -: 3102:}
        -: 3103:
        -: 3104:template<typename _Tp> static inline
        -: 3105:MatIterator_<_Tp> operator + (ptrdiff_t ofs, const MatIterator_<_Tp>& a)
        -: 3106:{
        -: 3107:    MatConstIterator t = (const MatConstIterator&)a + ofs;
        -: 3108:    return (MatIterator_<_Tp>&)t;
        -: 3109:}
        -: 3110:
        -: 3111:template<typename _Tp> static inline
        -: 3112:MatIterator_<_Tp> operator - (const MatIterator_<_Tp>& a, ptrdiff_t ofs)
        -: 3113:{
        -: 3114:    MatConstIterator t = (const MatConstIterator&)a - ofs;
        -: 3115:    return (MatIterator_<_Tp>&)t;
        -: 3116:}
        -: 3117:
        -: 3118:
        -: 3119:
        -: 3120://///////////////////// SparseMatConstIterator //////////////////////
        -: 3121:
        -: 3122:inline
        -: 3123:SparseMatConstIterator::SparseMatConstIterator()
        -: 3124:    : m(0), hashidx(0), ptr(0)
        -: 3125:{}
        -: 3126:
        -: 3127:inline
        -: 3128:SparseMatConstIterator::SparseMatConstIterator(const SparseMatConstIterator& it)
        -: 3129:    : m(it.m), hashidx(it.hashidx), ptr(it.ptr)
        -: 3130:{}
        -: 3131:
        -: 3132:inline SparseMatConstIterator& SparseMatConstIterator::operator = (const SparseMatConstIterator& it)
        -: 3133:{
        -: 3134:    if( this != &it )
        -: 3135:    {
        -: 3136:        m = it.m;
        -: 3137:        hashidx = it.hashidx;
        -: 3138:        ptr = it.ptr;
        -: 3139:    }
        -: 3140:    return *this;
        -: 3141:}
        -: 3142:
        -: 3143:template<typename _Tp> inline
        -: 3144:const _Tp& SparseMatConstIterator::value() const
        -: 3145:{
        -: 3146:    return *(const _Tp*)ptr;
        -: 3147:}
        -: 3148:
        -: 3149:inline
        -: 3150:const SparseMat::Node* SparseMatConstIterator::node() const
        -: 3151:{
        -: 3152:    return (ptr && m && m->hdr) ? (const SparseMat::Node*)(const void*)(ptr - m->hdr->valueOffset) : 0;
        -: 3153:}
        -: 3154:
        -: 3155:inline
        -: 3156:SparseMatConstIterator SparseMatConstIterator::operator ++(int)
        -: 3157:{
        -: 3158:    SparseMatConstIterator it = *this;
        -: 3159:    ++*this;
        -: 3160:    return it;
        -: 3161:}
        -: 3162:
        -: 3163:inline
        -: 3164:void SparseMatConstIterator::seekEnd()
        -: 3165:{
        -: 3166:    if( m && m->hdr )
        -: 3167:    {
        -: 3168:        hashidx = m->hdr->hashtab.size();
        -: 3169:        ptr = 0;
        -: 3170:    }
        -: 3171:}
        -: 3172:
        -: 3173:
        -: 3174:static inline
        -: 3175:bool operator == (const SparseMatConstIterator& it1, const SparseMatConstIterator& it2)
        -: 3176:{
        -: 3177:    return it1.m == it2.m && it1.ptr == it2.ptr;
        -: 3178:}
        -: 3179:
        -: 3180:static inline
        -: 3181:bool operator != (const SparseMatConstIterator& it1, const SparseMatConstIterator& it2)
        -: 3182:{
        -: 3183:    return !(it1 == it2);
        -: 3184:}
        -: 3185:
        -: 3186:
        -: 3187:
        -: 3188:///////////////////////// SparseMatIterator /////////////////////////
        -: 3189:
        -: 3190:inline
        -: 3191:SparseMatIterator::SparseMatIterator()
        -: 3192:{}
        -: 3193:
        -: 3194:inline
        -: 3195:SparseMatIterator::SparseMatIterator(SparseMat* _m)
        -: 3196:    : SparseMatConstIterator(_m)
        -: 3197:{}
        -: 3198:
        -: 3199:inline
        -: 3200:SparseMatIterator::SparseMatIterator(const SparseMatIterator& it)
        -: 3201:    : SparseMatConstIterator(it)
        -: 3202:{}
        -: 3203:
        -: 3204:inline
        -: 3205:SparseMatIterator& SparseMatIterator::operator = (const SparseMatIterator& it)
        -: 3206:{
        -: 3207:    (SparseMatConstIterator&)*this = it;
        -: 3208:    return *this;
        -: 3209:}
        -: 3210:
        -: 3211:template<typename _Tp> inline
        -: 3212:_Tp& SparseMatIterator::value() const
        -: 3213:{
        -: 3214:    return *(_Tp*)ptr;
        -: 3215:}
        -: 3216:
        -: 3217:inline
        -: 3218:SparseMat::Node* SparseMatIterator::node() const
        -: 3219:{
        -: 3220:    return (SparseMat::Node*)SparseMatConstIterator::node();
        -: 3221:}
        -: 3222:
        -: 3223:inline
        -: 3224:SparseMatIterator& SparseMatIterator::operator ++()
        -: 3225:{
        -: 3226:    SparseMatConstIterator::operator ++();
        -: 3227:    return *this;
        -: 3228:}
        -: 3229:
        -: 3230:inline
        -: 3231:SparseMatIterator SparseMatIterator::operator ++(int)
        -: 3232:{
        -: 3233:    SparseMatIterator it = *this;
        -: 3234:    ++*this;
        -: 3235:    return it;
        -: 3236:}
        -: 3237:
        -: 3238:
        -: 3239:
        -: 3240:////////////////////// SparseMatConstIterator_ //////////////////////
        -: 3241:
        -: 3242:template<typename _Tp> inline
        -: 3243:SparseMatConstIterator_<_Tp>::SparseMatConstIterator_()
        -: 3244:{}
        -: 3245:
        -: 3246:template<typename _Tp> inline
        -: 3247:SparseMatConstIterator_<_Tp>::SparseMatConstIterator_(const SparseMat_<_Tp>* _m)
        -: 3248:    : SparseMatConstIterator(_m)
        -: 3249:{}
        -: 3250:
        -: 3251:template<typename _Tp> inline
        -: 3252:SparseMatConstIterator_<_Tp>::SparseMatConstIterator_(const SparseMat* _m)
        -: 3253:    : SparseMatConstIterator(_m)
        -: 3254:{
        -: 3255:    CV_Assert( _m->type() == traits::Type<_Tp>::value );
        -: 3256:}
        -: 3257:
        -: 3258:template<typename _Tp> inline
        -: 3259:SparseMatConstIterator_<_Tp>::SparseMatConstIterator_(const SparseMatConstIterator_<_Tp>& it)
        -: 3260:    : SparseMatConstIterator(it)
        -: 3261:{}
        -: 3262:
        -: 3263:template<typename _Tp> inline
        -: 3264:SparseMatConstIterator_<_Tp>& SparseMatConstIterator_<_Tp>::operator = (const SparseMatConstIterator_<_Tp>& it)
        -: 3265:{
        -: 3266:    return reinterpret_cast<SparseMatConstIterator_<_Tp>&>
        -: 3267:         (*reinterpret_cast<SparseMatConstIterator*>(this) =
        -: 3268:           reinterpret_cast<const SparseMatConstIterator&>(it));
        -: 3269:}
        -: 3270:
        -: 3271:template<typename _Tp> inline
        -: 3272:const _Tp& SparseMatConstIterator_<_Tp>::operator *() const
        -: 3273:{
        -: 3274:    return *(const _Tp*)this->ptr;
        -: 3275:}
        -: 3276:
        -: 3277:template<typename _Tp> inline
        -: 3278:SparseMatConstIterator_<_Tp>& SparseMatConstIterator_<_Tp>::operator ++()
        -: 3279:{
        -: 3280:    SparseMatConstIterator::operator ++();
        -: 3281:    return *this;
        -: 3282:}
        -: 3283:
        -: 3284:template<typename _Tp> inline
        -: 3285:SparseMatConstIterator_<_Tp> SparseMatConstIterator_<_Tp>::operator ++(int)
        -: 3286:{
        -: 3287:    SparseMatConstIterator_<_Tp> it = *this;
        -: 3288:    SparseMatConstIterator::operator ++();
        -: 3289:    return it;
        -: 3290:}
        -: 3291:
        -: 3292:
        -: 3293:
        -: 3294:///////////////////////// SparseMatIterator_ ////////////////////////
        -: 3295:
        -: 3296:template<typename _Tp> inline
        -: 3297:SparseMatIterator_<_Tp>::SparseMatIterator_()
        -: 3298:{}
        -: 3299:
        -: 3300:template<typename _Tp> inline
        -: 3301:SparseMatIterator_<_Tp>::SparseMatIterator_(SparseMat_<_Tp>* _m)
        -: 3302:    : SparseMatConstIterator_<_Tp>(_m)
        -: 3303:{}
        -: 3304:
        -: 3305:template<typename _Tp> inline
        -: 3306:SparseMatIterator_<_Tp>::SparseMatIterator_(SparseMat* _m)
        -: 3307:    : SparseMatConstIterator_<_Tp>(_m)
        -: 3308:{}
        -: 3309:
        -: 3310:template<typename _Tp> inline
        -: 3311:SparseMatIterator_<_Tp>::SparseMatIterator_(const SparseMatIterator_<_Tp>& it)
        -: 3312:    : SparseMatConstIterator_<_Tp>(it)
        -: 3313:{}
        -: 3314:
        -: 3315:template<typename _Tp> inline
        -: 3316:SparseMatIterator_<_Tp>& SparseMatIterator_<_Tp>::operator = (const SparseMatIterator_<_Tp>& it)
        -: 3317:{
        -: 3318:    return reinterpret_cast<SparseMatIterator_<_Tp>&>
        -: 3319:         (*reinterpret_cast<SparseMatConstIterator*>(this) =
        -: 3320:           reinterpret_cast<const SparseMatConstIterator&>(it));
        -: 3321:}
        -: 3322:
        -: 3323:template<typename _Tp> inline
        -: 3324:_Tp& SparseMatIterator_<_Tp>::operator *() const
        -: 3325:{
        -: 3326:    return *(_Tp*)this->ptr;
        -: 3327:}
        -: 3328:
        -: 3329:template<typename _Tp> inline
        -: 3330:SparseMatIterator_<_Tp>& SparseMatIterator_<_Tp>::operator ++()
        -: 3331:{
        -: 3332:    SparseMatConstIterator::operator ++();
        -: 3333:    return *this;
        -: 3334:}
        -: 3335:
        -: 3336:template<typename _Tp> inline
        -: 3337:SparseMatIterator_<_Tp> SparseMatIterator_<_Tp>::operator ++(int)
        -: 3338:{
        -: 3339:    SparseMatIterator_<_Tp> it = *this;
        -: 3340:    SparseMatConstIterator::operator ++();
        -: 3341:    return it;
        -: 3342:}
        -: 3343:
        -: 3344:
        -: 3345:
        -: 3346://////////////////////// MatCommaInitializer_ ///////////////////////
        -: 3347:
        -: 3348:template<typename _Tp> inline
        -: 3349:MatCommaInitializer_<_Tp>::MatCommaInitializer_(Mat_<_Tp>* _m)
        -: 3350:    : it(_m)
        -: 3351:{}
        -: 3352:
        -: 3353:template<typename _Tp> template<typename T2> inline
        -: 3354:MatCommaInitializer_<_Tp>& MatCommaInitializer_<_Tp>::operator , (T2 v)
        -: 3355:{
        -: 3356:    CV_DbgAssert( this->it < ((const Mat_<_Tp>*)this->it.m)->end() );
        -: 3357:    *this->it = _Tp(v);
        -: 3358:    ++this->it;
        -: 3359:    return *this;
        -: 3360:}
        -: 3361:
        -: 3362:template<typename _Tp> inline
        -: 3363:MatCommaInitializer_<_Tp>::operator Mat_<_Tp>() const
        -: 3364:{
        -: 3365:    CV_DbgAssert( this->it == ((const Mat_<_Tp>*)this->it.m)->end() );
        -: 3366:    return Mat_<_Tp>(*this->it.m);
        -: 3367:}
        -: 3368:
        -: 3369:
        -: 3370:template<typename _Tp, typename T2> static inline
        -: 3371:MatCommaInitializer_<_Tp> operator << (const Mat_<_Tp>& m, T2 val)
        -: 3372:{
        -: 3373:    MatCommaInitializer_<_Tp> commaInitializer((Mat_<_Tp>*)&m);
        -: 3374:    return (commaInitializer, val);
        -: 3375:}
        -: 3376:
        -: 3377:
        -: 3378:
        -: 3379:///////////////////////// Matrix Expressions ////////////////////////
        -: 3380:
        -: 3381:inline
        -: 3382:Mat& Mat::operator = (const MatExpr& e)
        -: 3383:{
        -: 3384:    e.op->assign(e, *this);
        -: 3385:    return *this;
        -: 3386:}
        -: 3387:
        -: 3388:template<typename _Tp> inline
        -: 3389:Mat_<_Tp>::Mat_(const MatExpr& e)
        -: 3390:{
        -: 3391:    e.op->assign(e, *this, traits::Type<_Tp>::value);
        -: 3392:}
        -: 3393:
        -: 3394:template<typename _Tp> inline
        -: 3395:Mat_<_Tp>& Mat_<_Tp>::operator = (const MatExpr& e)
        -: 3396:{
        -: 3397:    e.op->assign(e, *this, traits::Type<_Tp>::value);
        -: 3398:    return *this;
        -: 3399:}
        -: 3400:
        -: 3401:template<typename _Tp> inline
        -: 3402:MatExpr Mat_<_Tp>::zeros(int rows, int cols)
        -: 3403:{
        -: 3404:    return Mat::zeros(rows, cols, traits::Type<_Tp>::value);
        -: 3405:}
        -: 3406:
        -: 3407:template<typename _Tp> inline
        -: 3408:MatExpr Mat_<_Tp>::zeros(Size sz)
        -: 3409:{
        -: 3410:    return Mat::zeros(sz, traits::Type<_Tp>::value);
        -: 3411:}
        -: 3412:
        -: 3413:template<typename _Tp> inline
        -: 3414:MatExpr Mat_<_Tp>::ones(int rows, int cols)
        -: 3415:{
        -: 3416:    return Mat::ones(rows, cols, traits::Type<_Tp>::value);
        -: 3417:}
        -: 3418:
        -: 3419:template<typename _Tp> inline
        -: 3420:MatExpr Mat_<_Tp>::ones(Size sz)
        -: 3421:{
        -: 3422:    return Mat::ones(sz, traits::Type<_Tp>::value);
        -: 3423:}
        -: 3424:
        -: 3425:template<typename _Tp> inline
        -: 3426:MatExpr Mat_<_Tp>::eye(int rows, int cols)
        -: 3427:{
        -: 3428:    return Mat::eye(rows, cols, traits::Type<_Tp>::value);
        -: 3429:}
        -: 3430:
        -: 3431:template<typename _Tp> inline
        -: 3432:MatExpr Mat_<_Tp>::eye(Size sz)
        -: 3433:{
        -: 3434:    return Mat::eye(sz, traits::Type<_Tp>::value);
        -: 3435:}
        -: 3436:
        -: 3437:inline
        -: 3438:MatExpr::MatExpr()
        -: 3439:    : op(0), flags(0), a(Mat()), b(Mat()), c(Mat()), alpha(0), beta(0), s()
        -: 3440:{}
        -: 3441:
        -: 3442:inline
        -: 3443:MatExpr::MatExpr(const MatOp* _op, int _flags, const Mat& _a, const Mat& _b,
        -: 3444:                 const Mat& _c, double _alpha, double _beta, const Scalar& _s)
        -: 3445:    : op(_op), flags(_flags), a(_a), b(_b), c(_c), alpha(_alpha), beta(_beta), s(_s)
        -: 3446:{}
        -: 3447:
        -: 3448:inline
        1: 3449:MatExpr::operator Mat() const
        1: 3449-block  0
        -: 3450:{
        1: 3451:    Mat m;
        1: 3452:    op->assign(*this, m);
        1: 3452-block  0
        1: 3453:    return m;
        1: 3454:}
        1: 3454-block  0
    $$$$$: 3454-block  1
    $$$$$: 3454-block  2
        1: 3454-block  3
    $$$$$: 3454-block  4
        -: 3455:
        -: 3456:template<typename _Tp> inline
        -: 3457:MatExpr::operator Mat_<_Tp>() const
        -: 3458:{
        -: 3459:    Mat_<_Tp> m;
        -: 3460:    op->assign(*this, m, traits::Type<_Tp>::value);
        -: 3461:    return m;
        -: 3462:}
        -: 3463:
        -: 3464:
        -: 3465:template<typename _Tp> static inline
        -: 3466:MatExpr min(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
        -: 3467:{
        -: 3468:    return cv::min((const Mat&)a, (const Mat&)b);
        -: 3469:}
        -: 3470:
        -: 3471:template<typename _Tp> static inline
        -: 3472:MatExpr min(const Mat_<_Tp>& a, double s)
        -: 3473:{
        -: 3474:    return cv::min((const Mat&)a, s);
        -: 3475:}
        -: 3476:
        -: 3477:template<typename _Tp> static inline
        -: 3478:MatExpr min(double s, const Mat_<_Tp>& a)
        -: 3479:{
        -: 3480:    return cv::min((const Mat&)a, s);
        -: 3481:}
        -: 3482:
        -: 3483:template<typename _Tp> static inline
        -: 3484:MatExpr max(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
        -: 3485:{
        -: 3486:    return cv::max((const Mat&)a, (const Mat&)b);
        -: 3487:}
        -: 3488:
        -: 3489:template<typename _Tp> static inline
        -: 3490:MatExpr max(const Mat_<_Tp>& a, double s)
        -: 3491:{
        -: 3492:    return cv::max((const Mat&)a, s);
        -: 3493:}
        -: 3494:
        -: 3495:template<typename _Tp> static inline
        -: 3496:MatExpr max(double s, const Mat_<_Tp>& a)
        -: 3497:{
        -: 3498:    return cv::max((const Mat&)a, s);
        -: 3499:}
        -: 3500:
        -: 3501:template<typename _Tp> static inline
        -: 3502:MatExpr abs(const Mat_<_Tp>& m)
        -: 3503:{
        -: 3504:    return cv::abs((const Mat&)m);
        -: 3505:}
        -: 3506:
        -: 3507:
        -: 3508:static inline
        -: 3509:Mat& operator += (Mat& a, const MatExpr& b)
        -: 3510:{
        -: 3511:    b.op->augAssignAdd(b, a);
        -: 3512:    return a;
        -: 3513:}
        -: 3514:
        -: 3515:static inline
        -: 3516:const Mat& operator += (const Mat& a, const MatExpr& b)
        -: 3517:{
        -: 3518:    b.op->augAssignAdd(b, (Mat&)a);
        -: 3519:    return a;
        -: 3520:}
        -: 3521:
        -: 3522:template<typename _Tp> static inline
        -: 3523:Mat_<_Tp>& operator += (Mat_<_Tp>& a, const MatExpr& b)
        -: 3524:{
        -: 3525:    b.op->augAssignAdd(b, a);
        -: 3526:    return a;
        -: 3527:}
        -: 3528:
        -: 3529:template<typename _Tp> static inline
        -: 3530:const Mat_<_Tp>& operator += (const Mat_<_Tp>& a, const MatExpr& b)
        -: 3531:{
        -: 3532:    b.op->augAssignAdd(b, (Mat&)a);
        -: 3533:    return a;
        -: 3534:}
        -: 3535:
        -: 3536:static inline
        -: 3537:Mat& operator -= (Mat& a, const MatExpr& b)
        -: 3538:{
        -: 3539:    b.op->augAssignSubtract(b, a);
        -: 3540:    return a;
        -: 3541:}
        -: 3542:
        -: 3543:static inline
        -: 3544:const Mat& operator -= (const Mat& a, const MatExpr& b)
        -: 3545:{
        -: 3546:    b.op->augAssignSubtract(b, (Mat&)a);
        -: 3547:    return a;
        -: 3548:}
        -: 3549:
        -: 3550:template<typename _Tp> static inline
        -: 3551:Mat_<_Tp>& operator -= (Mat_<_Tp>& a, const MatExpr& b)
        -: 3552:{
        -: 3553:    b.op->augAssignSubtract(b, a);
        -: 3554:    return a;
        -: 3555:}
        -: 3556:
        -: 3557:template<typename _Tp> static inline
        -: 3558:const Mat_<_Tp>& operator -= (const Mat_<_Tp>& a, const MatExpr& b)
        -: 3559:{
        -: 3560:    b.op->augAssignSubtract(b, (Mat&)a);
        -: 3561:    return a;
        -: 3562:}
        -: 3563:
        -: 3564:static inline
        -: 3565:Mat& operator *= (Mat& a, const MatExpr& b)
        -: 3566:{
        -: 3567:    b.op->augAssignMultiply(b, a);
        -: 3568:    return a;
        -: 3569:}
        -: 3570:
        -: 3571:static inline
        -: 3572:const Mat& operator *= (const Mat& a, const MatExpr& b)
        -: 3573:{
        -: 3574:    b.op->augAssignMultiply(b, (Mat&)a);
        -: 3575:    return a;
        -: 3576:}
        -: 3577:
        -: 3578:template<typename _Tp> static inline
        -: 3579:Mat_<_Tp>& operator *= (Mat_<_Tp>& a, const MatExpr& b)
        -: 3580:{
        -: 3581:    b.op->augAssignMultiply(b, a);
        -: 3582:    return a;
        -: 3583:}
        -: 3584:
        -: 3585:template<typename _Tp> static inline
        -: 3586:const Mat_<_Tp>& operator *= (const Mat_<_Tp>& a, const MatExpr& b)
        -: 3587:{
        -: 3588:    b.op->augAssignMultiply(b, (Mat&)a);
        -: 3589:    return a;
        -: 3590:}
        -: 3591:
        -: 3592:static inline
        -: 3593:Mat& operator /= (Mat& a, const MatExpr& b)
        -: 3594:{
        -: 3595:    b.op->augAssignDivide(b, a);
        -: 3596:    return a;
        -: 3597:}
        -: 3598:
        -: 3599:static inline
        -: 3600:const Mat& operator /= (const Mat& a, const MatExpr& b)
        -: 3601:{
        -: 3602:    b.op->augAssignDivide(b, (Mat&)a);
        -: 3603:    return a;
        -: 3604:}
        -: 3605:
        -: 3606:template<typename _Tp> static inline
        -: 3607:Mat_<_Tp>& operator /= (Mat_<_Tp>& a, const MatExpr& b)
        -: 3608:{
        -: 3609:    b.op->augAssignDivide(b, a);
        -: 3610:    return a;
        -: 3611:}
        -: 3612:
        -: 3613:template<typename _Tp> static inline
        -: 3614:const Mat_<_Tp>& operator /= (const Mat_<_Tp>& a, const MatExpr& b)
        -: 3615:{
        -: 3616:    b.op->augAssignDivide(b, (Mat&)a);
        -: 3617:    return a;
        -: 3618:}
        -: 3619:
        -: 3620:
        -: 3621://////////////////////////////// UMat ////////////////////////////////
        -: 3622:
        -: 3623:inline
        -: 3624:UMat::UMat(UMatUsageFlags _usageFlags)
        -: 3625:: flags(MAGIC_VAL), dims(0), rows(0), cols(0), allocator(0), usageFlags(_usageFlags), u(0), offset(0), size(&rows)
        -: 3626:{}
        -: 3627:
        -: 3628:inline
        -: 3629:UMat::UMat(int _rows, int _cols, int _type, UMatUsageFlags _usageFlags)
        -: 3630:: flags(MAGIC_VAL), dims(0), rows(0), cols(0), allocator(0), usageFlags(_usageFlags), u(0), offset(0), size(&rows)
        -: 3631:{
        -: 3632:    create(_rows, _cols, _type);
        -: 3633:}
        -: 3634:
        -: 3635:inline
        -: 3636:UMat::UMat(int _rows, int _cols, int _type, const Scalar& _s, UMatUsageFlags _usageFlags)
        -: 3637:: flags(MAGIC_VAL), dims(0), rows(0), cols(0), allocator(0), usageFlags(_usageFlags), u(0), offset(0), size(&rows)
        -: 3638:{
        -: 3639:    create(_rows, _cols, _type);
        -: 3640:    *this = _s;
        -: 3641:}
        -: 3642:
        -: 3643:inline
        -: 3644:UMat::UMat(Size _sz, int _type, UMatUsageFlags _usageFlags)
        -: 3645:: flags(MAGIC_VAL), dims(0), rows(0), cols(0), allocator(0), usageFlags(_usageFlags), u(0), offset(0), size(&rows)
        -: 3646:{
        -: 3647:    create( _sz.height, _sz.width, _type );
        -: 3648:}
        -: 3649:
        -: 3650:inline
        -: 3651:UMat::UMat(Size _sz, int _type, const Scalar& _s, UMatUsageFlags _usageFlags)
        -: 3652:: flags(MAGIC_VAL), dims(0), rows(0), cols(0), allocator(0), usageFlags(_usageFlags), u(0), offset(0), size(&rows)
        -: 3653:{
        -: 3654:    create(_sz.height, _sz.width, _type);
        -: 3655:    *this = _s;
        -: 3656:}
        -: 3657:
        -: 3658:inline
        -: 3659:UMat::UMat(int _dims, const int* _sz, int _type, UMatUsageFlags _usageFlags)
        -: 3660:: flags(MAGIC_VAL), dims(0), rows(0), cols(0), allocator(0), usageFlags(_usageFlags), u(0), offset(0), size(&rows)
        -: 3661:{
        -: 3662:    create(_dims, _sz, _type);
        -: 3663:}
        -: 3664:
        -: 3665:inline
        -: 3666:UMat::UMat(int _dims, const int* _sz, int _type, const Scalar& _s, UMatUsageFlags _usageFlags)
        -: 3667:: flags(MAGIC_VAL), dims(0), rows(0), cols(0), allocator(0), usageFlags(_usageFlags), u(0), offset(0), size(&rows)
        -: 3668:{
        -: 3669:    create(_dims, _sz, _type);
        -: 3670:    *this = _s;
        -: 3671:}
        -: 3672:
        -: 3673:inline
        -: 3674:UMat::UMat(const UMat& m)
        -: 3675:: flags(m.flags), dims(m.dims), rows(m.rows), cols(m.cols), allocator(m.allocator),
        -: 3676:  usageFlags(m.usageFlags), u(m.u), offset(m.offset), size(&rows)
        -: 3677:{
        -: 3678:    addref();
        -: 3679:    if( m.dims <= 2 )
        -: 3680:    {
        -: 3681:        step[0] = m.step[0]; step[1] = m.step[1];
        -: 3682:    }
        -: 3683:    else
        -: 3684:    {
        -: 3685:        dims = 0;
        -: 3686:        copySize(m);
        -: 3687:    }
        -: 3688:}
        -: 3689:
        -: 3690:
        -: 3691:template<typename _Tp> inline
        -: 3692:UMat::UMat(const std::vector<_Tp>& vec, bool copyData)
        -: 3693:: flags(MAGIC_VAL + traits::Type<_Tp>::value + CV_MAT_CONT_FLAG), dims(2), rows((int)vec.size()),
        -: 3694:cols(1), allocator(0), usageFlags(USAGE_DEFAULT), u(0), offset(0), size(&rows)
        -: 3695:{
        -: 3696:    if(vec.empty())
        -: 3697:        return;
        -: 3698:    if( !copyData )
        -: 3699:    {
        -: 3700:        // !!!TODO!!!
        -: 3701:        CV_Error(Error::StsNotImplemented, "");
        -: 3702:    }
        -: 3703:    else
        -: 3704:        Mat((int)vec.size(), 1, traits::Type<_Tp>::value, (uchar*)&vec[0]).copyTo(*this);
        -: 3705:}
        -: 3706:
        -: 3707:inline
        -: 3708:UMat& UMat::operator = (const UMat& m)
        -: 3709:{
        -: 3710:    if( this != &m )
        -: 3711:    {
        -: 3712:        const_cast<UMat&>(m).addref();
        -: 3713:        release();
        -: 3714:        flags = m.flags;
        -: 3715:        if( dims <= 2 && m.dims <= 2 )
        -: 3716:        {
        -: 3717:            dims = m.dims;
        -: 3718:            rows = m.rows;
        -: 3719:            cols = m.cols;
        -: 3720:            step[0] = m.step[0];
        -: 3721:            step[1] = m.step[1];
        -: 3722:        }
        -: 3723:        else
        -: 3724:            copySize(m);
        -: 3725:        allocator = m.allocator;
        -: 3726:        if (usageFlags == USAGE_DEFAULT)
        -: 3727:            usageFlags = m.usageFlags;
        -: 3728:        u = m.u;
        -: 3729:        offset = m.offset;
        -: 3730:    }
        -: 3731:    return *this;
        -: 3732:}
        -: 3733:
        -: 3734:inline
        -: 3735:UMat UMat::row(int y) const
        -: 3736:{
        -: 3737:    return UMat(*this, Range(y, y + 1), Range::all());
        -: 3738:}
        -: 3739:
        -: 3740:inline
        -: 3741:UMat UMat::col(int x) const
        -: 3742:{
        -: 3743:    return UMat(*this, Range::all(), Range(x, x + 1));
        -: 3744:}
        -: 3745:
        -: 3746:inline
        -: 3747:UMat UMat::rowRange(int startrow, int endrow) const
        -: 3748:{
        -: 3749:    return UMat(*this, Range(startrow, endrow), Range::all());
        -: 3750:}
        -: 3751:
        -: 3752:inline
        -: 3753:UMat UMat::rowRange(const Range& r) const
        -: 3754:{
        -: 3755:    return UMat(*this, r, Range::all());
        -: 3756:}
        -: 3757:
        -: 3758:inline
        -: 3759:UMat UMat::colRange(int startcol, int endcol) const
        -: 3760:{
        -: 3761:    return UMat(*this, Range::all(), Range(startcol, endcol));
        -: 3762:}
        -: 3763:
        -: 3764:inline
        -: 3765:UMat UMat::colRange(const Range& r) const
        -: 3766:{
        -: 3767:    return UMat(*this, Range::all(), r);
        -: 3768:}
        -: 3769:
        -: 3770:inline
        -: 3771:UMat UMat::clone() const
        -: 3772:{
        -: 3773:    UMat m;
        -: 3774:    copyTo(m);
        -: 3775:    return m;
        -: 3776:}
        -: 3777:
        -: 3778:inline
        -: 3779:void UMat::assignTo( UMat& m, int _type ) const
        -: 3780:{
        -: 3781:    if( _type < 0 )
        -: 3782:        m = *this;
        -: 3783:    else
        -: 3784:        convertTo(m, _type);
        -: 3785:}
        -: 3786:
        -: 3787:inline
        -: 3788:void UMat::create(int _rows, int _cols, int _type, UMatUsageFlags _usageFlags)
        -: 3789:{
        -: 3790:    _type &= TYPE_MASK;
        -: 3791:    if( dims <= 2 && rows == _rows && cols == _cols && type() == _type && u )
        -: 3792:        return;
        -: 3793:    int sz[] = {_rows, _cols};
        -: 3794:    create(2, sz, _type, _usageFlags);
        -: 3795:}
        -: 3796:
        -: 3797:inline
        -: 3798:void UMat::create(Size _sz, int _type, UMatUsageFlags _usageFlags)
        -: 3799:{
        -: 3800:    create(_sz.height, _sz.width, _type, _usageFlags);
        -: 3801:}
        -: 3802:
        -: 3803:inline
        -: 3804:void UMat::addref()
        -: 3805:{
        -: 3806:    if( u )
        -: 3807:        CV_XADD(&(u->urefcount), 1);
        -: 3808:}
        -: 3809:
        -: 3810:inline void UMat::release()
        -: 3811:{
        -: 3812:    if( u && CV_XADD(&(u->urefcount), -1) == 1 )
        -: 3813:        deallocate();
        -: 3814:    for(int i = 0; i < dims; i++)
        -: 3815:        size.p[i] = 0;
        -: 3816:    u = 0;
        -: 3817:}
        -: 3818:
        -: 3819:inline
        -: 3820:UMat UMat::operator()( Range _rowRange, Range _colRange ) const
        -: 3821:{
        -: 3822:    return UMat(*this, _rowRange, _colRange);
        -: 3823:}
        -: 3824:
        -: 3825:inline
        -: 3826:UMat UMat::operator()( const Rect& roi ) const
        -: 3827:{
        -: 3828:    return UMat(*this, roi);
        -: 3829:}
        -: 3830:
        -: 3831:inline
        -: 3832:UMat UMat::operator()(const Range* ranges) const
        -: 3833:{
        -: 3834:    return UMat(*this, ranges);
        -: 3835:}
        -: 3836:
        -: 3837:inline
        -: 3838:UMat UMat::operator()(const std::vector<Range>& ranges) const
        -: 3839:{
        -: 3840:    return UMat(*this, ranges);
        -: 3841:}
        -: 3842:
        -: 3843:inline
        -: 3844:bool UMat::isContinuous() const
        -: 3845:{
        -: 3846:    return (flags & CONTINUOUS_FLAG) != 0;
        -: 3847:}
        -: 3848:
        -: 3849:inline
        -: 3850:bool UMat::isSubmatrix() const
        -: 3851:{
        -: 3852:    return (flags & SUBMATRIX_FLAG) != 0;
        -: 3853:}
        -: 3854:
        -: 3855:inline
        -: 3856:size_t UMat::elemSize() const
        -: 3857:{
        -: 3858:    size_t res = dims > 0 ? step.p[dims - 1] : 0;
        -: 3859:    CV_DbgAssert(res != 0);
        -: 3860:    return res;
        -: 3861:}
        -: 3862:
        -: 3863:inline
        -: 3864:size_t UMat::elemSize1() const
        -: 3865:{
        -: 3866:    return CV_ELEM_SIZE1(flags);
        -: 3867:}
        -: 3868:
        -: 3869:inline
        -: 3870:int UMat::type() const
        -: 3871:{
        -: 3872:    return CV_MAT_TYPE(flags);
        -: 3873:}
        -: 3874:
        -: 3875:inline
        -: 3876:int UMat::depth() const
        -: 3877:{
        -: 3878:    return CV_MAT_DEPTH(flags);
        -: 3879:}
        -: 3880:
        -: 3881:inline
        -: 3882:int UMat::channels() const
        -: 3883:{
        -: 3884:    return CV_MAT_CN(flags);
        -: 3885:}
        -: 3886:
        -: 3887:inline
        -: 3888:size_t UMat::step1(int i) const
        -: 3889:{
        -: 3890:    return step.p[i] / elemSize1();
        -: 3891:}
        -: 3892:
        -: 3893:inline
        -: 3894:bool UMat::empty() const
        -: 3895:{
        -: 3896:    return u == 0 || total() == 0 || dims == 0;
        -: 3897:}
        -: 3898:
        -: 3899:inline
        -: 3900:size_t UMat::total() const
        -: 3901:{
        -: 3902:    if( dims <= 2 )
        -: 3903:        return (size_t)rows * cols;
        -: 3904:    size_t p = 1;
        -: 3905:    for( int i = 0; i < dims; i++ )
        -: 3906:        p *= size[i];
        -: 3907:    return p;
        -: 3908:}
        -: 3909:
        -: 3910:inline
        -: 3911:UMat::UMat(UMat&& m)
        -: 3912:: flags(m.flags), dims(m.dims), rows(m.rows), cols(m.cols), allocator(m.allocator),
        -: 3913:  usageFlags(m.usageFlags), u(m.u), offset(m.offset), size(&rows)
        -: 3914:{
        -: 3915:    if (m.dims <= 2)  // move new step/size info
        -: 3916:    {
        -: 3917:        step[0] = m.step[0];
        -: 3918:        step[1] = m.step[1];
        -: 3919:    }
        -: 3920:    else
        -: 3921:    {
        -: 3922:        CV_DbgAssert(m.step.p != m.step.buf);
        -: 3923:        step.p = m.step.p;
        -: 3924:        size.p = m.size.p;
        -: 3925:        m.step.p = m.step.buf;
        -: 3926:        m.size.p = &m.rows;
        -: 3927:    }
        -: 3928:    m.flags = MAGIC_VAL; m.dims = m.rows = m.cols = 0;
        -: 3929:    m.allocator = NULL;
        -: 3930:    m.u = NULL;
        -: 3931:    m.offset = 0;
        -: 3932:}
        -: 3933:
        -: 3934:inline
        -: 3935:UMat& UMat::operator = (UMat&& m)
        -: 3936:{
        -: 3937:    if (this == &m)
        -: 3938:      return *this;
        -: 3939:    release();
        -: 3940:    flags = m.flags; dims = m.dims; rows = m.rows; cols = m.cols;
        -: 3941:    allocator = m.allocator; usageFlags = m.usageFlags;
        -: 3942:    u = m.u;
        -: 3943:    offset = m.offset;
        -: 3944:    if (step.p != step.buf) // release self step/size
        -: 3945:    {
        -: 3946:        fastFree(step.p);
        -: 3947:        step.p = step.buf;
        -: 3948:        size.p = &rows;
        -: 3949:    }
        -: 3950:    if (m.dims <= 2) // move new step/size info
        -: 3951:    {
        -: 3952:        step[0] = m.step[0];
        -: 3953:        step[1] = m.step[1];
        -: 3954:    }
        -: 3955:    else
        -: 3956:    {
        -: 3957:        CV_DbgAssert(m.step.p != m.step.buf);
        -: 3958:        step.p = m.step.p;
        -: 3959:        size.p = m.size.p;
        -: 3960:        m.step.p = m.step.buf;
        -: 3961:        m.size.p = &m.rows;
        -: 3962:    }
        -: 3963:    m.flags = MAGIC_VAL; m.dims = m.rows = m.cols = 0;
        -: 3964:    m.allocator = NULL;
        -: 3965:    m.u = NULL;
        -: 3966:    m.offset = 0;
        -: 3967:    return *this;
        -: 3968:}
        -: 3969:
        -: 3970:
        -: 3971:inline bool UMatData::hostCopyObsolete() const { return (flags & HOST_COPY_OBSOLETE) != 0; }
        -: 3972:inline bool UMatData::deviceCopyObsolete() const { return (flags & DEVICE_COPY_OBSOLETE) != 0; }
        -: 3973:inline bool UMatData::deviceMemMapped() const { return (flags & DEVICE_MEM_MAPPED) != 0; }
        -: 3974:inline bool UMatData::copyOnMap() const { return (flags & COPY_ON_MAP) != 0; }
        -: 3975:inline bool UMatData::tempUMat() const { return (flags & TEMP_UMAT) != 0; }
        -: 3976:inline bool UMatData::tempCopiedUMat() const { return (flags & TEMP_COPIED_UMAT) == TEMP_COPIED_UMAT; }
        -: 3977:
        -: 3978:inline void UMatData::markDeviceMemMapped(bool flag)
        -: 3979:{
        -: 3980:  if(flag)
        -: 3981:    flags |= DEVICE_MEM_MAPPED;
        -: 3982:  else
        -: 3983:    flags &= ~DEVICE_MEM_MAPPED;
        -: 3984:}
        -: 3985:
        -: 3986:inline void UMatData::markHostCopyObsolete(bool flag)
        -: 3987:{
        -: 3988:    if(flag)
        -: 3989:        flags |= HOST_COPY_OBSOLETE;
        -: 3990:    else
        -: 3991:        flags &= ~HOST_COPY_OBSOLETE;
        -: 3992:}
        -: 3993:inline void UMatData::markDeviceCopyObsolete(bool flag)
        -: 3994:{
        -: 3995:    if(flag)
        -: 3996:        flags |= DEVICE_COPY_OBSOLETE;
        -: 3997:    else
        -: 3998:        flags &= ~DEVICE_COPY_OBSOLETE;
        -: 3999:}
        -: 4000:
        -: 4001://! @endcond
        -: 4002:
        -: 4003:} //cv
        -: 4004:
        -: 4005:#ifdef _MSC_VER
        -: 4006:#pragma warning( pop )
        -: 4007:#endif
        -: 4008:
        -: 4009:#ifdef CV_DISABLE_CLANG_ENUM_WARNINGS
        -: 4010:#undef CV_DISABLE_CLANG_ENUM_WARNINGS
        -: 4011:#pragma clang diagnostic pop
        -: 4012:#endif
        -: 4013:
        -: 4014:#endif
