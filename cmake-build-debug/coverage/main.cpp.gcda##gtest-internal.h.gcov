        -:    0:Source:/cygdrive/c/Users/10505/CLionProjects/C-projcet/googletest/googletest/include/gtest/internal/gtest-internal.h
        -:    0:Graph:/cygdrive/c/Users/10505/CLionProjects/C-projcet/cmake-build-debug/CMakeFiles/cppProject.dir/main.cpp.gcno
        -:    0:Data:/cygdrive/c/Users/10505/CLionProjects/C-projcet/cmake-build-debug/CMakeFiles/cppProject.dir/main.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// Copyright 2005, Google Inc.
        -:    2:// All rights reserved.
        -:    3://
        -:    4:// Redistribution and use in source and binary forms, with or without
        -:    5:// modification, are permitted provided that the following conditions are
        -:    6:// met:
        -:    7://
        -:    8://     * Redistributions of source code must retain the above copyright
        -:    9:// notice, this list of conditions and the following disclaimer.
        -:   10://     * Redistributions in binary form must reproduce the above
        -:   11:// copyright notice, this list of conditions and the following disclaimer
        -:   12:// in the documentation and/or other materials provided with the
        -:   13:// distribution.
        -:   14://     * Neither the name of Google Inc. nor the names of its
        -:   15:// contributors may be used to endorse or promote products derived from
        -:   16:// this software without specific prior written permission.
        -:   17://
        -:   18:// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
        -:   19:// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
        -:   20:// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
        -:   21:// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
        -:   22:// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
        -:   23:// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
        -:   24:// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
        -:   25:// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
        -:   26:// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   27:// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
        -:   28:// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   29://
        -:   30:// The Google C++ Testing and Mocking Framework (Google Test)
        -:   31://
        -:   32:// This header file declares functions and macros used internally by
        -:   33:// Google Test.  They are subject to change without notice.
        -:   34:
        -:   35:// GOOGLETEST_CM0001 DO NOT DELETE
        -:   36:
        -:   37:#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_
        -:   38:#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_
        -:   39:
        -:   40:#include "gtest/internal/gtest-port.h"
        -:   41:
        -:   42:#if GTEST_OS_LINUX
        -:   43:# include <stdlib.h>
        -:   44:# include <sys/types.h>
        -:   45:# include <sys/wait.h>
        -:   46:# include <unistd.h>
        -:   47:#endif  // GTEST_OS_LINUX
        -:   48:
        -:   49:#if GTEST_HAS_EXCEPTIONS
        -:   50:
        -:   51:# include <stdexcept>
        -:   52:
        -:   53:#endif
        -:   54:
        -:   55:#include <ctype.h>
        -:   56:#include <float.h>
        -:   57:#include <string.h>
        -:   58:#include <cstdint>
        -:   59:#include <iomanip>
        -:   60:#include <limits>
        -:   61:#include <map>
        -:   62:#include <set>
        -:   63:#include <string>
        -:   64:#include <type_traits>
        -:   65:#include <vector>
        -:   66:
        -:   67:#include "gtest/gtest-message.h"
        -:   68:#include "gtest/internal/gtest-filepath.h"
        -:   69:#include "gtest/internal/gtest-string.h"
        -:   70:#include "gtest/internal/gtest-type-util.h"
        -:   71:
        -:   72:// Due to C++ preprocessor weirdness, we need double indirection to
        -:   73:// concatenate two tokens when one of them is __LINE__.  Writing
        -:   74://
        -:   75://   foo ## __LINE__
        -:   76://
        -:   77:// will result in the token foo__LINE__, instead of foo followed by
        -:   78:// the current line number.  For more details, see
        -:   79:// http://www.parashift.com/c++-faq-lite/misc-technical-issues.html#faq-39.6
        -:   80:#define GTEST_CONCAT_TOKEN_(foo, bar) GTEST_CONCAT_TOKEN_IMPL_(foo, bar)
        -:   81:#define GTEST_CONCAT_TOKEN_IMPL_(foo, bar) foo ## bar
        -:   82:
        -:   83:// Stringifies its argument.
        -:   84:// Work around a bug in visual studio which doesn't accept code like this:
        -:   85://
        -:   86://   #define GTEST_STRINGIFY_(name) #name
        -:   87://   #define MACRO(a, b, c) ... GTEST_STRINGIFY_(a) ...
        -:   88://   MACRO(, x, y)
        -:   89://
        -:   90:// Complaining about the argument to GTEST_STRINGIFY_ being empty.
        -:   91:// This is allowed by the spec.
        -:   92:#define GTEST_STRINGIFY_HELPER_(name, ...) #name
        -:   93:#define GTEST_STRINGIFY_(...) GTEST_STRINGIFY_HELPER_(__VA_ARGS__, )
        -:   94:
        -:   95:namespace proto2 {
        -:   96:    class MessageLite;
        -:   97:}
        -:   98:
        -:   99:namespace testing {
        -:  100:
        -:  101:// Forward declarations.
        -:  102:
        -:  103:    class AssertionResult;                 // Result of an assertion.
        -:  104:    class Message;                         // Represents a failure message.
        -:  105:    class Test;                            // Represents a test.
        -:  106:    class TestInfo;                        // Information about a test.
        -:  107:    class TestPartResult;                  // Result of a test part.
        -:  108:    class UnitTest;                        // A collection of test suites.
        -:  109:
        -:  110:    template<typename T>
        -:  111:    ::std::string PrintToString(const T &value);
        -:  112:
        -:  113:    namespace internal {
        -:  114:
        -:  115:        struct TraceInfo;                      // Information about a trace point.
        -:  116:        class TestInfoImpl;                    // Opaque implementation of TestInfo
        -:  117:        class UnitTestImpl;                    // Opaque implementation of UnitTest
        -:  118:
        -:  119:// The text used in failure messages to indicate the start of the
        -:  120:// stack trace.
        -:  121:        GTEST_API_ extern const char kStackTraceMarker[];
        -:  122:
        -:  123:// An IgnoredValue object can be implicitly constructed from ANY value.
        -:  124:        class IgnoredValue {
        -:  125:            struct Sink {
        -:  126:            };
        -:  127:        public:
        -:  128:            // This constructor template allows any value to be implicitly
        -:  129:            // converted to IgnoredValue.  The object has no data member and
        -:  130:            // doesn't try to remember anything about the argument.  We
        -:  131:            // deliberately omit the 'explicit' keyword in order to allow the
        -:  132:            // conversion to be implicit.
        -:  133:            // Disable the conversion if T already has a magical conversion operator.
        -:  134:            // Otherwise we get ambiguity.
        -:  135:            template<typename T,
        -:  136:                    typename std::enable_if<!std::is_convertible<T, Sink>::value,
        -:  137:                            int>::type = 0>
        -:  138:            IgnoredValue(const T & /* ignored */) {}  // NOLINT(runtime/explicit)
        -:  139:        };
        -:  140:
        -:  141:// Appends the user-supplied message to the Google-Test-generated message.
        -:  142:        GTEST_API_ std::string AppendUserMessage(
        -:  143:                const std::string &gtest_msg, const Message &user_msg);
        -:  144:
        -:  145:#if GTEST_HAS_EXCEPTIONS
        -:  146:
        -:  147:        GTEST_DISABLE_MSC_WARNINGS_PUSH_(4275 \
        -:  148:/* an exported class was derived from a class that was not exported */)
        -:  149:
        -:  150:// This exception is thrown by (and only by) a failed Google Test
        -:  151:// assertion when GTEST_FLAG(throw_on_failure) is true (if exceptions
        -:  152:// are enabled).  We derive it from std::runtime_error, which is for
        -:  153:// errors presumably detectable only at run time.  Since
        -:  154:// std::runtime_error inherits from std::exception, many testing
        -:  155:// frameworks know how to extract and print the message inside it.
        -:  156:        class GTEST_API_ GoogleTestFailureException : public ::std::runtime_error {
        -:  157:        public:
        -:  158:            explicit GoogleTestFailureException(const TestPartResult &failure);
        -:  159:        };
        -:  160:
        -:  161:        GTEST_DISABLE_MSC_WARNINGS_POP_()  //  4275
        -:  162:
        -:  163:#endif  // GTEST_HAS_EXCEPTIONS
        -:  164:
        -:  165:        namespace edit_distance {
        -:  166:// Returns the optimal edits to go from 'left' to 'right'.
        -:  167:// All edits cost the same, with replace having lower priority than
        -:  168:// add/remove.
        -:  169:// Simple implementation of the Wagner-Fischer algorithm.
        -:  170:// See http://en.wikipedia.org/wiki/Wagner-Fischer_algorithm
        -:  171:            enum EditType {
        -:  172:                kMatch, kAdd, kRemove, kReplace
        -:  173:            };
        -:  174:
        -:  175:            GTEST_API_ std::vector<EditType> CalculateOptimalEdits(
        -:  176:                    const std::vector<size_t> &left, const std::vector<size_t> &right);
        -:  177:
        -:  178:// Same as above, but the input is represented as strings.
        -:  179:            GTEST_API_ std::vector<EditType> CalculateOptimalEdits(
        -:  180:                    const std::vector<std::string> &left,
        -:  181:                    const std::vector<std::string> &right);
        -:  182:
        -:  183:// Create a diff of the input strings in Unified diff format.
        -:  184:            GTEST_API_ std::string CreateUnifiedDiff(const std::vector<std::string> &left,
        -:  185:                                                     const std::vector<std::string> &right,
        -:  186:                                                     size_t context = 2);
        -:  187:
        -:  188:        }  // namespace edit_distance
        -:  189:
        -:  190:// Calculate the diff between 'left' and 'right' and return it in unified diff
        -:  191:// format.
        -:  192:// If not null, stores in 'total_line_count' the total number of lines found
        -:  193:// in left + right.
        -:  194:        GTEST_API_ std::string DiffStrings(const std::string &left,
        -:  195:                                           const std::string &right,
        -:  196:                                           size_t *total_line_count);
        -:  197:
        -:  198:// Constructs and returns the message for an equality assertion
        -:  199:// (e.g. ASSERT_EQ, EXPECT_STREQ, etc) failure.
        -:  200://
        -:  201:// The first four parameters are the expressions used in the assertion
        -:  202:// and their values, as strings.  For example, for ASSERT_EQ(foo, bar)
        -:  203:// where foo is 5 and bar is 6, we have:
        -:  204://
        -:  205://   expected_expression: "foo"
        -:  206://   actual_expression:   "bar"
        -:  207://   expected_value:      "5"
        -:  208://   actual_value:        "6"
        -:  209://
        -:  210:// The ignoring_case parameter is true if and only if the assertion is a
        -:  211:// *_STRCASEEQ*.  When it's true, the string " (ignoring case)" will
        -:  212:// be inserted into the message.
        -:  213:        GTEST_API_ AssertionResult EqFailure(const char *expected_expression,
        -:  214:                                             const char *actual_expression,
        -:  215:                                             const std::string &expected_value,
        -:  216:                                             const std::string &actual_value,
        -:  217:                                             bool ignoring_case);
        -:  218:
        -:  219:// Constructs a failure message for Boolean assertions such as EXPECT_TRUE.
        -:  220:        GTEST_API_ std::string GetBoolAssertionFailureMessage(
        -:  221:                const AssertionResult &assertion_result,
        -:  222:                const char *expression_text,
        -:  223:                const char *actual_predicate_value,
        -:  224:                const char *expected_predicate_value);
        -:  225:
        -:  226:// This template class represents an IEEE floating-point number
        -:  227:// (either single-precision or double-precision, depending on the
        -:  228:// template parameters).
        -:  229://
        -:  230:// The purpose of this class is to do more sophisticated number
        -:  231:// comparison.  (Due to round-off error, etc, it's very unlikely that
        -:  232:// two floating-points will be equal exactly.  Hence a naive
        -:  233:// comparison by the == operation often doesn't work.)
        -:  234://
        -:  235:// Format of IEEE floating-point:
        -:  236://
        -:  237://   The most-significant bit being the leftmost, an IEEE
        -:  238://   floating-point looks like
        -:  239://
        -:  240://     sign_bit exponent_bits fraction_bits
        -:  241://
        -:  242://   Here, sign_bit is a single bit that designates the sign of the
        -:  243://   number.
        -:  244://
        -:  245://   For float, there are 8 exponent bits and 23 fraction bits.
        -:  246://
        -:  247://   For double, there are 11 exponent bits and 52 fraction bits.
        -:  248://
        -:  249://   More details can be found at
        -:  250://   http://en.wikipedia.org/wiki/IEEE_floating-point_standard.
        -:  251://
        -:  252:// Template parameter:
        -:  253://
        -:  254://   RawType: the raw floating-point type (either float or double)
        -:  255:        template<typename RawType>
        -:  256:        class FloatingPoint {
        -:  257:        public:
        -:  258:            // Defines the unsigned integer type that has the same size as the
        -:  259:            // floating point number.
        -:  260:            typedef typename TypeWithSize<sizeof(RawType)>::UInt Bits;
        -:  261:
        -:  262:            // Constants.
        -:  263:
        -:  264:            // # of bits in a number.
        -:  265:            static const size_t kBitCount = 8 * sizeof(RawType);
        -:  266:
        -:  267:            // # of fraction bits in a number.
        -:  268:            static const size_t kFractionBitCount =
        -:  269:                    std::numeric_limits<RawType>::digits - 1;
        -:  270:
        -:  271:            // # of exponent bits in a number.
        -:  272:            static const size_t kExponentBitCount = kBitCount - 1 - kFractionBitCount;
        -:  273:
        -:  274:            // The mask for the sign bit.
        -:  275:            static const Bits kSignBitMask = static_cast<Bits>(1) << (kBitCount - 1);
        -:  276:
        -:  277:            // The mask for the fraction bits.
        -:  278:            static const Bits kFractionBitMask =
        -:  279:                    ~static_cast<Bits>(0) >> (kExponentBitCount + 1);
        -:  280:
        -:  281:            // The mask for the exponent bits.
        -:  282:            static const Bits kExponentBitMask = ~(kSignBitMask | kFractionBitMask);
        -:  283:
        -:  284:            // How many ULP's (Units in the Last Place) we want to tolerate when
        -:  285:            // comparing two numbers.  The larger the value, the more error we
        -:  286:            // allow.  A 0 value means that two numbers must be exactly the same
        -:  287:            // to be considered equal.
        -:  288:            //
        -:  289:            // The maximum error of a single floating-point operation is 0.5
        -:  290:            // units in the last place.  On Intel CPU's, all floating-point
        -:  291:            // calculations are done with 80-bit precision, while double has 64
        -:  292:            // bits.  Therefore, 4 should be enough for ordinary use.
        -:  293:            //
        -:  294:            // See the following article for more details on ULP:
        -:  295:            // http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/
        -:  296:            static const size_t kMaxUlps = 4;
        -:  297:
        -:  298:            // Constructs a FloatingPoint from a raw floating-point number.
        -:  299:            //
        -:  300:            // On an Intel CPU, passing a non-normalized NAN (Not a Number)
        -:  301:            // around may change its bits, although the new value is guaranteed
        -:  302:            // to be also a NAN.  Therefore, don't expect this constructor to
        -:  303:            // preserve the bits in x when x is a NAN.
       36:  304:            explicit FloatingPoint(const RawType &x) { u_.value_ = x; }
       36:  304-block  0
        -:  305:
        -:  306:            // Static methods
        -:  307:
        -:  308:            // Reinterprets a bit pattern as a floating-point number.
        -:  309:            //
        -:  310:            // This function is needed to test the AlmostEquals() method.
        -:  311:            static RawType ReinterpretBits(const Bits bits) {
        -:  312:                FloatingPoint fp(0);
        -:  313:                fp.u_.bits_ = bits;
        -:  314:                return fp.u_.value_;
        -:  315:            }
        -:  316:
        -:  317:            // Returns the floating-point number that represent positive infinity.
        -:  318:            static RawType Infinity() {
        -:  319:                return ReinterpretBits(kExponentBitMask);
        -:  320:            }
        -:  321:
        -:  322:            // Returns the maximum representable finite floating-point number.
        -:  323:            static RawType Max();
        -:  324:
        -:  325:            // Non-static methods
        -:  326:
        -:  327:            // Returns the bits that represents this number.
        -:  328:            const Bits &bits() const { return u_.bits_; }
        -:  329:
        -:  330:            // Returns the exponent bits of this number.
       72:  331:            Bits exponent_bits() const { return kExponentBitMask & u_.bits_; }
       36:  331-block  0
       36:  331-block  1
        -:  332:
        -:  333:            // Returns the fraction bits of this number.
    #####:  334:            Bits fraction_bits() const { return kFractionBitMask & u_.bits_; }
    $$$$$:  334-block  0
    $$$$$:  334-block  1
        -:  335:
        -:  336:            // Returns the sign bit of this number.
        -:  337:            Bits sign_bit() const { return kSignBitMask & u_.bits_; }
        -:  338:
        -:  339:            // Returns true if and only if this is NAN (not a number).
       36:  340:            bool is_nan() const {
       36:  340-block  0
        -:  341:                // It's a NAN if the exponent bits are all ones and the fraction
        -:  342:                // bits are not entirely zeros.
       36:  343:                return (exponent_bits() == kExponentBitMask) && (fraction_bits() != 0);
       36:  343-block  0
    $$$$$:  343-block  1
    $$$$$:  343-block  2
       36:  343-block  3
       36:  343-block  4
        -:  344:            }
        -:  345:
        -:  346:            // Returns true if and only if this number is at most kMaxUlps ULP's away
        -:  347:            // from rhs.  In particular, this function:
        -:  348:            //
        -:  349:            //   - returns false if either number is (or both are) NAN.
        -:  350:            //   - treats really large numbers as almost equal to infinity.
        -:  351:            //   - thinks +0.0 and -0.0 are 0 DLP's apart.
       18:  352:            bool AlmostEquals(const FloatingPoint &rhs) const {
       18:  352-block  0
        -:  353:                // The IEEE standard says that any comparison operation involving
        -:  354:                // a NAN must return false.
       18:  355:                if (is_nan() || rhs.is_nan()) return false;
       18:  355-block  0
       18:  355-block  1
    $$$$$:  355-block  2
       18:  355-block  3
       18:  355-block  4
    $$$$$:  355-block  5
        -:  356:
       18:  357:                return DistanceBetweenSignAndMagnitudeNumbers(u_.bits_, rhs.u_.bits_)
       18:  357-block  0
       18:  358:                       <= kMaxUlps;
        -:  359:            }
        -:  360:
        -:  361:        private:
        -:  362:            // The data type used to store the actual floating-point number.
        -:  363:            union FloatingPointUnion {
        -:  364:                RawType value_;  // The raw floating-point number.
        -:  365:                Bits bits_;      // The bits that represent the number.
        -:  366:            };
        -:  367:
        -:  368:            // Converts an integer from the sign-and-magnitude representation to
        -:  369:            // the biased representation.  More precisely, let N be 2 to the
        -:  370:            // power of (kBitCount - 1), an integer x is represented by the
        -:  371:            // unsigned number x + N.
        -:  372:            //
        -:  373:            // For instance,
        -:  374:            //
        -:  375:            //   -N + 1 (the most negative number representable using
        -:  376:            //          sign-and-magnitude) is represented by 1;
        -:  377:            //   0      is represented by N; and
        -:  378:            //   N - 1  (the biggest number representable using
        -:  379:            //          sign-and-magnitude) is represented by 2N - 1.
        -:  380:            //
        -:  381:            // Read http://en.wikipedia.org/wiki/Signed_number_representations
        -:  382:            // for more details on signed number representations.
       36:  383:            static Bits SignAndMagnitudeToBiased(const Bits &sam) {
       36:  383-block  0
       36:  384:                if (kSignBitMask & sam) {
       36:  384-block  0
        -:  385:                    // sam represents a negative number.
       24:  386:                    return ~sam + 1;
       24:  386-block  0
        -:  387:                } else {
        -:  388:                    // sam represents a positive number.
       12:  389:                    return kSignBitMask | sam;
       12:  389-block  0
        -:  390:                }
        -:  391:            }
        -:  392:
        -:  393:            // Given two numbers in the sign-and-magnitude representation,
        -:  394:            // returns the distance between them as an unsigned number.
       18:  395:            static Bits DistanceBetweenSignAndMagnitudeNumbers(const Bits &sam1,
       18:  395-block  0
        -:  396:                                                               const Bits &sam2) {
       18:  397:                const Bits biased1 = SignAndMagnitudeToBiased(sam1);
       18:  397-block  0
       18:  398:                const Bits biased2 = SignAndMagnitudeToBiased(sam2);
       18:  399:                return (biased1 >= biased2) ? (biased1 - biased2) : (biased2 - biased1);
       18:  399-block  0
    $$$$$:  399-block  1
       18:  399-block  2
        -:  400:            }
        -:  401:
        -:  402:            FloatingPointUnion u_;
        -:  403:        };
        -:  404:
        -:  405:// We cannot use std::numeric_limits<T>::max() as it clashes with the max()
        -:  406:// macro defined by <windows.h>.
        -:  407:        template<>
        -:  408:        inline float FloatingPoint<float>::Max() { return FLT_MAX; }
        -:  409:
        -:  410:        template<>
        -:  411:        inline double FloatingPoint<double>::Max() { return DBL_MAX; }
        -:  412:
        -:  413:// Typedefs the instances of the FloatingPoint template class that we
        -:  414:// care to use.
        -:  415:        typedef FloatingPoint<float> Float;
        -:  416:        typedef FloatingPoint<double> Double;
        -:  417:
        -:  418:// In order to catch the mistake of putting tests that use different
        -:  419:// test fixture classes in the same test suite, we need to assign
        -:  420:// unique IDs to fixture classes and compare them.  The TypeId type is
        -:  421:// used to hold such IDs.  The user should treat TypeId as an opaque
        -:  422:// type: the only operation allowed on TypeId values is to compare
        -:  423:// them for equality using the == operator.
        -:  424:        typedef const void *TypeId;
        -:  425:
        -:  426:        template<typename T>
        -:  427:        class TypeIdHelper {
        -:  428:        public:
        -:  429:            // dummy_ must not have a const type.  Otherwise an overly eager
        -:  430:            // compiler (e.g. MSVC 7.1 & 8.0) may try to merge
        -:  431:            // TypeIdHelper<T>::dummy_ for different Ts as an "optimization".
        -:  432:            static bool dummy_;
        -:  433:        };
        -:  434:
        -:  435:        template<typename T>
        -:  436:        bool TypeIdHelper<T>::dummy_ = false;
        -:  437:
        -:  438:// GetTypeId<T>() returns the ID of type T.  Different values will be
        -:  439:// returned for different types.  Calling the function twice with the
        -:  440:// same type argument is guaranteed to return the same ID.
        -:  441:        template<typename T>
        -:  442:        TypeId GetTypeId() {
        -:  443:            // The compiler is required to allocate a different
        -:  444:            // TypeIdHelper<T>::dummy_ variable for each T used to instantiate
        -:  445:            // the template.  Therefore, the address of dummy_ is guaranteed to
        -:  446:            // be unique.
        -:  447:            return &(TypeIdHelper<T>::dummy_);
        -:  448:        }
        -:  449:
        -:  450:// Returns the type ID of ::testing::Test.  Always call this instead
        -:  451:// of GetTypeId< ::testing::Test>() to get the type ID of
        -:  452:// ::testing::Test, as the latter may give the wrong result due to a
        -:  453:// suspected linker bug when compiling Google Test as a Mac OS X
        -:  454:// framework.
        -:  455:        GTEST_API_ TypeId GetTestTypeId();
        -:  456:
        -:  457:// Defines the abstract factory interface that creates instances
        -:  458:// of a Test object.
        -:  459:        class TestFactoryBase {
        -:  460:        public:
    #####:  461:            virtual ~TestFactoryBase() {}
    $$$$$:  461-block  0
        -:  462:
        -:  463:            // Creates a test instance to run. The instance is both created and destroyed
        -:  464:            // within TestInfoImpl::Run()
        -:  465:            virtual Test *CreateTest() = 0;
        -:  466:
        -:  467:        protected:
        7:  468:            TestFactoryBase() {}
        7:  468-block  0
        -:  469:
        -:  470:        private:
        -:  471:            GTEST_DISALLOW_COPY_AND_ASSIGN_(TestFactoryBase);
        -:  472:        };
        -:  473:
        -:  474:// This class provides implementation of TeastFactoryBase interface.
        -:  475:// It is used in TEST and TEST_F macros.
        -:  476:        template<class TestClass>
       14:  477:        class TestFactoryImpl : public TestFactoryBase {
    $$$$$:  477-block  0
    $$$$$:  477-block  1
    $$$$$:  477-block  2
    $$$$$:  477-block  3
    $$$$$:  477-block  4
    $$$$$:  477-block  5
    $$$$$:  477-block  6
    $$$$$:  477-block  7
    $$$$$:  477-block  8
    $$$$$:  477-block  9
    $$$$$:  477-block 10
    $$$$$:  477-block 11
    $$$$$:  477-block 12
    $$$$$:  477-block 13
    $$$$$:  477-block 14
    $$$$$:  477-block 15
    $$$$$:  477-block 16
    $$$$$:  477-block 17
    $$$$$:  477-block 18
    $$$$$:  477-block 19
    $$$$$:  477-block 20
    $$$$$:  477-block 21
    $$$$$:  477-block 22
    $$$$$:  477-block 23
    $$$$$:  477-block 24
    $$$$$:  477-block 25
    $$$$$:  477-block 26
    $$$$$:  477-block 27
        1:  477-block 28
        1:  477-block 29
        1:  477-block 30
        1:  477-block 31
        1:  477-block 32
        1:  477-block 33
        1:  477-block 34
        1:  477-block 35
        1:  477-block 36
        1:  477-block 37
        1:  477-block 38
        1:  477-block 39
        1:  477-block 40
        1:  477-block 41
        -:  478:        public:
        7:  479:            Test *CreateTest() override { return new TestClass; }
        1:  479-block  0
        1:  479-block  1
        1:  479-block  2
        1:  479-block  3
    %%%%%:  479-block  4
        1:  479-block  5
        1:  479-block  6
        1:  479-block  7
        1:  479-block  8
    %%%%%:  479-block  9
        1:  479-block 10
        1:  479-block 11
        1:  479-block 12
        1:  479-block 13
    %%%%%:  479-block 14
        1:  479-block 15
        1:  479-block 16
        1:  479-block 17
        1:  479-block 18
    %%%%%:  479-block 19
        1:  479-block 20
        1:  479-block 21
        1:  479-block 22
        1:  479-block 23
    %%%%%:  479-block 24
        1:  479-block 25
        1:  479-block 26
        1:  479-block 27
        1:  479-block 28
    %%%%%:  479-block 29
        1:  479-block 30
        1:  479-block 31
        1:  479-block 32
        1:  479-block 33
    %%%%%:  479-block 34
        -:  480:        };
        -:  481:
        -:  482:#if GTEST_OS_WINDOWS
        -:  483:
        -:  484:        // Predicate-formatters for implementing the HRESULT checking macros
        -:  485:        // {ASSERT|EXPECT}_HRESULT_{SUCCEEDED|FAILED}
        -:  486:        // We pass a long instead of HRESULT to avoid causing an
        -:  487:        // include dependency for the HRESULT type.
        -:  488:        GTEST_API_ AssertionResult IsHRESULTSuccess(const char* expr,
        -:  489:                                                    long hr);  // NOLINT
        -:  490:        GTEST_API_ AssertionResult IsHRESULTFailure(const char* expr,
        -:  491:                                                    long hr);  // NOLINT
        -:  492:
        -:  493:#endif  // GTEST_OS_WINDOWS
        -:  494:
        -:  495:// Types of SetUpTestSuite() and TearDownTestSuite() functions.
        -:  496:        using SetUpTestSuiteFunc = void (*)();
        -:  497:        using TearDownTestSuiteFunc = void (*)();
        -:  498:
       28:  499:        struct CodeLocation {
       14:  499-block  0
       14:  499-block  1
        7:  500:            CodeLocation(const std::string &a_file, int a_line)
        7:  500-block  0
        7:  501:                    : file(a_file), line(a_line) {}
        7:  501-block  0
        -:  502:
        -:  503:            std::string file;
        -:  504:            int line;
        -:  505:        };
        -:  506:
        -:  507://  Helper to identify which setup function for TestCase / TestSuite to call.
        -:  508://  Only one function is allowed, either TestCase or TestSute but not both.
        -:  509:
        -:  510:// Utility functions to help SuiteApiResolver
        -:  511:        using SetUpTearDownSuiteFuncType = void (*)();
        -:  512:
       28:  513:        inline SetUpTearDownSuiteFuncType GetNotDefaultOrNull(
       28:  513-block  0
        -:  514:                SetUpTearDownSuiteFuncType a, SetUpTearDownSuiteFuncType def) {
       28:  515:            return a == def ? nullptr : a;
       28:  515-block  0
    $$$$$:  515-block  1
       28:  515-block  2
       28:  515-block  3
        -:  516:        }
        -:  517:
        -:  518:        template<typename T>
        -:  519://  Note that SuiteApiResolver inherits from T because
        -:  520://  SetUpTestSuite()/TearDownTestSuite() could be protected. Ths way
        -:  521://  SuiteApiResolver can access them.
        -:  522:        struct SuiteApiResolver : T {
        -:  523:            // testing::Test is only forward declared at this point. So we make it a
        -:  524:            // dependend class for the compiler to be OK with it.
        -:  525:            using Test =
        -:  526:            typename std::conditional<sizeof(T) != 0, ::testing::Test, void>::type;
        -:  527:
        7:  528:            static SetUpTearDownSuiteFuncType GetSetUpCaseOrSuite(const char *filename,
        7:  528-block  0
        -:  529:                                                                  int line_num) {
        7:  530:                SetUpTearDownSuiteFuncType test_case_fp =
        7:  530-block  0
        -:  531:                        GetNotDefaultOrNull(&T::SetUpTestCase, &Test::SetUpTestCase);
        7:  532:                SetUpTearDownSuiteFuncType test_suite_fp =
        -:  533:                        GetNotDefaultOrNull(&T::SetUpTestSuite, &Test::SetUpTestSuite);
        -:  534:
        7:  535:                GTEST_CHECK_(!test_case_fp || !test_suite_fp)
    $$$$$:  535-block  0
        7:  535-block  1
    $$$$$:  535-block  2
        7:  535-block  3
    $$$$$:  535-block  4
    $$$$$:  535-block  5
    $$$$$:  535-block  6
    %%%%%:  535-block  7
        -:  536:                            << "Test can not provide both SetUpTestSuite and SetUpTestCase, please "
        -:  537:                               "make sure there is only one present at "
    #####:  538:                            << filename << ":" << line_num;
    $$$$$:  538-block  0
    $$$$$:  538-block  1
    $$$$$:  538-block  2
        -:  539:
        7:  540:                return test_case_fp != nullptr ? test_case_fp : test_suite_fp;
        7:  540-block  0
    $$$$$:  540-block  1
        7:  540-block  2
        7:  540-block  3
        7:  540-block  4
        -:  541:            }
        -:  542:
        7:  543:            static SetUpTearDownSuiteFuncType GetTearDownCaseOrSuite(const char *filename,
        7:  543-block  0
        -:  544:                                                                     int line_num) {
        7:  545:                SetUpTearDownSuiteFuncType test_case_fp =
        7:  545-block  0
        -:  546:                        GetNotDefaultOrNull(&T::TearDownTestCase, &Test::TearDownTestCase);
        7:  547:                SetUpTearDownSuiteFuncType test_suite_fp =
        -:  548:                        GetNotDefaultOrNull(&T::TearDownTestSuite, &Test::TearDownTestSuite);
        -:  549:
        7:  550:                GTEST_CHECK_(!test_case_fp || !test_suite_fp)
    $$$$$:  550-block  0
        7:  550-block  1
    $$$$$:  550-block  2
        7:  550-block  3
    $$$$$:  550-block  4
    $$$$$:  550-block  5
    $$$$$:  550-block  6
    %%%%%:  550-block  7
        -:  551:                            << "Test can not provide both TearDownTestSuite and TearDownTestCase,"
        -:  552:                               " please make sure there is only one present at"
    #####:  553:                            << filename << ":" << line_num;
    $$$$$:  553-block  0
    $$$$$:  553-block  1
    $$$$$:  553-block  2
        -:  554:
        7:  555:                return test_case_fp != nullptr ? test_case_fp : test_suite_fp;
        7:  555-block  0
    $$$$$:  555-block  1
        7:  555-block  2
        7:  555-block  3
        7:  555-block  4
        -:  556:            }
        -:  557:        };
        -:  558:
        -:  559:// Creates a new TestInfo object and registers it with Google Test;
        -:  560:// returns the created object.
        -:  561://
        -:  562:// Arguments:
        -:  563://
        -:  564://   test_suite_name:   name of the test suite
        -:  565://   name:             name of the test
        -:  566://   type_param        the name of the test's type parameter, or NULL if
        -:  567://                     this is not a typed or a type-parameterized test.
        -:  568://   value_param       text representation of the test's value parameter,
        -:  569://                     or NULL if this is not a type-parameterized test.
        -:  570://   code_location:    code location where the test is defined
        -:  571://   fixture_class_id: ID of the test fixture class
        -:  572://   set_up_tc:        pointer to the function that sets up the test suite
        -:  573://   tear_down_tc:     pointer to the function that tears down the test suite
        -:  574://   factory:          pointer to the factory that creates a test object.
        -:  575://                     The newly created TestInfo instance will assume
        -:  576://                     ownership of the factory object.
        -:  577:        GTEST_API_ TestInfo *MakeAndRegisterTestInfo(
        -:  578:                const char *test_suite_name, const char *name, const char *type_param,
        -:  579:                const char *value_param, CodeLocation code_location,
        -:  580:                TypeId fixture_class_id, SetUpTestSuiteFunc set_up_tc,
        -:  581:                TearDownTestSuiteFunc tear_down_tc, TestFactoryBase *factory);
        -:  582:
        -:  583:// If *pstr starts with the given prefix, modifies *pstr to be right
        -:  584:// past the prefix and returns true; otherwise leaves *pstr unchanged
        -:  585:// and returns false.  None of pstr, *pstr, and prefix can be NULL.
        -:  586:        GTEST_API_ bool SkipPrefix(const char *prefix, const char **pstr);
        -:  587:
        -:  588:#if GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P
        -:  589:
        -:  590:        GTEST_DISABLE_MSC_WARNINGS_PUSH_(4251 \
        -:  591:/* class A needs to have dll-interface to be used by clients of class B */)
        -:  592:
        -:  593:// State of the definition of a type-parameterized test suite.
        -:  594:        class GTEST_API_ TypedTestSuitePState {
        -:  595:        public:
        -:  596:            TypedTestSuitePState() : registered_(false) {}
        -:  597:
        -:  598:            // Adds the given test name to defined_test_names_ and return true
        -:  599:            // if the test suite hasn't been registered; otherwise aborts the
        -:  600:            // program.
        -:  601:            bool AddTestName(const char *file, int line, const char *case_name,
        -:  602:                             const char *test_name) {
        -:  603:                if (registered_) {
        -:  604:                    fprintf(stderr,
        -:  605:                            "%s Test %s must be defined before "
        -:  606:                            "REGISTER_TYPED_TEST_SUITE_P(%s, ...).\n",
        -:  607:                            FormatFileLocation(file, line).c_str(), test_name, case_name);
        -:  608:                    fflush(stderr);
        -:  609:                    posix::Abort();
        -:  610:                }
        -:  611:                registered_tests_.insert(
        -:  612:                        ::std::make_pair(test_name, CodeLocation(file, line)));
        -:  613:                return true;
        -:  614:            }
        -:  615:
        -:  616:            bool TestExists(const std::string &test_name) const {
        -:  617:                return registered_tests_.count(test_name) > 0;
        -:  618:            }
        -:  619:
        -:  620:            const CodeLocation &GetCodeLocation(const std::string &test_name) const {
        -:  621:                RegisteredTestsMap::const_iterator it = registered_tests_.find(test_name);
        -:  622:                GTEST_CHECK_(it != registered_tests_.end());
        -:  623:                return it->second;
        -:  624:            }
        -:  625:
        -:  626:            // Verifies that registered_tests match the test names in
        -:  627:            // defined_test_names_; returns registered_tests if successful, or
        -:  628:            // aborts the program otherwise.
        -:  629:            const char *VerifyRegisteredTestNames(const char *test_suite_name,
        -:  630:                                                  const char *file, int line,
        -:  631:                                                  const char *registered_tests);
        -:  632:
        -:  633:        private:
        -:  634:            typedef ::std::map<std::string, CodeLocation> RegisteredTestsMap;
        -:  635:
        -:  636:            bool registered_;
        -:  637:            RegisteredTestsMap registered_tests_;
        -:  638:        };
        -:  639:
        -:  640://  Legacy API is deprecated but still available
        -:  641:#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
        -:  642:        using TypedTestCasePState = TypedTestSuitePState;
        -:  643:#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_
        -:  644:
        -:  645:        GTEST_DISABLE_MSC_WARNINGS_POP_()  //  4251
        -:  646:
        -:  647:// Skips to the first non-space char after the first comma in 'str';
        -:  648:// returns NULL if no comma is found in 'str'.
        -:  649:        inline const char *SkipComma(const char *str) {
        -:  650:            const char *comma = strchr(str, ',');
        -:  651:            if (comma == nullptr) {
        -:  652:                return nullptr;
        -:  653:            }
        -:  654:            while (IsSpace(*(++comma))) {}
        -:  655:            return comma;
        -:  656:        }
        -:  657:
        -:  658:// Returns the prefix of 'str' before the first comma in it; returns
        -:  659:// the entire string if it contains no comma.
        -:  660:        inline std::string GetPrefixUntilComma(const char *str) {
        -:  661:            const char *comma = strchr(str, ',');
        -:  662:            return comma == nullptr ? str : std::string(str, comma);
        -:  663:        }
        -:  664:
        -:  665:// Splits a given string on a given delimiter, populating a given
        -:  666:// vector with the fields.
        -:  667:        void SplitString(const ::std::string &str, char delimiter,
        -:  668:                         ::std::vector<::std::string> *dest);
        -:  669:
        -:  670:// The default argument to the template below for the case when the user does
        -:  671:// not provide a name generator.
        -:  672:        struct DefaultNameGenerator {
        -:  673:            template<typename T>
        -:  674:            static std::string GetName(int i) {
        -:  675:                return StreamableToString(i);
        -:  676:            }
        -:  677:        };
        -:  678:
        -:  679:        template<typename Provided = DefaultNameGenerator>
        -:  680:        struct NameGeneratorSelector {
        -:  681:            typedef Provided type;
        -:  682:        };
        -:  683:
        -:  684:        template<typename NameGenerator>
        -:  685:        void GenerateNamesRecursively(internal::None, std::vector<std::string> *, int) {}
        -:  686:
        -:  687:        template<typename NameGenerator, typename Types>
        -:  688:        void GenerateNamesRecursively(Types, std::vector<std::string> *result, int i) {
        -:  689:            result->push_back(NameGenerator::template GetName<typename Types::Head>(i));
        -:  690:            GenerateNamesRecursively<NameGenerator>(typename Types::Tail(), result,
        -:  691:                                                    i + 1);
        -:  692:        }
        -:  693:
        -:  694:        template<typename NameGenerator, typename Types>
        -:  695:        std::vector<std::string> GenerateNames() {
        -:  696:            std::vector<std::string> result;
        -:  697:            GenerateNamesRecursively<NameGenerator>(Types(), &result, 0);
        -:  698:            return result;
        -:  699:        }
        -:  700:
        -:  701:// TypeParameterizedTest<Fixture, TestSel, Types>::Register()
        -:  702:// registers a list of type-parameterized tests with Google Test.  The
        -:  703:// return value is insignificant - we just need to return something
        -:  704:// such that we can call this function in a namespace scope.
        -:  705://
        -:  706:// Implementation note: The GTEST_TEMPLATE_ macro declares a template
        -:  707:// template parameter.  It's defined in gtest-type-util.h.
        -:  708:        template<GTEST_TEMPLATE_ Fixture, class TestSel, typename Types>
        -:  709:        class TypeParameterizedTest {
        -:  710:        public:
        -:  711:            // 'index' is the index of the test in the type list 'Types'
        -:  712:            // specified in INSTANTIATE_TYPED_TEST_SUITE_P(Prefix, TestSuite,
        -:  713:            // Types).  Valid values for 'index' are [0, N - 1] where N is the
        -:  714:            // length of Types.
        -:  715:            static bool Register(const char *prefix, const CodeLocation &code_location,
        -:  716:                                 const char *case_name, const char *test_names, int index,
        -:  717:                                 const std::vector<std::string> &type_names =
        -:  718:                                 GenerateNames<DefaultNameGenerator, Types>()) {
        -:  719:                typedef typename Types::Head Type;
        -:  720:                typedef Fixture<Type> FixtureClass;
        -:  721:                typedef typename GTEST_BIND_(TestSel, Type) TestClass;
        -:  722:
        -:  723:                // First, registers the first type-parameterized test in the type
        -:  724:                // list.
        -:  725:                MakeAndRegisterTestInfo(
        -:  726:                        (std::string(prefix) + (prefix[0] == '\0' ? "" : "/") + case_name +
        -:  727:                         "/" + type_names[static_cast<size_t>(index)])
        -:  728:                                .c_str(),
        -:  729:                        StripTrailingSpaces(GetPrefixUntilComma(test_names)).c_str(),
        -:  730:                        GetTypeName<Type>().c_str(),
        -:  731:                        nullptr,  // No value parameter.
        -:  732:                        code_location, GetTypeId<FixtureClass>(),
        -:  733:                        SuiteApiResolver<TestClass>::GetSetUpCaseOrSuite(
        -:  734:                                code_location.file.c_str(), code_location.line),
        -:  735:                        SuiteApiResolver<TestClass>::GetTearDownCaseOrSuite(
        -:  736:                                code_location.file.c_str(), code_location.line),
        -:  737:                        new TestFactoryImpl<TestClass>);
        -:  738:
        -:  739:                // Next, recurses (at compile time) with the tail of the type list.
        -:  740:                return TypeParameterizedTest<Fixture, TestSel,
        -:  741:                        typename Types::Tail>::Register(prefix,
        -:  742:                                                        code_location,
        -:  743:                                                        case_name,
        -:  744:                                                        test_names,
        -:  745:                                                        index + 1,
        -:  746:                                                        type_names);
        -:  747:            }
        -:  748:        };
        -:  749:
        -:  750:// The base case for the compile time recursion.
        -:  751:        template<GTEST_TEMPLATE_ Fixture, class TestSel>
        -:  752:        class TypeParameterizedTest<Fixture, TestSel, internal::None> {
        -:  753:        public:
        -:  754:            static bool Register(const char * /*prefix*/, const CodeLocation &,
        -:  755:                                 const char * /*case_name*/, const char * /*test_names*/,
        -:  756:                                 int /*index*/,
        -:  757:                                 const std::vector<std::string> & =
        -:  758:                                 std::vector<std::string>() /*type_names*/) {
        -:  759:                return true;
        -:  760:            }
        -:  761:        };
        -:  762:
        -:  763:        GTEST_API_ void RegisterTypeParameterizedTestSuite(const char *test_suite_name,
        -:  764:                                                           CodeLocation code_location);
        -:  765:
        -:  766:        GTEST_API_ void RegisterTypeParameterizedTestSuiteInstantiation(
        -:  767:                const char *case_name);
        -:  768:
        -:  769:// TypeParameterizedTestSuite<Fixture, Tests, Types>::Register()
        -:  770:// registers *all combinations* of 'Tests' and 'Types' with Google
        -:  771:// Test.  The return value is insignificant - we just need to return
        -:  772:// something such that we can call this function in a namespace scope.
        -:  773:        template<GTEST_TEMPLATE_ Fixture, typename Tests, typename Types>
        -:  774:        class TypeParameterizedTestSuite {
        -:  775:        public:
        -:  776:            static bool Register(const char *prefix, CodeLocation code_location,
        -:  777:                                 const TypedTestSuitePState *state, const char *case_name,
        -:  778:                                 const char *test_names,
        -:  779:                                 const std::vector<std::string> &type_names =
        -:  780:                                 GenerateNames<DefaultNameGenerator, Types>()) {
        -:  781:                RegisterTypeParameterizedTestSuiteInstantiation(case_name);
        -:  782:                std::string test_name = StripTrailingSpaces(
        -:  783:                        GetPrefixUntilComma(test_names));
        -:  784:                if (!state->TestExists(test_name)) {
        -:  785:                    fprintf(stderr, "Failed to get code location for test %s.%s at %s.",
        -:  786:                            case_name, test_name.c_str(),
        -:  787:                            FormatFileLocation(code_location.file.c_str(),
        -:  788:                                               code_location.line).c_str());
        -:  789:                    fflush(stderr);
        -:  790:                    posix::Abort();
        -:  791:                }
        -:  792:                const CodeLocation &test_location = state->GetCodeLocation(test_name);
        -:  793:
        -:  794:                typedef typename Tests::Head Head;
        -:  795:
        -:  796:                // First, register the first test in 'Test' for each type in 'Types'.
        -:  797:                TypeParameterizedTest<Fixture, Head, Types>::Register(
        -:  798:                        prefix, test_location, case_name, test_names, 0, type_names);
        -:  799:
        -:  800:                // Next, recurses (at compile time) with the tail of the test list.
        -:  801:                return TypeParameterizedTestSuite<Fixture, typename Tests::Tail,
        -:  802:                        Types>::Register(prefix, code_location,
        -:  803:                                         state, case_name,
        -:  804:                                         SkipComma(test_names),
        -:  805:                                         type_names);
        -:  806:            }
        -:  807:        };
        -:  808:
        -:  809:// The base case for the compile time recursion.
        -:  810:        template<GTEST_TEMPLATE_ Fixture, typename Types>
        -:  811:        class TypeParameterizedTestSuite<Fixture, internal::None, Types> {
        -:  812:        public:
        -:  813:            static bool Register(const char * /*prefix*/, const CodeLocation &,
        -:  814:                                 const TypedTestSuitePState * /*state*/,
        -:  815:                                 const char * /*case_name*/, const char * /*test_names*/,
        -:  816:                                 const std::vector<std::string> & =
        -:  817:                                 std::vector<std::string>() /*type_names*/) {
        -:  818:                return true;
        -:  819:            }
        -:  820:        };
        -:  821:
        -:  822:#endif  // GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P
        -:  823:
        -:  824:// Returns the current OS stack trace as an std::string.
        -:  825://
        -:  826:// The maximum number of stack frames to be included is specified by
        -:  827:// the gtest_stack_trace_depth flag.  The skip_count parameter
        -:  828:// specifies the number of top frames to be skipped, which doesn't
        -:  829:// count against the number of frames to be included.
        -:  830://
        -:  831:// For example, if Foo() calls Bar(), which in turn calls
        -:  832:// GetCurrentOsStackTraceExceptTop(..., 1), Foo() will be included in
        -:  833:// the trace but Bar() and GetCurrentOsStackTraceExceptTop() won't.
        -:  834:        GTEST_API_ std::string GetCurrentOsStackTraceExceptTop(
        -:  835:                UnitTest *unit_test, int skip_count);
        -:  836:
        -:  837:// Helpers for suppressing warnings on unreachable code or constant
        -:  838:// condition.
        -:  839:
        -:  840:// Always returns true.
        -:  841:        GTEST_API_ bool AlwaysTrue();
        -:  842:
        -:  843:// Always returns false.
        -:  844:        inline bool AlwaysFalse() { return !AlwaysTrue(); }
        -:  845:
        -:  846:// Helper for suppressing false warning from Clang on a const char*
        -:  847:// variable declared in a conditional expression always being NULL in
        -:  848:// the else branch.
        -:  849:        struct GTEST_API_ ConstCharPtr {
        -:  850:            ConstCharPtr(const char *str) : value(str) {}
        -:  851:
        -:  852:            operator bool() const { return true; }
        -:  853:
        -:  854:            const char *value;
        -:  855:        };
        -:  856:
        -:  857:// Helper for declaring std::string within 'if' statement
        -:  858:// in pre C++17 build environment.
        -:  859:        struct TrueWithString {
        -:  860:            TrueWithString() = default;
        -:  861:
        -:  862:            explicit TrueWithString(const char *str) : value(str) {}
        -:  863:
        -:  864:            explicit TrueWithString(const std::string &str) : value(str) {}
        -:  865:
        -:  866:            explicit operator bool() const { return true; }
        -:  867:
        -:  868:            std::string value;
        -:  869:        };
        -:  870:
        -:  871:// A simple Linear Congruential Generator for generating random
        -:  872:// numbers with a uniform distribution.  Unlike rand() and srand(), it
        -:  873:// doesn't use global state (and therefore can't interfere with user
        -:  874:// code).  Unlike rand_r(), it's portable.  An LCG isn't very random,
        -:  875:// but it's good enough for our purposes.
        -:  876:        class GTEST_API_ Random {
        -:  877:        public:
        -:  878:            static const uint32_t kMaxRange = 1u << 31;
        -:  879:
        -:  880:            explicit Random(uint32_t seed) : state_(seed) {}
        -:  881:
        -:  882:            void Reseed(uint32_t seed) { state_ = seed; }
        -:  883:
        -:  884:            // Generates a random number from [0, range).  Crashes if 'range' is
        -:  885:            // 0 or greater than kMaxRange.
        -:  886:            uint32_t Generate(uint32_t range);
        -:  887:
        -:  888:        private:
        -:  889:            uint32_t state_;
        -:  890:            GTEST_DISALLOW_COPY_AND_ASSIGN_(Random);
        -:  891:        };
        -:  892:
        -:  893:// Turns const U&, U&, const U, and U all into U.
        -:  894:#define GTEST_REMOVE_REFERENCE_AND_CONST_(T) \
        -:  895:  typename std::remove_const<typename std::remove_reference<T>::type>::type
        -:  896:
        -:  897:// IsAProtocolMessage<T>::value is a compile-time bool constant that's
        -:  898:// true if and only if T is type proto2::MessageLite or a subclass of it.
        -:  899:        template<typename T>
        -:  900:        struct IsAProtocolMessage
        -:  901:                : public std::is_convertible<const T *, const ::proto2::MessageLite *> {
        -:  902:        };
        -:  903:
        -:  904:// When the compiler sees expression IsContainerTest<C>(0), if C is an
        -:  905:// STL-style container class, the first overload of IsContainerTest
        -:  906:// will be viable (since both C::iterator* and C::const_iterator* are
        -:  907:// valid types and NULL can be implicitly converted to them).  It will
        -:  908:// be picked over the second overload as 'int' is a perfect match for
        -:  909:// the type of argument 0.  If C::iterator or C::const_iterator is not
        -:  910:// a valid type, the first overload is not viable, and the second
        -:  911:// overload will be picked.  Therefore, we can determine whether C is
        -:  912:// a container class by checking the type of IsContainerTest<C>(0).
        -:  913:// The value of the expression is insignificant.
        -:  914://
        -:  915:// In C++11 mode we check the existence of a const_iterator and that an
        -:  916:// iterator is properly implemented for the container.
        -:  917://
        -:  918:// For pre-C++11 that we look for both C::iterator and C::const_iterator.
        -:  919:// The reason is that C++ injects the name of a class as a member of the
        -:  920:// class itself (e.g. you can refer to class iterator as either
        -:  921:// 'iterator' or 'iterator::iterator').  If we look for C::iterator
        -:  922:// only, for example, we would mistakenly think that a class named
        -:  923:// iterator is an STL container.
        -:  924://
        -:  925:// Also note that the simpler approach of overloading
        -:  926:// IsContainerTest(typename C::const_iterator*) and
        -:  927:// IsContainerTest(...) doesn't work with Visual Age C++ and Sun C++.
        -:  928:        typedef int IsContainer;
        -:  929:
        -:  930:        template<class C,
        -:  931:                class Iterator = decltype(::std::declval<const C &>().begin()),
        -:  932:                class = decltype(::std::declval<const C &>().end()),
        -:  933:                class = decltype(++::std::declval<Iterator &>()),
        -:  934:                class = decltype(*::std::declval<Iterator>()),
        -:  935:                class = typename C::const_iterator>
        -:  936:        IsContainer IsContainerTest(int /* dummy */) {
        -:  937:            return 0;
        -:  938:        }
        -:  939:
        -:  940:        typedef char IsNotContainer;
        -:  941:
        -:  942:        template<class C>
        -:  943:        IsNotContainer IsContainerTest(long /* dummy */) { return '\0'; }
        -:  944:
        -:  945:// Trait to detect whether a type T is a hash table.
        -:  946:// The heuristic used is that the type contains an inner type `hasher` and does
        -:  947:// not contain an inner type `reverse_iterator`.
        -:  948:// If the container is iterable in reverse, then order might actually matter.
        -:  949:        template<typename T>
        -:  950:        struct IsHashTable {
        -:  951:        private:
        -:  952:            template<typename U>
        -:  953:            static char test(typename U::hasher *, typename U::reverse_iterator *);
        -:  954:
        -:  955:            template<typename U>
        -:  956:            static int test(typename U::hasher *, ...);
        -:  957:
        -:  958:            template<typename U>
        -:  959:            static char test(...);
        -:  960:
        -:  961:        public:
        -:  962:            static const bool value = sizeof(test<T>(nullptr, nullptr)) == sizeof(int);
        -:  963:        };
        -:  964:
        -:  965:        template<typename T>
        -:  966:        const bool IsHashTable<T>::value;
        -:  967:
        -:  968:        template<typename C,
        -:  969:                bool = sizeof(IsContainerTest<C>(0)) == sizeof(IsContainer)>
        -:  970:        struct IsRecursiveContainerImpl;
        -:  971:
        -:  972:        template<typename C>
        -:  973:        struct IsRecursiveContainerImpl<C, false> : public std::false_type {
        -:  974:        };
        -:  975:
        -:  976:// Since the IsRecursiveContainerImpl depends on the IsContainerTest we need to
        -:  977:// obey the same inconsistencies as the IsContainerTest, namely check if
        -:  978:// something is a container is relying on only const_iterator in C++11 and
        -:  979:// is relying on both const_iterator and iterator otherwise
        -:  980:        template<typename C>
        -:  981:        struct IsRecursiveContainerImpl<C, true> {
        -:  982:            using value_type = decltype(*std::declval<typename C::const_iterator>());
        -:  983:            using type =
        -:  984:            std::is_same<typename std::remove_const<
        -:  985:                    typename std::remove_reference<value_type>::type>::type,
        -:  986:                    C>;
        -:  987:        };
        -:  988:
        -:  989:// IsRecursiveContainer<Type> is a unary compile-time predicate that
        -:  990:// evaluates whether C is a recursive container type. A recursive container
        -:  991:// type is a container type whose value_type is equal to the container type
        -:  992:// itself. An example for a recursive container type is
        -:  993:// boost::filesystem::path, whose iterator has a value_type that is equal to
        -:  994:// boost::filesystem::path.
        -:  995:        template<typename C>
        -:  996:        struct IsRecursiveContainer : public IsRecursiveContainerImpl<C>::type {
        -:  997:        };
        -:  998:
        -:  999:// Utilities for native arrays.
        -: 1000:
        -: 1001:// ArrayEq() compares two k-dimensional native arrays using the
        -: 1002:// elements' operator==, where k can be any integer >= 0.  When k is
        -: 1003:// 0, ArrayEq() degenerates into comparing a single pair of values.
        -: 1004:
        -: 1005:        template<typename T, typename U>
        -: 1006:        bool ArrayEq(const T *lhs, size_t size, const U *rhs);
        -: 1007:
        -: 1008:// This generic version is used when k is 0.
        -: 1009:        template<typename T, typename U>
        -: 1010:        inline bool ArrayEq(const T &lhs, const U &rhs) { return lhs == rhs; }
        -: 1011:
        -: 1012:// This overload is used when k >= 1.
        -: 1013:        template<typename T, typename U, size_t N>
        -: 1014:        inline bool ArrayEq(const T(&lhs)[N], const U(&rhs)[N]) {
        -: 1015:            return internal::ArrayEq(lhs, N, rhs);
        -: 1016:        }
        -: 1017:
        -: 1018:// This helper reduces code bloat.  If we instead put its logic inside
        -: 1019:// the previous ArrayEq() function, arrays with different sizes would
        -: 1020:// lead to different copies of the template code.
        -: 1021:        template<typename T, typename U>
        -: 1022:        bool ArrayEq(const T *lhs, size_t size, const U *rhs) {
        -: 1023:            for (size_t i = 0; i != size; i++) {
        -: 1024:                if (!internal::ArrayEq(lhs[i], rhs[i]))
        -: 1025:                    return false;
        -: 1026:            }
        -: 1027:            return true;
        -: 1028:        }
        -: 1029:
        -: 1030:// Finds the first element in the iterator range [begin, end) that
        -: 1031:// equals elem.  Element may be a native array type itself.
        -: 1032:        template<typename Iter, typename Element>
        -: 1033:        Iter ArrayAwareFind(Iter begin, Iter end, const Element &elem) {
        -: 1034:            for (Iter it = begin; it != end; ++it) {
        -: 1035:                if (internal::ArrayEq(*it, elem))
        -: 1036:                    return it;
        -: 1037:            }
        -: 1038:            return end;
        -: 1039:        }
        -: 1040:
        -: 1041:// CopyArray() copies a k-dimensional native array using the elements'
        -: 1042:// operator=, where k can be any integer >= 0.  When k is 0,
        -: 1043:// CopyArray() degenerates into copying a single value.
        -: 1044:
        -: 1045:        template<typename T, typename U>
        -: 1046:        void CopyArray(const T *from, size_t size, U *to);
        -: 1047:
        -: 1048:// This generic version is used when k is 0.
        -: 1049:        template<typename T, typename U>
        -: 1050:        inline void CopyArray(const T &from, U *to) { *to = from; }
        -: 1051:
        -: 1052:// This overload is used when k >= 1.
        -: 1053:        template<typename T, typename U, size_t N>
        -: 1054:        inline void CopyArray(const T(&from)[N], U(*to)[N]) {
        -: 1055:            internal::CopyArray(from, N, *to);
        -: 1056:        }
        -: 1057:
        -: 1058:// This helper reduces code bloat.  If we instead put its logic inside
        -: 1059:// the previous CopyArray() function, arrays with different sizes
        -: 1060:// would lead to different copies of the template code.
        -: 1061:        template<typename T, typename U>
        -: 1062:        void CopyArray(const T *from, size_t size, U *to) {
        -: 1063:            for (size_t i = 0; i != size; i++) {
        -: 1064:                internal::CopyArray(from[i], to + i);
        -: 1065:            }
        -: 1066:        }
        -: 1067:
        -: 1068:// The relation between an NativeArray object (see below) and the
        -: 1069:// native array it represents.
        -: 1070:// We use 2 different structs to allow non-copyable types to be used, as long
        -: 1071:// as RelationToSourceReference() is passed.
        -: 1072:        struct RelationToSourceReference {
        -: 1073:        };
        -: 1074:        struct RelationToSourceCopy {
        -: 1075:        };
        -: 1076:
        -: 1077:// Adapts a native array to a read-only STL-style container.  Instead
        -: 1078:// of the complete STL container concept, this adaptor only implements
        -: 1079:// members useful for Google Mock's container matchers.  New members
        -: 1080:// should be added as needed.  To simplify the implementation, we only
        -: 1081:// support Element being a raw type (i.e. having no top-level const or
        -: 1082:// reference modifier).  It's the client's responsibility to satisfy
        -: 1083:// this requirement.  Element can be an array type itself (hence
        -: 1084:// multi-dimensional arrays are supported).
        -: 1085:        template<typename Element>
        -: 1086:        class NativeArray {
        -: 1087:        public:
        -: 1088:            // STL-style container typedefs.
        -: 1089:            typedef Element value_type;
        -: 1090:            typedef Element *iterator;
        -: 1091:            typedef const Element *const_iterator;
        -: 1092:
        -: 1093:            // Constructs from a native array. References the source.
        -: 1094:            NativeArray(const Element *array, size_t count, RelationToSourceReference) {
        -: 1095:                InitRef(array, count);
        -: 1096:            }
        -: 1097:
        -: 1098:            // Constructs from a native array. Copies the source.
        -: 1099:            NativeArray(const Element *array, size_t count, RelationToSourceCopy) {
        -: 1100:                InitCopy(array, count);
        -: 1101:            }
        -: 1102:
        -: 1103:            // Copy constructor.
        -: 1104:            NativeArray(const NativeArray &rhs) {
        -: 1105:                (this->*rhs.clone_)(rhs.array_, rhs.size_);
        -: 1106:            }
        -: 1107:
        -: 1108:            ~NativeArray() {
        -: 1109:                if (clone_ != &NativeArray::InitRef)
        -: 1110:                    delete[] array_;
        -: 1111:            }
        -: 1112:
        -: 1113:            // STL-style container methods.
        -: 1114:            size_t size() const { return size_; }
        -: 1115:
        -: 1116:            const_iterator begin() const { return array_; }
        -: 1117:
        -: 1118:            const_iterator end() const { return array_ + size_; }
        -: 1119:
        -: 1120:            bool operator==(const NativeArray &rhs) const {
        -: 1121:                return size() == rhs.size() &&
        -: 1122:                       ArrayEq(begin(), size(), rhs.begin());
        -: 1123:            }
        -: 1124:
        -: 1125:        private:
        -: 1126:            static_assert(!std::is_const<Element>::value, "Type must not be const");
        -: 1127:            static_assert(!std::is_reference<Element>::value,
        -: 1128:                          "Type must not be a reference");
        -: 1129:
        -: 1130:            // Initializes this object with a copy of the input.
        -: 1131:            void InitCopy(const Element *array, size_t a_size) {
        -: 1132:                Element *const copy = new Element[a_size];
        -: 1133:                CopyArray(array, a_size, copy);
        -: 1134:                array_ = copy;
        -: 1135:                size_ = a_size;
        -: 1136:                clone_ = &NativeArray::InitCopy;
        -: 1137:            }
        -: 1138:
        -: 1139:            // Initializes this object with a reference of the input.
        -: 1140:            void InitRef(const Element *array, size_t a_size) {
        -: 1141:                array_ = array;
        -: 1142:                size_ = a_size;
        -: 1143:                clone_ = &NativeArray::InitRef;
        -: 1144:            }
        -: 1145:
        -: 1146:            const Element *array_;
        -: 1147:            size_t size_;
        -: 1148:
        -: 1149:            void (NativeArray::*clone_)(const Element *, size_t);
        -: 1150:        };
        -: 1151:
        -: 1152:// Backport of std::index_sequence.
        -: 1153:        template<size_t... Is>
        -: 1154:        struct IndexSequence {
        -: 1155:            using type = IndexSequence;
        -: 1156:        };
        -: 1157:
        -: 1158:// Double the IndexSequence, and one if plus_one is true.
        -: 1159:        template<bool plus_one, typename T, size_t sizeofT>
        -: 1160:        struct DoubleSequence;
        -: 1161:        template<size_t... I, size_t sizeofT>
        -: 1162:        struct DoubleSequence<true, IndexSequence<I...>, sizeofT> {
        -: 1163:            using type = IndexSequence<I..., (sizeofT + I)..., 2 * sizeofT>;
        -: 1164:        };
        -: 1165:        template<size_t... I, size_t sizeofT>
        -: 1166:        struct DoubleSequence<false, IndexSequence<I...>, sizeofT> {
        -: 1167:            using type = IndexSequence<I..., (sizeofT + I)...>;
        -: 1168:        };
        -: 1169:
        -: 1170:// Backport of std::make_index_sequence.
        -: 1171:// It uses O(ln(N)) instantiation depth.
        -: 1172:        template<size_t N>
        -: 1173:        struct MakeIndexSequence
        -: 1174:                : DoubleSequence<N % 2 == 1, typename MakeIndexSequence<N / 2>::type,
        -: 1175:                        N / 2>::type {
        -: 1176:        };
        -: 1177:
        -: 1178:        template<>
        -: 1179:        struct MakeIndexSequence<0> : IndexSequence<> {
        -: 1180:        };
        -: 1181:
        -: 1182:        template<size_t>
        -: 1183:        struct Ignore {
        -: 1184:            Ignore(...);  // NOLINT
        -: 1185:        };
        -: 1186:
        -: 1187:        template<typename>
        -: 1188:        struct ElemFromListImpl;
        -: 1189:
        -: 1190:        template<size_t... I>
        -: 1191:        struct ElemFromListImpl<IndexSequence<I...>> {
        -: 1192:            // We make Ignore a template to solve a problem with MSVC.
        -: 1193:            // A non-template Ignore would work fine with `decltype(Ignore(I))...`, but
        -: 1194:            // MSVC doesn't understand how to deal with that pack expansion.
        -: 1195:            // Use `0 * I` to have a single instantiation of Ignore.
        -: 1196:            template<typename R>
        -: 1197:            static R Apply(Ignore<0 * I>..., R (*)(), ...);
        -: 1198:        };
        -: 1199:
        -: 1200:        template<size_t N, typename... T>
        -: 1201:        struct ElemFromList {
        -: 1202:            using type =
        -: 1203:            decltype(ElemFromListImpl<typename MakeIndexSequence<N>::type>::Apply(
        -: 1204:                    static_cast<T (*)()>(nullptr)...));
        -: 1205:        };
        -: 1206:
        -: 1207:        template<typename... T>
        -: 1208:        class FlatTuple;
        -: 1209:
        -: 1210:        template<typename Derived, size_t I>
        -: 1211:        struct FlatTupleElemBase;
        -: 1212:
        -: 1213:        template<typename... T, size_t I>
        -: 1214:        struct FlatTupleElemBase<FlatTuple<T...>, I> {
        -: 1215:            using value_type = typename ElemFromList<I, T...>::type;
        -: 1216:
        -: 1217:            FlatTupleElemBase() = default;
        -: 1218:
        -: 1219:            explicit FlatTupleElemBase(value_type t) : value(std::move(t)) {}
        -: 1220:
        -: 1221:            value_type value;
        -: 1222:        };
        -: 1223:
        -: 1224:        template<typename Derived, typename Idx>
        -: 1225:        struct FlatTupleBase;
        -: 1226:
        -: 1227:        template<size_t... Idx, typename... T>
        -: 1228:        struct FlatTupleBase<FlatTuple<T...>, IndexSequence<Idx...>>
        -: 1229:                : FlatTupleElemBase<FlatTuple<T...>, Idx> ... {
        -: 1230:            using Indices = IndexSequence<Idx...>;
        -: 1231:
        -: 1232:            FlatTupleBase() = default;
        -: 1233:
        -: 1234:            explicit FlatTupleBase(T... t)
        -: 1235:                    : FlatTupleElemBase<FlatTuple<T...>, Idx>(std::move(t))... {}
        -: 1236:        };
        -: 1237:
        -: 1238:// Analog to std::tuple but with different tradeoffs.
        -: 1239:// This class minimizes the template instantiation depth, thus allowing more
        -: 1240:// elements than std::tuple would. std::tuple has been seen to require an
        -: 1241:// instantiation depth of more than 10x the number of elements in some
        -: 1242:// implementations.
        -: 1243:// FlatTuple and ElemFromList are not recursive and have a fixed depth
        -: 1244:// regardless of T...
        -: 1245:// MakeIndexSequence, on the other hand, it is recursive but with an
        -: 1246:// instantiation depth of O(ln(N)).
        -: 1247:        template<typename... T>
        -: 1248:        class FlatTuple
        -: 1249:                : private FlatTupleBase<FlatTuple<T...>,
        -: 1250:                        typename MakeIndexSequence<sizeof...(T)>::type> {
        -: 1251:            using Indices = typename FlatTupleBase<
        -: 1252:                    FlatTuple<T...>, typename MakeIndexSequence<sizeof...(T)>::type>::Indices;
        -: 1253:
        -: 1254:        public:
        -: 1255:            FlatTuple() = default;
        -: 1256:
        -: 1257:            explicit FlatTuple(T... t) : FlatTuple::FlatTupleBase(std::move(t)...) {}
        -: 1258:
        -: 1259:            template<size_t I>
        -: 1260:            const typename ElemFromList<I, T...>::type &Get() const {
        -: 1261:                return static_cast<const FlatTupleElemBase <FlatTuple, I> *>(this)->value;
        -: 1262:            }
        -: 1263:
        -: 1264:            template<size_t I>
        -: 1265:            typename ElemFromList<I, T...>::type &Get() {
        -: 1266:                return static_cast<FlatTupleElemBase <FlatTuple, I> *>(this)->value;
        -: 1267:            }
        -: 1268:        };
        -: 1269:
        -: 1270:// Utility functions to be called with static_assert to induce deprecation
        -: 1271:// warnings.
        -: 1272:        GTEST_INTERNAL_DEPRECATED(
        -: 1273:                "INSTANTIATE_TEST_CASE_P is deprecated, please use "
        -: 1274:                "INSTANTIATE_TEST_SUITE_P")
        -: 1275:        constexpr bool InstantiateTestCase_P_IsDeprecated() { return true; }
        -: 1276:
        -: 1277:        GTEST_INTERNAL_DEPRECATED(
        -: 1278:                "TYPED_TEST_CASE_P is deprecated, please use "
        -: 1279:                "TYPED_TEST_SUITE_P")
        -: 1280:        constexpr bool TypedTestCase_P_IsDeprecated() { return true; }
        -: 1281:
        -: 1282:        GTEST_INTERNAL_DEPRECATED(
        -: 1283:                "TYPED_TEST_CASE is deprecated, please use "
        -: 1284:                "TYPED_TEST_SUITE")
        -: 1285:        constexpr bool TypedTestCaseIsDeprecated() { return true; }
        -: 1286:
        -: 1287:        GTEST_INTERNAL_DEPRECATED(
        -: 1288:                "REGISTER_TYPED_TEST_CASE_P is deprecated, please use "
        -: 1289:                "REGISTER_TYPED_TEST_SUITE_P")
        -: 1290:        constexpr bool RegisterTypedTestCase_P_IsDeprecated() { return true; }
        -: 1291:
        -: 1292:        GTEST_INTERNAL_DEPRECATED(
        -: 1293:                "INSTANTIATE_TYPED_TEST_CASE_P is deprecated, please use "
        -: 1294:                "INSTANTIATE_TYPED_TEST_SUITE_P")
        -: 1295:        constexpr bool InstantiateTypedTestCase_P_IsDeprecated() { return true; }
        -: 1296:
        -: 1297:    }  // namespace internal
        -: 1298:}  // namespace testing
        -: 1299:
        -: 1300:#define GTEST_MESSAGE_AT_(file, line, message, result_type) \
        -: 1301:  ::testing::internal::AssertHelper(result_type, file, line, message) \
        -: 1302:    = ::testing::Message()
        -: 1303:
        -: 1304:#define GTEST_MESSAGE_(message, result_type) \
        -: 1305:  GTEST_MESSAGE_AT_(__FILE__, __LINE__, message, result_type)
        -: 1306:
        -: 1307:#define GTEST_FATAL_FAILURE_(message) \
        -: 1308:  return GTEST_MESSAGE_(message, ::testing::TestPartResult::kFatalFailure)
        -: 1309:
        -: 1310:#define GTEST_NONFATAL_FAILURE_(message) \
        -: 1311:  GTEST_MESSAGE_(message, ::testing::TestPartResult::kNonFatalFailure)
        -: 1312:
        -: 1313:#define GTEST_SUCCESS_(message) \
        -: 1314:  GTEST_MESSAGE_(message, ::testing::TestPartResult::kSuccess)
        -: 1315:
        -: 1316:#define GTEST_SKIP_(message) \
        -: 1317:  return GTEST_MESSAGE_(message, ::testing::TestPartResult::kSkip)
        -: 1318:
        -: 1319:// Suppress MSVC warning 4072 (unreachable code) for the code following
        -: 1320:// statement if it returns or throws (or doesn't return or throw in some
        -: 1321:// situations).
        -: 1322:// NOTE: The "else" is important to keep this expansion to prevent a top-level
        -: 1323:// "else" from attaching to our "if".
        -: 1324:#define GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement) \
        -: 1325:  if (::testing::internal::AlwaysTrue()) {                        \
        -: 1326:    statement;                                                    \
        -: 1327:  } else                     /* NOLINT */                         \
        -: 1328:    static_assert(true, "")  // User must have a semicolon after expansion.
        -: 1329:
        -: 1330:#define GTEST_TEST_THROW_(statement, expected_exception, fail) \
        -: 1331:  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \
        -: 1332:  if (::testing::internal::ConstCharPtr gtest_msg = "") { \
        -: 1333:    bool gtest_caught_expected = false; \
        -: 1334:    try { \
        -: 1335:      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \
        -: 1336:    } \
        -: 1337:    catch (expected_exception const&) { \
        -: 1338:      gtest_caught_expected = true; \
        -: 1339:    } \
        -: 1340:    catch (...) { \
        -: 1341:      gtest_msg.value = \
        -: 1342:          "Expected: " #statement " throws an exception of type " \
        -: 1343:          #expected_exception ".\n  Actual: it throws a different type."; \
        -: 1344:      goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \
        -: 1345:    } \
        -: 1346:    if (!gtest_caught_expected) { \
        -: 1347:      gtest_msg.value = \
        -: 1348:          "Expected: " #statement " throws an exception of type " \
        -: 1349:          #expected_exception ".\n  Actual: it throws nothing."; \
        -: 1350:      goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \
        -: 1351:    } \
        -: 1352:  } else \
        -: 1353:    GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__): \
        -: 1354:      fail(gtest_msg.value)
        -: 1355:
        -: 1356:#if GTEST_HAS_EXCEPTIONS
        -: 1357:
        -: 1358:#define GTEST_TEST_NO_THROW_CATCH_STD_EXCEPTION_() \
        -: 1359:  catch (std::exception const& e) { \
        -: 1360:    gtest_msg.value = ( \
        -: 1361:      "it throws std::exception-derived exception with description: \"" \
        -: 1362:    ); \
        -: 1363:    gtest_msg.value += e.what(); \
        -: 1364:    gtest_msg.value += "\"."; \
        -: 1365:    goto GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__); \
        -: 1366:  }
        -: 1367:
        -: 1368:#else  // GTEST_HAS_EXCEPTIONS
        -: 1369:
        -: 1370:#define GTEST_TEST_NO_THROW_CATCH_STD_EXCEPTION_()
        -: 1371:
        -: 1372:#endif  // GTEST_HAS_EXCEPTIONS
        -: 1373:
        -: 1374:#define GTEST_TEST_NO_THROW_(statement, fail) \
        -: 1375:  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \
        -: 1376:  if (::testing::internal::TrueWithString gtest_msg{}) { \
        -: 1377:    try { \
        -: 1378:      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \
        -: 1379:    } \
        -: 1380:    GTEST_TEST_NO_THROW_CATCH_STD_EXCEPTION_() \
        -: 1381:    catch (...) { \
        -: 1382:      gtest_msg.value = "it throws."; \
        -: 1383:      goto GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__); \
        -: 1384:    } \
        -: 1385:  } else \
        -: 1386:    GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__): \
        -: 1387:      fail(("Expected: " #statement " doesn't throw an exception.\n" \
        -: 1388:            "  Actual: " + gtest_msg.value).c_str())
        -: 1389:
        -: 1390:#define GTEST_TEST_ANY_THROW_(statement, fail) \
        -: 1391:  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \
        -: 1392:  if (::testing::internal::AlwaysTrue()) { \
        -: 1393:    bool gtest_caught_any = false; \
        -: 1394:    try { \
        -: 1395:      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \
        -: 1396:    } \
        -: 1397:    catch (...) { \
        -: 1398:      gtest_caught_any = true; \
        -: 1399:    } \
        -: 1400:    if (!gtest_caught_any) { \
        -: 1401:      goto GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__); \
        -: 1402:    } \
        -: 1403:  } else \
        -: 1404:    GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__): \
        -: 1405:      fail("Expected: " #statement " throws an exception.\n" \
        -: 1406:           "  Actual: it doesn't.")
        -: 1407:
        -: 1408:
        -: 1409:// Implements Boolean test assertions such as EXPECT_TRUE. expression can be
        -: 1410:// either a boolean expression or an AssertionResult. text is a textual
        -: 1411:// represenation of expression as it was passed into the EXPECT_TRUE.
        -: 1412:#define GTEST_TEST_BOOLEAN_(expression, text, actual, expected, fail) \
        -: 1413:  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \
        -: 1414:  if (const ::testing::AssertionResult gtest_ar_ = \
        -: 1415:      ::testing::AssertionResult(expression)) \
        -: 1416:    ; \
        -: 1417:  else \
        -: 1418:    fail(::testing::internal::GetBoolAssertionFailureMessage(\
        -: 1419:        gtest_ar_, text, #actual, #expected).c_str())
        -: 1420:
        -: 1421:#define GTEST_TEST_NO_FATAL_FAILURE_(statement, fail) \
        -: 1422:  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \
        -: 1423:  if (::testing::internal::AlwaysTrue()) { \
        -: 1424:    ::testing::internal::HasNewFatalFailureHelper gtest_fatal_failure_checker; \
        -: 1425:    GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \
        -: 1426:    if (gtest_fatal_failure_checker.has_new_fatal_failure()) { \
        -: 1427:      goto GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__); \
        -: 1428:    } \
        -: 1429:  } else \
        -: 1430:    GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__): \
        -: 1431:      fail("Expected: " #statement " doesn't generate new fatal " \
        -: 1432:           "failures in the current thread.\n" \
        -: 1433:           "  Actual: it does.")
        -: 1434:
        -: 1435:// Expands to the name of the class that implements the given test.
        -: 1436:#define GTEST_TEST_CLASS_NAME_(test_suite_name, test_name) \
        -: 1437:  test_suite_name##_##test_name##_Test
        -: 1438:
        -: 1439:// Helper macro for defining tests.
        -: 1440:#define GTEST_TEST_(test_suite_name, test_name, parent_class, parent_id)      \
        -: 1441:  static_assert(sizeof(GTEST_STRINGIFY_(test_suite_name)) > 1,                \
        -: 1442:                "test_suite_name must not be empty");                         \
        -: 1443:  static_assert(sizeof(GTEST_STRINGIFY_(test_name)) > 1,                      \
        -: 1444:                "test_name must not be empty");                               \
        -: 1445:  class GTEST_TEST_CLASS_NAME_(test_suite_name, test_name)                    \
        -: 1446:      : public parent_class {                                                 \
        -: 1447:   public:                                                                    \
        -: 1448:    GTEST_TEST_CLASS_NAME_(test_suite_name, test_name)() {}                   \
        -: 1449:    ~GTEST_TEST_CLASS_NAME_(test_suite_name, test_name)() override = default; \
        -: 1450:    GTEST_DISALLOW_COPY_AND_ASSIGN_(GTEST_TEST_CLASS_NAME_(test_suite_name,   \
        -: 1451:                                                           test_name));       \
        -: 1452:    GTEST_DISALLOW_MOVE_AND_ASSIGN_(GTEST_TEST_CLASS_NAME_(test_suite_name,   \
        -: 1453:                                                           test_name));       \
        -: 1454:                                                                              \
        -: 1455:   private:                                                                   \
        -: 1456:    void TestBody() override;                                                 \
        -: 1457:    static ::testing::TestInfo* const test_info_ GTEST_ATTRIBUTE_UNUSED_;     \
        -: 1458:  };                                                                          \
        -: 1459:                                                                              \
        -: 1460:  ::testing::TestInfo* const GTEST_TEST_CLASS_NAME_(test_suite_name,          \
        -: 1461:                                                    test_name)::test_info_ =  \
        -: 1462:      ::testing::internal::MakeAndRegisterTestInfo(                           \
        -: 1463:          #test_suite_name, #test_name, nullptr, nullptr,                     \
        -: 1464:          ::testing::internal::CodeLocation(__FILE__, __LINE__), (parent_id), \
        -: 1465:          ::testing::internal::SuiteApiResolver<                              \
        -: 1466:              parent_class>::GetSetUpCaseOrSuite(__FILE__, __LINE__),         \
        -: 1467:          ::testing::internal::SuiteApiResolver<                              \
        -: 1468:              parent_class>::GetTearDownCaseOrSuite(__FILE__, __LINE__),      \
        -: 1469:          new ::testing::internal::TestFactoryImpl<GTEST_TEST_CLASS_NAME_(    \
        -: 1470:              test_suite_name, test_name)>);                                  \
        -: 1471:  void GTEST_TEST_CLASS_NAME_(test_suite_name, test_name)::TestBody()
        -: 1472:
        -: 1473:#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_
