        -:    0:Source:/usr/local/Cellar/opencv/4.3.0_4/include/opencv4/opencv2/core/types.hpp
        -:    0:Graph:/Users/bytedance/CLionProjects/C-projcet/cmake-build-debug/CMakeFiles/cppProject.dir/code/main.cpp.gcno
        -:    0:Data:/Users/bytedance/CLionProjects/C-projcet/cmake-build-debug/CMakeFiles/cppProject.dir/code/main.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*M///////////////////////////////////////////////////////////////////////////////////////
        -:    2://
        -:    3://  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
        -:    4://
        -:    5://  By downloading, copying, installing or using the software you agree to this license.
        -:    6://  If you do not agree to this license, do not download, install,
        -:    7://  copy or use the software.
        -:    8://
        -:    9://
        -:   10://                          License Agreement
        -:   11://                For Open Source Computer Vision Library
        -:   12://
        -:   13:// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.
        -:   14:// Copyright (C) 2009, Willow Garage Inc., all rights reserved.
        -:   15:// Copyright (C) 2013, OpenCV Foundation, all rights reserved.
        -:   16:// Third party copyrights are property of their respective owners.
        -:   17://
        -:   18:// Redistribution and use in source and binary forms, with or without modification,
        -:   19:// are permitted provided that the following conditions are met:
        -:   20://
        -:   21://   * Redistribution's of source code must retain the above copyright notice,
        -:   22://     this list of conditions and the following disclaimer.
        -:   23://
        -:   24://   * Redistribution's in binary form must reproduce the above copyright notice,
        -:   25://     this list of conditions and the following disclaimer in the documentation
        -:   26://     and/or other materials provided with the distribution.
        -:   27://
        -:   28://   * The name of the copyright holders may not be used to endorse or promote products
        -:   29://     derived from this software without specific prior written permission.
        -:   30://
        -:   31:// This software is provided by the copyright holders and contributors "as is" and
        -:   32:// any express or implied warranties, including, but not limited to, the implied
        -:   33:// warranties of merchantability and fitness for a particular purpose are disclaimed.
        -:   34:// In no event shall the Intel Corporation or contributors be liable for any direct,
        -:   35:// indirect, incidental, special, exemplary, or consequential damages
        -:   36:// (including, but not limited to, procurement of substitute goods or services;
        -:   37:// loss of use, data, or profits; or business interruption) however caused
        -:   38:// and on any theory of liability, whether in contract, strict liability,
        -:   39:// or tort (including negligence or otherwise) arising in any way out of
        -:   40:// the use of this software, even if advised of the possibility of such damage.
        -:   41://
        -:   42://M*/
        -:   43:
        -:   44:#ifndef OPENCV_CORE_TYPES_HPP
        -:   45:#define OPENCV_CORE_TYPES_HPP
        -:   46:
        -:   47:#ifndef __cplusplus
        -:   48:#  error types.hpp header must be compiled as C++
        -:   49:#endif
        -:   50:
        -:   51:#include <climits>
        -:   52:#include <cfloat>
        -:   53:#include <vector>
        -:   54:#include <limits>
        -:   55:
        -:   56:#include "opencv2/core/cvdef.h"
        -:   57:#include "opencv2/core/cvstd.hpp"
        -:   58:#include "opencv2/core/matx.hpp"
        -:   59:
        -:   60:namespace cv
        -:   61:{
        -:   62:
        -:   63://! @addtogroup core_basic
        -:   64://! @{
        -:   65:
        -:   66://////////////////////////////// Complex //////////////////////////////
        -:   67:
        -:   68:/** @brief  A complex number class.
        -:   69:
        -:   70:  The template class is similar and compatible with std::complex, however it provides slightly
        -:   71:  more convenient access to the real and imaginary parts using through the simple field access, as opposite
        -:   72:  to std::complex::real() and std::complex::imag().
        -:   73:*/
        -:   74:template<typename _Tp> class Complex
        -:   75:{
        -:   76:public:
        -:   77:
        -:   78:    //! default constructor
        -:   79:    Complex();
        -:   80:    Complex( _Tp _re, _Tp _im = 0 );
        -:   81:
        -:   82:    //! conversion to another data type
        -:   83:    template<typename T2> operator Complex<T2>() const;
        -:   84:    //! conjugation
        -:   85:    Complex conj() const;
        -:   86:
        -:   87:    _Tp re, im; //< the real and the imaginary parts
        -:   88:};
        -:   89:
        -:   90:typedef Complex<float> Complexf;
        -:   91:typedef Complex<double> Complexd;
        -:   92:
        -:   93:template<typename _Tp> class DataType< Complex<_Tp> >
        -:   94:{
        -:   95:public:
        -:   96:    typedef Complex<_Tp> value_type;
        -:   97:    typedef value_type   work_type;
        -:   98:    typedef _Tp          channel_type;
        -:   99:
        -:  100:    enum { generic_type = 0,
        -:  101:           channels     = 2,
        -:  102:           fmt          = DataType<channel_type>::fmt + ((channels - 1) << 8)
        -:  103:#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED
        -:  104:           ,depth        = DataType<channel_type>::depth
        -:  105:           ,type         = CV_MAKETYPE(depth, channels)
        -:  106:#endif
        -:  107:    };
        -:  108:
        -:  109:    typedef Vec<channel_type, channels> vec_type;
        -:  110:};
        -:  111:
        -:  112:namespace traits {
        -:  113:template<typename _Tp>
        -:  114:struct Depth< Complex<_Tp> > { enum { value = Depth<_Tp>::value }; };
        -:  115:template<typename _Tp>
        -:  116:struct Type< Complex<_Tp> > { enum { value = CV_MAKETYPE(Depth<_Tp>::value, 2) }; };
        -:  117:} // namespace
        -:  118:
        -:  119:
        -:  120://////////////////////////////// Point_ ////////////////////////////////
        -:  121:
        -:  122:/** @brief Template class for 2D points specified by its coordinates `x` and `y`.
        -:  123:
        -:  124:An instance of the class is interchangeable with C structures, CvPoint and CvPoint2D32f . There is
        -:  125:also a cast operator to convert point coordinates to the specified type. The conversion from
        -:  126:floating-point coordinates to integer coordinates is done by rounding. Commonly, the conversion
        -:  127:uses this operation for each of the coordinates. Besides the class members listed in the
        -:  128:declaration above, the following operations on points are implemented:
        -:  129:@code
        -:  130:    pt1 = pt2 + pt3;
        -:  131:    pt1 = pt2 - pt3;
        -:  132:    pt1 = pt2 * a;
        -:  133:    pt1 = a * pt2;
        -:  134:    pt1 = pt2 / a;
        -:  135:    pt1 += pt2;
        -:  136:    pt1 -= pt2;
        -:  137:    pt1 *= a;
        -:  138:    pt1 /= a;
        -:  139:    double value = norm(pt); // L2 norm
        -:  140:    pt1 == pt2;
        -:  141:    pt1 != pt2;
        -:  142:@endcode
        -:  143:For your convenience, the following type aliases are defined:
        -:  144:@code
        -:  145:    typedef Point_<int> Point2i;
        -:  146:    typedef Point2i Point;
        -:  147:    typedef Point_<float> Point2f;
        -:  148:    typedef Point_<double> Point2d;
        -:  149:@endcode
        -:  150:Example:
        -:  151:@code
        -:  152:    Point2f a(0.3f, 0.f), b(0.f, 0.4f);
        -:  153:    Point pt = (a + b)*10.f;
        -:  154:    cout << pt.x << ", " << pt.y << endl;
        -:  155:@endcode
        -:  156:*/
        -:  157:template<typename _Tp> class Point_
        -:  158:{
        -:  159:public:
        -:  160:    typedef _Tp value_type;
        -:  161:
        -:  162:    //! default constructor
        -:  163:    Point_();
        -:  164:    Point_(_Tp _x, _Tp _y);
        -:  165:    Point_(const Point_& pt);
        -:  166:    Point_(Point_&& pt) CV_NOEXCEPT;
        -:  167:    Point_(const Size_<_Tp>& sz);
        -:  168:    Point_(const Vec<_Tp, 2>& v);
        -:  169:
        -:  170:    Point_& operator = (const Point_& pt);
        -:  171:    Point_& operator = (Point_&& pt) CV_NOEXCEPT;
        -:  172:    //! conversion to another data type
        -:  173:    template<typename _Tp2> operator Point_<_Tp2>() const;
        -:  174:
        -:  175:    //! conversion to the old-style C structures
        -:  176:    operator Vec<_Tp, 2>() const;
        -:  177:
        -:  178:    //! dot product
        -:  179:    _Tp dot(const Point_& pt) const;
        -:  180:    //! dot product computed in double-precision arithmetics
        -:  181:    double ddot(const Point_& pt) const;
        -:  182:    //! cross-product
        -:  183:    double cross(const Point_& pt) const;
        -:  184:    //! checks whether the point is inside the specified rectangle
        -:  185:    bool inside(const Rect_<_Tp>& r) const;
        -:  186:    _Tp x; //!< x coordinate of the point
        -:  187:    _Tp y; //!< y coordinate of the point
        -:  188:};
        -:  189:
        -:  190:typedef Point_<int> Point2i;
        -:  191:typedef Point_<int64> Point2l;
        -:  192:typedef Point_<float> Point2f;
        -:  193:typedef Point_<double> Point2d;
        -:  194:typedef Point2i Point;
        -:  195:
        -:  196:template<typename _Tp> class DataType< Point_<_Tp> >
        -:  197:{
        -:  198:public:
        -:  199:    typedef Point_<_Tp>                               value_type;
        -:  200:    typedef Point_<typename DataType<_Tp>::work_type> work_type;
        -:  201:    typedef _Tp                                       channel_type;
        -:  202:
        -:  203:    enum { generic_type = 0,
        -:  204:           channels     = 2,
        -:  205:           fmt          = traits::SafeFmt<channel_type>::fmt + ((channels - 1) << 8)
        -:  206:#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED
        -:  207:           ,depth        = DataType<channel_type>::depth
        -:  208:           ,type         = CV_MAKETYPE(depth, channels)
        -:  209:#endif
        -:  210:         };
        -:  211:
        -:  212:    typedef Vec<channel_type, channels> vec_type;
        -:  213:};
        -:  214:
        -:  215:namespace traits {
        -:  216:template<typename _Tp>
        -:  217:struct Depth< Point_<_Tp> > { enum { value = Depth<_Tp>::value }; };
        -:  218:template<typename _Tp>
        -:  219:struct Type< Point_<_Tp> > { enum { value = CV_MAKETYPE(Depth<_Tp>::value, 2) }; };
        -:  220:} // namespace
        -:  221:
        -:  222:
        -:  223://////////////////////////////// Point3_ ////////////////////////////////
        -:  224:
        -:  225:/** @brief Template class for 3D points specified by its coordinates `x`, `y` and `z`.
        -:  226:
        -:  227:An instance of the class is interchangeable with the C structure CvPoint2D32f . Similarly to
        -:  228:Point_ , the coordinates of 3D points can be converted to another type. The vector arithmetic and
        -:  229:comparison operations are also supported.
        -:  230:
        -:  231:The following Point3_\<\> aliases are available:
        -:  232:@code
        -:  233:    typedef Point3_<int> Point3i;
        -:  234:    typedef Point3_<float> Point3f;
        -:  235:    typedef Point3_<double> Point3d;
        -:  236:@endcode
        -:  237:@see cv::Point3i, cv::Point3f and cv::Point3d
        -:  238:*/
        -:  239:template<typename _Tp> class Point3_
        -:  240:{
        -:  241:public:
        -:  242:    typedef _Tp value_type;
        -:  243:
        -:  244:    //! default constructor
        -:  245:    Point3_();
        -:  246:    Point3_(_Tp _x, _Tp _y, _Tp _z);
        -:  247:    Point3_(const Point3_& pt);
        -:  248:    Point3_(Point3_&& pt) CV_NOEXCEPT;
        -:  249:    explicit Point3_(const Point_<_Tp>& pt);
        -:  250:    Point3_(const Vec<_Tp, 3>& v);
        -:  251:
        -:  252:    Point3_& operator = (const Point3_& pt);
        -:  253:    Point3_& operator = (Point3_&& pt) CV_NOEXCEPT;
        -:  254:    //! conversion to another data type
        -:  255:    template<typename _Tp2> operator Point3_<_Tp2>() const;
        -:  256:    //! conversion to cv::Vec<>
        -:  257:    operator Vec<_Tp, 3>() const;
        -:  258:
        -:  259:    //! dot product
        -:  260:    _Tp dot(const Point3_& pt) const;
        -:  261:    //! dot product computed in double-precision arithmetics
        -:  262:    double ddot(const Point3_& pt) const;
        -:  263:    //! cross product of the 2 3D points
        -:  264:    Point3_ cross(const Point3_& pt) const;
        -:  265:    _Tp x; //!< x coordinate of the 3D point
        -:  266:    _Tp y; //!< y coordinate of the 3D point
        -:  267:    _Tp z; //!< z coordinate of the 3D point
        -:  268:};
        -:  269:
        -:  270:typedef Point3_<int> Point3i;
        -:  271:typedef Point3_<float> Point3f;
        -:  272:typedef Point3_<double> Point3d;
        -:  273:
        -:  274:template<typename _Tp> class DataType< Point3_<_Tp> >
        -:  275:{
        -:  276:public:
        -:  277:    typedef Point3_<_Tp>                               value_type;
        -:  278:    typedef Point3_<typename DataType<_Tp>::work_type> work_type;
        -:  279:    typedef _Tp                                        channel_type;
        -:  280:
        -:  281:    enum { generic_type = 0,
        -:  282:           channels     = 3,
        -:  283:           fmt          = traits::SafeFmt<channel_type>::fmt + ((channels - 1) << 8)
        -:  284:#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED
        -:  285:           ,depth        = DataType<channel_type>::depth
        -:  286:           ,type         = CV_MAKETYPE(depth, channels)
        -:  287:#endif
        -:  288:         };
        -:  289:
        -:  290:    typedef Vec<channel_type, channels> vec_type;
        -:  291:};
        -:  292:
        -:  293:namespace traits {
        -:  294:template<typename _Tp>
        -:  295:struct Depth< Point3_<_Tp> > { enum { value = Depth<_Tp>::value }; };
        -:  296:template<typename _Tp>
        -:  297:struct Type< Point3_<_Tp> > { enum { value = CV_MAKETYPE(Depth<_Tp>::value, 3) }; };
        -:  298:} // namespace
        -:  299:
        -:  300://////////////////////////////// Size_ ////////////////////////////////
        -:  301:
        -:  302:/** @brief Template class for specifying the size of an image or rectangle.
        -:  303:
        -:  304:The class includes two members called width and height. The structure can be converted to and from
        -:  305:the old OpenCV structures CvSize and CvSize2D32f . The same set of arithmetic and comparison
        -:  306:operations as for Point_ is available.
        -:  307:
        -:  308:OpenCV defines the following Size_\<\> aliases:
        -:  309:@code
        -:  310:    typedef Size_<int> Size2i;
        -:  311:    typedef Size2i Size;
        -:  312:    typedef Size_<float> Size2f;
        -:  313:@endcode
        -:  314:*/
        -:  315:template<typename _Tp> class Size_
        -:  316:{
        -:  317:public:
        -:  318:    typedef _Tp value_type;
        -:  319:
        -:  320:    //! default constructor
        -:  321:    Size_();
        -:  322:    Size_(_Tp _width, _Tp _height);
        -:  323:    Size_(const Size_& sz);
        -:  324:    Size_(Size_&& sz) CV_NOEXCEPT;
        -:  325:    Size_(const Point_<_Tp>& pt);
        -:  326:
        -:  327:    Size_& operator = (const Size_& sz);
        -:  328:    Size_& operator = (Size_&& sz) CV_NOEXCEPT;
        -:  329:    //! the area (width*height)
        -:  330:    _Tp area() const;
        -:  331:    //! aspect ratio (width/height)
        -:  332:    double aspectRatio() const;
        -:  333:    //! true if empty
        -:  334:    bool empty() const;
        -:  335:
        -:  336:    //! conversion of another data type.
        -:  337:    template<typename _Tp2> operator Size_<_Tp2>() const;
        -:  338:
        -:  339:    _Tp width; //!< the width
        -:  340:    _Tp height; //!< the height
        -:  341:};
        -:  342:
        -:  343:typedef Size_<int> Size2i;
        -:  344:typedef Size_<int64> Size2l;
        -:  345:typedef Size_<float> Size2f;
        -:  346:typedef Size_<double> Size2d;
        -:  347:typedef Size2i Size;
        -:  348:
        -:  349:template<typename _Tp> class DataType< Size_<_Tp> >
        -:  350:{
        -:  351:public:
        -:  352:    typedef Size_<_Tp>                               value_type;
        -:  353:    typedef Size_<typename DataType<_Tp>::work_type> work_type;
        -:  354:    typedef _Tp                                      channel_type;
        -:  355:
        -:  356:    enum { generic_type = 0,
        -:  357:           channels     = 2,
        -:  358:           fmt          = DataType<channel_type>::fmt + ((channels - 1) << 8)
        -:  359:#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED
        -:  360:           ,depth        = DataType<channel_type>::depth
        -:  361:           ,type         = CV_MAKETYPE(depth, channels)
        -:  362:#endif
        -:  363:         };
        -:  364:
        -:  365:    typedef Vec<channel_type, channels> vec_type;
        -:  366:};
        -:  367:
        -:  368:namespace traits {
        -:  369:template<typename _Tp>
        -:  370:struct Depth< Size_<_Tp> > { enum { value = Depth<_Tp>::value }; };
        -:  371:template<typename _Tp>
        -:  372:struct Type< Size_<_Tp> > { enum { value = CV_MAKETYPE(Depth<_Tp>::value, 2) }; };
        -:  373:} // namespace
        -:  374:
        -:  375://////////////////////////////// Rect_ ////////////////////////////////
        -:  376:
        -:  377:/** @brief Template class for 2D rectangles
        -:  378:
        -:  379:described by the following parameters:
        -:  380:-   Coordinates of the top-left corner. This is a default interpretation of Rect_::x and Rect_::y
        -:  381:    in OpenCV. Though, in your algorithms you may count x and y from the bottom-left corner.
        -:  382:-   Rectangle width and height.
        -:  383:
        -:  384:OpenCV typically assumes that the top and left boundary of the rectangle are inclusive, while the
        -:  385:right and bottom boundaries are not. For example, the method Rect_::contains returns true if
        -:  386:
        -:  387:\f[x  \leq pt.x < x+width,
        -:  388:      y  \leq pt.y < y+height\f]
        -:  389:
        -:  390:Virtually every loop over an image ROI in OpenCV (where ROI is specified by Rect_\<int\> ) is
        -:  391:implemented as:
        -:  392:@code
        -:  393:    for(int y = roi.y; y < roi.y + roi.height; y++)
        -:  394:        for(int x = roi.x; x < roi.x + roi.width; x++)
        -:  395:        {
        -:  396:            // ...
        -:  397:        }
        -:  398:@endcode
        -:  399:In addition to the class members, the following operations on rectangles are implemented:
        -:  400:-   \f$\texttt{rect} = \texttt{rect} \pm \texttt{point}\f$ (shifting a rectangle by a certain offset)
        -:  401:-   \f$\texttt{rect} = \texttt{rect} \pm \texttt{size}\f$ (expanding or shrinking a rectangle by a
        -:  402:    certain amount)
        -:  403:-   rect += point, rect -= point, rect += size, rect -= size (augmenting operations)
        -:  404:-   rect = rect1 & rect2 (rectangle intersection)
        -:  405:-   rect = rect1 | rect2 (minimum area rectangle containing rect1 and rect2 )
        -:  406:-   rect &= rect1, rect |= rect1 (and the corresponding augmenting operations)
        -:  407:-   rect == rect1, rect != rect1 (rectangle comparison)
        -:  408:
        -:  409:This is an example how the partial ordering on rectangles can be established (rect1 \f$\subseteq\f$
        -:  410:rect2):
        -:  411:@code
        -:  412:    template<typename _Tp> inline bool
        -:  413:    operator <= (const Rect_<_Tp>& r1, const Rect_<_Tp>& r2)
        -:  414:    {
        -:  415:        return (r1 & r2) == r1;
        -:  416:    }
        -:  417:@endcode
        -:  418:For your convenience, the Rect_\<\> alias is available: cv::Rect
        -:  419:*/
        -:  420:template<typename _Tp> class Rect_
        -:  421:{
        -:  422:public:
        -:  423:    typedef _Tp value_type;
        -:  424:
        -:  425:    //! default constructor
        -:  426:    Rect_();
        -:  427:    Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height);
        -:  428:    Rect_(const Rect_& r);
        -:  429:    Rect_(Rect_&& r) CV_NOEXCEPT;
        -:  430:    Rect_(const Point_<_Tp>& org, const Size_<_Tp>& sz);
        -:  431:    Rect_(const Point_<_Tp>& pt1, const Point_<_Tp>& pt2);
        -:  432:
        -:  433:    Rect_& operator = ( const Rect_& r );
        -:  434:    Rect_& operator = ( Rect_&& r ) CV_NOEXCEPT;
        -:  435:    //! the top-left corner
        -:  436:    Point_<_Tp> tl() const;
        -:  437:    //! the bottom-right corner
        -:  438:    Point_<_Tp> br() const;
        -:  439:
        -:  440:    //! size (width, height) of the rectangle
        -:  441:    Size_<_Tp> size() const;
        -:  442:    //! area (width*height) of the rectangle
        -:  443:    _Tp area() const;
        -:  444:    //! true if empty
        -:  445:    bool empty() const;
        -:  446:
        -:  447:    //! conversion to another data type
        -:  448:    template<typename _Tp2> operator Rect_<_Tp2>() const;
        -:  449:
        -:  450:    //! checks whether the rectangle contains the point
        -:  451:    bool contains(const Point_<_Tp>& pt) const;
        -:  452:
        -:  453:    _Tp x; //!< x coordinate of the top-left corner
        -:  454:    _Tp y; //!< y coordinate of the top-left corner
        -:  455:    _Tp width; //!< width of the rectangle
        -:  456:    _Tp height; //!< height of the rectangle
        -:  457:};
        -:  458:
        -:  459:typedef Rect_<int> Rect2i;
        -:  460:typedef Rect_<float> Rect2f;
        -:  461:typedef Rect_<double> Rect2d;
        -:  462:typedef Rect2i Rect;
        -:  463:
        -:  464:template<typename _Tp> class DataType< Rect_<_Tp> >
        -:  465:{
        -:  466:public:
        -:  467:    typedef Rect_<_Tp>                               value_type;
        -:  468:    typedef Rect_<typename DataType<_Tp>::work_type> work_type;
        -:  469:    typedef _Tp                                      channel_type;
        -:  470:
        -:  471:    enum { generic_type = 0,
        -:  472:           channels     = 4,
        -:  473:           fmt          = traits::SafeFmt<channel_type>::fmt + ((channels - 1) << 8)
        -:  474:#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED
        -:  475:           ,depth        = DataType<channel_type>::depth
        -:  476:           ,type         = CV_MAKETYPE(depth, channels)
        -:  477:#endif
        -:  478:         };
        -:  479:
        -:  480:    typedef Vec<channel_type, channels> vec_type;
        -:  481:};
        -:  482:
        -:  483:namespace traits {
        -:  484:template<typename _Tp>
        -:  485:struct Depth< Rect_<_Tp> > { enum { value = Depth<_Tp>::value }; };
        -:  486:template<typename _Tp>
        -:  487:struct Type< Rect_<_Tp> > { enum { value = CV_MAKETYPE(Depth<_Tp>::value, 4) }; };
        -:  488:} // namespace
        -:  489:
        -:  490:///////////////////////////// RotatedRect /////////////////////////////
        -:  491:
        -:  492:/** @brief The class represents rotated (i.e. not up-right) rectangles on a plane.
        -:  493:
        -:  494:Each rectangle is specified by the center point (mass center), length of each side (represented by
        -:  495:#Size2f structure) and the rotation angle in degrees.
        -:  496:
        -:  497:The sample below demonstrates how to use RotatedRect:
        -:  498:@snippet snippets/core_various.cpp RotatedRect_demo
        -:  499:![image](pics/rotatedrect.png)
        -:  500:
        -:  501:@sa CamShift, fitEllipse, minAreaRect, CvBox2D
        -:  502:*/
        -:  503:class CV_EXPORTS RotatedRect
        -:  504:{
        -:  505:public:
        -:  506:    //! default constructor
        -:  507:    RotatedRect();
        -:  508:    /** full constructor
        -:  509:    @param center The rectangle mass center.
        -:  510:    @param size Width and height of the rectangle.
        -:  511:    @param angle The rotation angle in a clockwise direction. When the angle is 0, 90, 180, 270 etc.,
        -:  512:    the rectangle becomes an up-right rectangle.
        -:  513:    */
        -:  514:    RotatedRect(const Point2f& center, const Size2f& size, float angle);
        -:  515:    /**
        -:  516:    Any 3 end points of the RotatedRect. They must be given in order (either clockwise or
        -:  517:    anticlockwise).
        -:  518:     */
        -:  519:    RotatedRect(const Point2f& point1, const Point2f& point2, const Point2f& point3);
        -:  520:
        -:  521:    /** returns 4 vertices of the rectangle
        -:  522:    @param pts The points array for storing rectangle vertices. The order is bottomLeft, topLeft, topRight, bottomRight.
        -:  523:    */
        -:  524:    void points(Point2f pts[]) const;
        -:  525:    //! returns the minimal up-right integer rectangle containing the rotated rectangle
        -:  526:    Rect boundingRect() const;
        -:  527:    //! returns the minimal (exact) floating point rectangle containing the rotated rectangle, not intended for use with images
        -:  528:    Rect_<float> boundingRect2f() const;
        -:  529:    //! returns the rectangle mass center
        -:  530:    Point2f center;
        -:  531:    //! returns width and height of the rectangle
        -:  532:    Size2f size;
        -:  533:    //! returns the rotation angle. When the angle is 0, 90, 180, 270 etc., the rectangle becomes an up-right rectangle.
        -:  534:    float angle;
        -:  535:};
        -:  536:
        -:  537:template<> class DataType< RotatedRect >
        -:  538:{
        -:  539:public:
        -:  540:    typedef RotatedRect  value_type;
        -:  541:    typedef value_type   work_type;
        -:  542:    typedef float        channel_type;
        -:  543:
        -:  544:    enum { generic_type = 0,
        -:  545:           channels     = (int)sizeof(value_type)/sizeof(channel_type), // 5
        -:  546:           fmt          = traits::SafeFmt<channel_type>::fmt + ((channels - 1) << 8)
        -:  547:#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED
        -:  548:           ,depth        = DataType<channel_type>::depth
        -:  549:           ,type         = CV_MAKETYPE(depth, channels)
        -:  550:#endif
        -:  551:         };
        -:  552:
        -:  553:    typedef Vec<channel_type, channels> vec_type;
        -:  554:};
        -:  555:
        -:  556:namespace traits {
        -:  557:template<>
        -:  558:struct Depth< RotatedRect > { enum { value = Depth<float>::value }; };
        -:  559:template<>
        -:  560:struct Type< RotatedRect > { enum { value = CV_MAKETYPE(Depth<float>::value, (int)sizeof(RotatedRect)/sizeof(float)) }; };
        -:  561:} // namespace
        -:  562:
        -:  563:
        -:  564://////////////////////////////// Range /////////////////////////////////
        -:  565:
        -:  566:/** @brief Template class specifying a continuous subsequence (slice) of a sequence.
        -:  567:
        -:  568:The class is used to specify a row or a column span in a matrix ( Mat ) and for many other purposes.
        -:  569:Range(a,b) is basically the same as a:b in Matlab or a..b in Python. As in Python, start is an
        -:  570:inclusive left boundary of the range and end is an exclusive right boundary of the range. Such a
        -:  571:half-opened interval is usually denoted as \f$[start,end)\f$ .
        -:  572:
        -:  573:The static method Range::all() returns a special variable that means "the whole sequence" or "the
        -:  574:whole range", just like " : " in Matlab or " ... " in Python. All the methods and functions in
        -:  575:OpenCV that take Range support this special Range::all() value. But, of course, in case of your own
        -:  576:custom processing, you will probably have to check and handle it explicitly:
        -:  577:@code
        -:  578:    void my_function(..., const Range& r, ....)
        -:  579:    {
        -:  580:        if(r == Range::all()) {
        -:  581:            // process all the data
        -:  582:        }
        -:  583:        else {
        -:  584:            // process [r.start, r.end)
        -:  585:        }
        -:  586:    }
        -:  587:@endcode
        -:  588:*/
        -:  589:class CV_EXPORTS Range
        -:  590:{
        -:  591:public:
        -:  592:    Range();
        -:  593:    Range(int _start, int _end);
        -:  594:    int size() const;
        -:  595:    bool empty() const;
        -:  596:    static Range all();
        -:  597:
        -:  598:    int start, end;
        -:  599:};
        -:  600:
        -:  601:template<> class DataType<Range>
        -:  602:{
        -:  603:public:
        -:  604:    typedef Range      value_type;
        -:  605:    typedef value_type work_type;
        -:  606:    typedef int        channel_type;
        -:  607:
        -:  608:    enum { generic_type = 0,
        -:  609:           channels     = 2,
        -:  610:           fmt          = traits::SafeFmt<channel_type>::fmt + ((channels - 1) << 8)
        -:  611:#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED
        -:  612:           ,depth        = DataType<channel_type>::depth
        -:  613:           ,type         = CV_MAKETYPE(depth, channels)
        -:  614:#endif
        -:  615:         };
        -:  616:
        -:  617:    typedef Vec<channel_type, channels> vec_type;
        -:  618:};
        -:  619:
        -:  620:namespace traits {
        -:  621:template<>
        -:  622:struct Depth< Range > { enum { value = Depth<int>::value }; };
        -:  623:template<>
        -:  624:struct Type< Range > { enum { value = CV_MAKETYPE(Depth<int>::value, 2) }; };
        -:  625:} // namespace
        -:  626:
        -:  627:
        -:  628://////////////////////////////// Scalar_ ///////////////////////////////
        -:  629:
        -:  630:/** @brief Template class for a 4-element vector derived from Vec.
        -:  631:
        -:  632:Being derived from Vec\<_Tp, 4\> , Scalar\_ and Scalar can be used just as typical 4-element
        -:  633:vectors. In addition, they can be converted to/from CvScalar . The type Scalar is widely used in
        -:  634:OpenCV to pass pixel values.
        -:  635:*/
        -:  636:template<typename _Tp> class Scalar_ : public Vec<_Tp, 4>
        -:  637:{
        -:  638:public:
        -:  639:    //! default constructor
        -:  640:    Scalar_();
        -:  641:    Scalar_(_Tp v0, _Tp v1, _Tp v2=0, _Tp v3=0);
        -:  642:    Scalar_(_Tp v0);
        -:  643:
        -:  644:    Scalar_(const Scalar_& s);
        -:  645:    Scalar_(Scalar_&& s) CV_NOEXCEPT;
        -:  646:
        -:  647:    Scalar_& operator=(const Scalar_& s);
        -:  648:    Scalar_& operator=(Scalar_&& s) CV_NOEXCEPT;
        -:  649:
        -:  650:    template<typename _Tp2, int cn>
        -:  651:    Scalar_(const Vec<_Tp2, cn>& v);
        -:  652:
        -:  653:    //! returns a scalar with all elements set to v0
        -:  654:    static Scalar_<_Tp> all(_Tp v0);
        -:  655:
        -:  656:    //! conversion to another data type
        -:  657:    template<typename T2> operator Scalar_<T2>() const;
        -:  658:
        -:  659:    //! per-element product
        -:  660:    Scalar_<_Tp> mul(const Scalar_<_Tp>& a, double scale=1 ) const;
        -:  661:
        -:  662:    //! returns (v0, -v1, -v2, -v3)
        -:  663:    Scalar_<_Tp> conj() const;
        -:  664:
        -:  665:    //! returns true iff v1 == v2 == v3 == 0
        -:  666:    bool isReal() const;
        -:  667:};
        -:  668:
        -:  669:typedef Scalar_<double> Scalar;
        -:  670:
        -:  671:template<typename _Tp> class DataType< Scalar_<_Tp> >
        -:  672:{
        -:  673:public:
        -:  674:    typedef Scalar_<_Tp>                               value_type;
        -:  675:    typedef Scalar_<typename DataType<_Tp>::work_type> work_type;
        -:  676:    typedef _Tp                                        channel_type;
        -:  677:
        -:  678:    enum { generic_type = 0,
        -:  679:           channels     = 4,
        -:  680:           fmt          = traits::SafeFmt<channel_type>::fmt + ((channels - 1) << 8)
        -:  681:#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED
        -:  682:           ,depth        = DataType<channel_type>::depth
        -:  683:           ,type         = CV_MAKETYPE(depth, channels)
        -:  684:#endif
        -:  685:         };
        -:  686:
        -:  687:    typedef Vec<channel_type, channels> vec_type;
        -:  688:};
        -:  689:
        -:  690:namespace traits {
        -:  691:template<typename _Tp>
        -:  692:struct Depth< Scalar_<_Tp> > { enum { value = Depth<_Tp>::value }; };
        -:  693:template<typename _Tp>
        -:  694:struct Type< Scalar_<_Tp> > { enum { value = CV_MAKETYPE(Depth<_Tp>::value, 4) }; };
        -:  695:} // namespace
        -:  696:
        -:  697:
        -:  698://///////////////////////////// KeyPoint ////////////////////////////////
        -:  699:
        -:  700:/** @brief Data structure for salient point detectors.
        -:  701:
        -:  702:The class instance stores a keypoint, i.e. a point feature found by one of many available keypoint
        -:  703:detectors, such as Harris corner detector, #FAST, %StarDetector, %SURF, %SIFT etc.
        -:  704:
        -:  705:The keypoint is characterized by the 2D position, scale (proportional to the diameter of the
        -:  706:neighborhood that needs to be taken into account), orientation and some other parameters. The
        -:  707:keypoint neighborhood is then analyzed by another algorithm that builds a descriptor (usually
        -:  708:represented as a feature vector). The keypoints representing the same object in different images
        -:  709:can then be matched using %KDTree or another method.
        -:  710:*/
        -:  711:class CV_EXPORTS_W_SIMPLE KeyPoint
        -:  712:{
        -:  713:public:
        -:  714:    //! the default constructor
        -:  715:    CV_WRAP KeyPoint();
        -:  716:    /**
        -:  717:    @param _pt x & y coordinates of the keypoint
        -:  718:    @param _size keypoint diameter
        -:  719:    @param _angle keypoint orientation
        -:  720:    @param _response keypoint detector response on the keypoint (that is, strength of the keypoint)
        -:  721:    @param _octave pyramid octave in which the keypoint has been detected
        -:  722:    @param _class_id object id
        -:  723:     */
        -:  724:    KeyPoint(Point2f _pt, float _size, float _angle=-1, float _response=0, int _octave=0, int _class_id=-1);
        -:  725:    /**
        -:  726:    @param x x-coordinate of the keypoint
        -:  727:    @param y y-coordinate of the keypoint
        -:  728:    @param _size keypoint diameter
        -:  729:    @param _angle keypoint orientation
        -:  730:    @param _response keypoint detector response on the keypoint (that is, strength of the keypoint)
        -:  731:    @param _octave pyramid octave in which the keypoint has been detected
        -:  732:    @param _class_id object id
        -:  733:     */
        -:  734:    CV_WRAP KeyPoint(float x, float y, float _size, float _angle=-1, float _response=0, int _octave=0, int _class_id=-1);
        -:  735:
        -:  736:    size_t hash() const;
        -:  737:
        -:  738:    /**
        -:  739:    This method converts vector of keypoints to vector of points or the reverse, where each keypoint is
        -:  740:    assigned the same size and the same orientation.
        -:  741:
        -:  742:    @param keypoints Keypoints obtained from any feature detection algorithm like SIFT/SURF/ORB
        -:  743:    @param points2f Array of (x,y) coordinates of each keypoint
        -:  744:    @param keypointIndexes Array of indexes of keypoints to be converted to points. (Acts like a mask to
        -:  745:    convert only specified keypoints)
        -:  746:    */
        -:  747:    CV_WRAP static void convert(const std::vector<KeyPoint>& keypoints,
        -:  748:                                CV_OUT std::vector<Point2f>& points2f,
        -:  749:                                const std::vector<int>& keypointIndexes=std::vector<int>());
        -:  750:    /** @overload
        -:  751:    @param points2f Array of (x,y) coordinates of each keypoint
        -:  752:    @param keypoints Keypoints obtained from any feature detection algorithm like SIFT/SURF/ORB
        -:  753:    @param size keypoint diameter
        -:  754:    @param response keypoint detector response on the keypoint (that is, strength of the keypoint)
        -:  755:    @param octave pyramid octave in which the keypoint has been detected
        -:  756:    @param class_id object id
        -:  757:    */
        -:  758:    CV_WRAP static void convert(const std::vector<Point2f>& points2f,
        -:  759:                                CV_OUT std::vector<KeyPoint>& keypoints,
        -:  760:                                float size=1, float response=1, int octave=0, int class_id=-1);
        -:  761:
        -:  762:    /**
        -:  763:    This method computes overlap for pair of keypoints. Overlap is the ratio between area of keypoint
        -:  764:    regions' intersection and area of keypoint regions' union (considering keypoint region as circle).
        -:  765:    If they don't overlap, we get zero. If they coincide at same location with same size, we get 1.
        -:  766:    @param kp1 First keypoint
        -:  767:    @param kp2 Second keypoint
        -:  768:    */
        -:  769:    CV_WRAP static float overlap(const KeyPoint& kp1, const KeyPoint& kp2);
        -:  770:
        -:  771:    CV_PROP_RW Point2f pt; //!< coordinates of the keypoints
        -:  772:    CV_PROP_RW float size; //!< diameter of the meaningful keypoint neighborhood
        -:  773:    CV_PROP_RW float angle; //!< computed orientation of the keypoint (-1 if not applicable);
        -:  774:                            //!< it's in [0,360) degrees and measured relative to
        -:  775:                            //!< image coordinate system, ie in clockwise.
        -:  776:    CV_PROP_RW float response; //!< the response by which the most strong keypoints have been selected. Can be used for the further sorting or subsampling
        -:  777:    CV_PROP_RW int octave; //!< octave (pyramid layer) from which the keypoint has been extracted
        -:  778:    CV_PROP_RW int class_id; //!< object class (if the keypoints need to be clustered by an object they belong to)
        -:  779:};
        -:  780:
        -:  781:#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED
        -:  782:template<> class DataType<KeyPoint>
        -:  783:{
        -:  784:public:
        -:  785:    typedef KeyPoint      value_type;
        -:  786:    typedef float         work_type;
        -:  787:    typedef float         channel_type;
        -:  788:
        -:  789:    enum { generic_type = 0,
        -:  790:           depth        = DataType<channel_type>::depth,
        -:  791:           channels     = (int)(sizeof(value_type)/sizeof(channel_type)), // 7
        -:  792:           fmt          = DataType<channel_type>::fmt + ((channels - 1) << 8),
        -:  793:           type         = CV_MAKETYPE(depth, channels)
        -:  794:         };
        -:  795:
        -:  796:    typedef Vec<channel_type, channels> vec_type;
        -:  797:};
        -:  798:#endif
        -:  799:
        -:  800:
        -:  801://////////////////////////////// DMatch /////////////////////////////////
        -:  802:
        -:  803:/** @brief Class for matching keypoint descriptors
        -:  804:
        -:  805:query descriptor index, train descriptor index, train image index, and distance between
        -:  806:descriptors.
        -:  807:*/
        -:  808:class CV_EXPORTS_W_SIMPLE DMatch
        -:  809:{
        -:  810:public:
        -:  811:    CV_WRAP DMatch();
        -:  812:    CV_WRAP DMatch(int _queryIdx, int _trainIdx, float _distance);
        -:  813:    CV_WRAP DMatch(int _queryIdx, int _trainIdx, int _imgIdx, float _distance);
        -:  814:
        -:  815:    CV_PROP_RW int queryIdx; //!< query descriptor index
        -:  816:    CV_PROP_RW int trainIdx; //!< train descriptor index
        -:  817:    CV_PROP_RW int imgIdx;   //!< train image index
        -:  818:
        -:  819:    CV_PROP_RW float distance;
        -:  820:
        -:  821:    // less is better
        -:  822:    bool operator<(const DMatch &m) const;
        -:  823:};
        -:  824:
        -:  825:#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED
        -:  826:template<> class DataType<DMatch>
        -:  827:{
        -:  828:public:
        -:  829:    typedef DMatch      value_type;
        -:  830:    typedef int         work_type;
        -:  831:    typedef int         channel_type;
        -:  832:
        -:  833:    enum { generic_type = 0,
        -:  834:           depth        = DataType<channel_type>::depth,
        -:  835:           channels     = (int)(sizeof(value_type)/sizeof(channel_type)), // 4
        -:  836:           fmt          = DataType<channel_type>::fmt + ((channels - 1) << 8),
        -:  837:           type         = CV_MAKETYPE(depth, channels)
        -:  838:         };
        -:  839:
        -:  840:    typedef Vec<channel_type, channels> vec_type;
        -:  841:};
        -:  842:#endif
        -:  843:
        -:  844:
        -:  845:///////////////////////////// TermCriteria //////////////////////////////
        -:  846:
        -:  847:/** @brief The class defining termination criteria for iterative algorithms.
        -:  848:
        -:  849:You can initialize it by default constructor and then override any parameters, or the structure may
        -:  850:be fully initialized using the advanced variant of the constructor.
        -:  851:*/
        -:  852:class CV_EXPORTS TermCriteria
        -:  853:{
        -:  854:public:
        -:  855:    /**
        -:  856:      Criteria type, can be one of: COUNT, EPS or COUNT + EPS
        -:  857:    */
        -:  858:    enum Type
        -:  859:    {
        -:  860:        COUNT=1, //!< the maximum number of iterations or elements to compute
        -:  861:        MAX_ITER=COUNT, //!< ditto
        -:  862:        EPS=2 //!< the desired accuracy or change in parameters at which the iterative algorithm stops
        -:  863:    };
        -:  864:
        -:  865:    //! default constructor
        -:  866:    TermCriteria();
        -:  867:    /**
        -:  868:    @param type The type of termination criteria, one of TermCriteria::Type
        -:  869:    @param maxCount The maximum number of iterations or elements to compute.
        -:  870:    @param epsilon The desired accuracy or change in parameters at which the iterative algorithm stops.
        -:  871:    */
        -:  872:    TermCriteria(int type, int maxCount, double epsilon);
        -:  873:
        -:  874:    inline bool isValid() const
        -:  875:    {
        -:  876:        const bool isCount = (type & COUNT) && maxCount > 0;
        -:  877:        const bool isEps = (type & EPS) && !cvIsNaN(epsilon);
        -:  878:        return isCount || isEps;
        -:  879:    }
        -:  880:
        -:  881:    int type; //!< the type of termination criteria: COUNT, EPS or COUNT + EPS
        -:  882:    int maxCount; //!< the maximum number of iterations/elements
        -:  883:    double epsilon; //!< the desired accuracy
        -:  884:};
        -:  885:
        -:  886:
        -:  887://! @} core_basic
        -:  888:
        -:  889:///////////////////////// raster image moments //////////////////////////
        -:  890:
        -:  891://! @addtogroup imgproc_shape
        -:  892://! @{
        -:  893:
        -:  894:/** @brief struct returned by cv::moments
        -:  895:
        -:  896:The spatial moments \f$\texttt{Moments::m}_{ji}\f$ are computed as:
        -:  897:
        -:  898:\f[\texttt{m} _{ji}= \sum _{x,y}  \left ( \texttt{array} (x,y)  \cdot x^j  \cdot y^i \right )\f]
        -:  899:
        -:  900:The central moments \f$\texttt{Moments::mu}_{ji}\f$ are computed as:
        -:  901:
        -:  902:\f[\texttt{mu} _{ji}= \sum _{x,y}  \left ( \texttt{array} (x,y)  \cdot (x -  \bar{x} )^j  \cdot (y -  \bar{y} )^i \right )\f]
        -:  903:
        -:  904:where \f$(\bar{x}, \bar{y})\f$ is the mass center:
        -:  905:
        -:  906:\f[\bar{x} = \frac{\texttt{m}_{10}}{\texttt{m}_{00}} , \; \bar{y} = \frac{\texttt{m}_{01}}{\texttt{m}_{00}}\f]
        -:  907:
        -:  908:The normalized central moments \f$\texttt{Moments::nu}_{ij}\f$ are computed as:
        -:  909:
        -:  910:\f[\texttt{nu} _{ji}= \frac{\texttt{mu}_{ji}}{\texttt{m}_{00}^{(i+j)/2+1}} .\f]
        -:  911:
        -:  912:@note
        -:  913:\f$\texttt{mu}_{00}=\texttt{m}_{00}\f$, \f$\texttt{nu}_{00}=1\f$
        -:  914:\f$\texttt{nu}_{10}=\texttt{mu}_{10}=\texttt{mu}_{01}=\texttt{mu}_{10}=0\f$ , hence the values are not
        -:  915:stored.
        -:  916:
        -:  917:The moments of a contour are defined in the same way but computed using the Green's formula (see
        -:  918:<http://en.wikipedia.org/wiki/Green_theorem>). So, due to a limited raster resolution, the moments
        -:  919:computed for a contour are slightly different from the moments computed for the same rasterized
        -:  920:contour.
        -:  921:
        -:  922:@note
        -:  923:Since the contour moments are computed using Green formula, you may get seemingly odd results for
        -:  924:contours with self-intersections, e.g. a zero area (m00) for butterfly-shaped contours.
        -:  925: */
        -:  926:class CV_EXPORTS_W_MAP Moments
        -:  927:{
        -:  928:public:
        -:  929:    //! the default constructor
        -:  930:    Moments();
        -:  931:    //! the full constructor
        -:  932:    Moments(double m00, double m10, double m01, double m20, double m11,
        -:  933:            double m02, double m30, double m21, double m12, double m03 );
        -:  934:    ////! the conversion from CvMoments
        -:  935:    //Moments( const CvMoments& moments );
        -:  936:    ////! the conversion to CvMoments
        -:  937:    //operator CvMoments() const;
        -:  938:
        -:  939:    //! @name spatial moments
        -:  940:    //! @{
        -:  941:    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;
        -:  942:    //! @}
        -:  943:
        -:  944:    //! @name central moments
        -:  945:    //! @{
        -:  946:    CV_PROP_RW double  mu20, mu11, mu02, mu30, mu21, mu12, mu03;
        -:  947:    //! @}
        -:  948:
        -:  949:    //! @name central normalized moments
        -:  950:    //! @{
        -:  951:    CV_PROP_RW double  nu20, nu11, nu02, nu30, nu21, nu12, nu03;
        -:  952:    //! @}
        -:  953:};
        -:  954:
        -:  955:template<> class DataType<Moments>
        -:  956:{
        -:  957:public:
        -:  958:    typedef Moments     value_type;
        -:  959:    typedef double      work_type;
        -:  960:    typedef double      channel_type;
        -:  961:
        -:  962:    enum { generic_type = 0,
        -:  963:           channels     = (int)(sizeof(value_type)/sizeof(channel_type)), // 24
        -:  964:           fmt          = DataType<channel_type>::fmt + ((channels - 1) << 8)
        -:  965:#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED
        -:  966:           ,depth        = DataType<channel_type>::depth
        -:  967:           ,type         = CV_MAKETYPE(depth, channels)
        -:  968:#endif
        -:  969:         };
        -:  970:
        -:  971:    typedef Vec<channel_type, channels> vec_type;
        -:  972:};
        -:  973:
        -:  974:namespace traits {
        -:  975:template<>
        -:  976:struct Depth< Moments > { enum { value = Depth<double>::value }; };
        -:  977:template<>
        -:  978:struct Type< Moments > { enum { value = CV_MAKETYPE(Depth<double>::value, (int)(sizeof(Moments)/sizeof(double))) }; };
        -:  979:} // namespace
        -:  980:
        -:  981://! @} imgproc_shape
        -:  982:
        -:  983://! @cond IGNORED
        -:  984:
        -:  985://///////////////////////////////////////////////////////////////////////
        -:  986:///////////////////////////// Implementation ////////////////////////////
        -:  987://///////////////////////////////////////////////////////////////////////
        -:  988:
        -:  989://////////////////////////////// Complex ////////////////////////////////
        -:  990:
        -:  991:template<typename _Tp> inline
        -:  992:Complex<_Tp>::Complex()
        -:  993:    : re(0), im(0) {}
        -:  994:
        -:  995:template<typename _Tp> inline
        -:  996:Complex<_Tp>::Complex( _Tp _re, _Tp _im )
        -:  997:    : re(_re), im(_im) {}
        -:  998:
        -:  999:template<typename _Tp> template<typename T2> inline
        -: 1000:Complex<_Tp>::operator Complex<T2>() const
        -: 1001:{
        -: 1002:    return Complex<T2>(saturate_cast<T2>(re), saturate_cast<T2>(im));
        -: 1003:}
        -: 1004:
        -: 1005:template<typename _Tp> inline
        -: 1006:Complex<_Tp> Complex<_Tp>::conj() const
        -: 1007:{
        -: 1008:    return Complex<_Tp>(re, -im);
        -: 1009:}
        -: 1010:
        -: 1011:
        -: 1012:template<typename _Tp> static inline
        -: 1013:bool operator == (const Complex<_Tp>& a, const Complex<_Tp>& b)
        -: 1014:{
        -: 1015:    return a.re == b.re && a.im == b.im;
        -: 1016:}
        -: 1017:
        -: 1018:template<typename _Tp> static inline
        -: 1019:bool operator != (const Complex<_Tp>& a, const Complex<_Tp>& b)
        -: 1020:{
        -: 1021:    return a.re != b.re || a.im != b.im;
        -: 1022:}
        -: 1023:
        -: 1024:template<typename _Tp> static inline
        -: 1025:Complex<_Tp> operator + (const Complex<_Tp>& a, const Complex<_Tp>& b)
        -: 1026:{
        -: 1027:    return Complex<_Tp>( a.re + b.re, a.im + b.im );
        -: 1028:}
        -: 1029:
        -: 1030:template<typename _Tp> static inline
        -: 1031:Complex<_Tp>& operator += (Complex<_Tp>& a, const Complex<_Tp>& b)
        -: 1032:{
        -: 1033:    a.re += b.re; a.im += b.im;
        -: 1034:    return a;
        -: 1035:}
        -: 1036:
        -: 1037:template<typename _Tp> static inline
        -: 1038:Complex<_Tp> operator - (const Complex<_Tp>& a, const Complex<_Tp>& b)
        -: 1039:{
        -: 1040:    return Complex<_Tp>( a.re - b.re, a.im - b.im );
        -: 1041:}
        -: 1042:
        -: 1043:template<typename _Tp> static inline
        -: 1044:Complex<_Tp>& operator -= (Complex<_Tp>& a, const Complex<_Tp>& b)
        -: 1045:{
        -: 1046:    a.re -= b.re; a.im -= b.im;
        -: 1047:    return a;
        -: 1048:}
        -: 1049:
        -: 1050:template<typename _Tp> static inline
        -: 1051:Complex<_Tp> operator - (const Complex<_Tp>& a)
        -: 1052:{
        -: 1053:    return Complex<_Tp>(-a.re, -a.im);
        -: 1054:}
        -: 1055:
        -: 1056:template<typename _Tp> static inline
        -: 1057:Complex<_Tp> operator * (const Complex<_Tp>& a, const Complex<_Tp>& b)
        -: 1058:{
        -: 1059:    return Complex<_Tp>( a.re*b.re - a.im*b.im, a.re*b.im + a.im*b.re );
        -: 1060:}
        -: 1061:
        -: 1062:template<typename _Tp> static inline
        -: 1063:Complex<_Tp> operator * (const Complex<_Tp>& a, _Tp b)
        -: 1064:{
        -: 1065:    return Complex<_Tp>( a.re*b, a.im*b );
        -: 1066:}
        -: 1067:
        -: 1068:template<typename _Tp> static inline
        -: 1069:Complex<_Tp> operator * (_Tp b, const Complex<_Tp>& a)
        -: 1070:{
        -: 1071:    return Complex<_Tp>( a.re*b, a.im*b );
        -: 1072:}
        -: 1073:
        -: 1074:template<typename _Tp> static inline
        -: 1075:Complex<_Tp> operator + (const Complex<_Tp>& a, _Tp b)
        -: 1076:{
        -: 1077:    return Complex<_Tp>( a.re + b, a.im );
        -: 1078:}
        -: 1079:
        -: 1080:template<typename _Tp> static inline
        -: 1081:Complex<_Tp> operator - (const Complex<_Tp>& a, _Tp b)
        -: 1082:{ return Complex<_Tp>( a.re - b, a.im ); }
        -: 1083:
        -: 1084:template<typename _Tp> static inline
        -: 1085:Complex<_Tp> operator + (_Tp b, const Complex<_Tp>& a)
        -: 1086:{
        -: 1087:    return Complex<_Tp>( a.re + b, a.im );
        -: 1088:}
        -: 1089:
        -: 1090:template<typename _Tp> static inline
        -: 1091:Complex<_Tp> operator - (_Tp b, const Complex<_Tp>& a)
        -: 1092:{
        -: 1093:    return Complex<_Tp>( b - a.re, -a.im );
        -: 1094:}
        -: 1095:
        -: 1096:template<typename _Tp> static inline
        -: 1097:Complex<_Tp>& operator += (Complex<_Tp>& a, _Tp b)
        -: 1098:{
        -: 1099:    a.re += b; return a;
        -: 1100:}
        -: 1101:
        -: 1102:template<typename _Tp> static inline
        -: 1103:Complex<_Tp>& operator -= (Complex<_Tp>& a, _Tp b)
        -: 1104:{
        -: 1105:    a.re -= b; return a;
        -: 1106:}
        -: 1107:
        -: 1108:template<typename _Tp> static inline
        -: 1109:Complex<_Tp>& operator *= (Complex<_Tp>& a, _Tp b)
        -: 1110:{
        -: 1111:    a.re *= b; a.im *= b; return a;
        -: 1112:}
        -: 1113:
        -: 1114:template<typename _Tp> static inline
        -: 1115:double abs(const Complex<_Tp>& a)
        -: 1116:{
        -: 1117:    return std::sqrt( (double)a.re*a.re + (double)a.im*a.im);
        -: 1118:}
        -: 1119:
        -: 1120:template<typename _Tp> static inline
        -: 1121:Complex<_Tp> operator / (const Complex<_Tp>& a, const Complex<_Tp>& b)
        -: 1122:{
        -: 1123:    double t = 1./((double)b.re*b.re + (double)b.im*b.im);
        -: 1124:    return Complex<_Tp>( (_Tp)((a.re*b.re + a.im*b.im)*t),
        -: 1125:                        (_Tp)((-a.re*b.im + a.im*b.re)*t) );
        -: 1126:}
        -: 1127:
        -: 1128:template<typename _Tp> static inline
        -: 1129:Complex<_Tp>& operator /= (Complex<_Tp>& a, const Complex<_Tp>& b)
        -: 1130:{
        -: 1131:    a = a / b;
        -: 1132:    return a;
        -: 1133:}
        -: 1134:
        -: 1135:template<typename _Tp> static inline
        -: 1136:Complex<_Tp> operator / (const Complex<_Tp>& a, _Tp b)
        -: 1137:{
        -: 1138:    _Tp t = (_Tp)1/b;
        -: 1139:    return Complex<_Tp>( a.re*t, a.im*t );
        -: 1140:}
        -: 1141:
        -: 1142:template<typename _Tp> static inline
        -: 1143:Complex<_Tp> operator / (_Tp b, const Complex<_Tp>& a)
        -: 1144:{
        -: 1145:    return Complex<_Tp>(b)/a;
        -: 1146:}
        -: 1147:
        -: 1148:template<typename _Tp> static inline
        -: 1149:Complex<_Tp> operator /= (const Complex<_Tp>& a, _Tp b)
        -: 1150:{
        -: 1151:    _Tp t = (_Tp)1/b;
        -: 1152:    a.re *= t; a.im *= t; return a;
        -: 1153:}
        -: 1154:
        -: 1155:
        -: 1156:
        -: 1157://////////////////////////////// 2D Point ///////////////////////////////
        -: 1158:
        -: 1159:template<typename _Tp> inline
        -: 1160:Point_<_Tp>::Point_()
        -: 1161:    : x(0), y(0) {}
        -: 1162:
        -: 1163:template<typename _Tp> inline
        -: 1164:Point_<_Tp>::Point_(_Tp _x, _Tp _y)
        -: 1165:    : x(_x), y(_y) {}
        -: 1166:
        -: 1167:template<typename _Tp> inline
        -: 1168:Point_<_Tp>::Point_(const Point_& pt)
        -: 1169:    : x(pt.x), y(pt.y) {}
        -: 1170:
        -: 1171:template<typename _Tp> inline
        -: 1172:Point_<_Tp>::Point_(Point_&& pt) CV_NOEXCEPT
        -: 1173:    : x(std::move(pt.x)), y(std::move(pt.y)) {}
        -: 1174:
        -: 1175:template<typename _Tp> inline
        -: 1176:Point_<_Tp>::Point_(const Size_<_Tp>& sz)
        -: 1177:    : x(sz.width), y(sz.height) {}
        -: 1178:
        -: 1179:template<typename _Tp> inline
        -: 1180:Point_<_Tp>::Point_(const Vec<_Tp,2>& v)
        -: 1181:    : x(v[0]), y(v[1]) {}
        -: 1182:
        -: 1183:template<typename _Tp> inline
        -: 1184:Point_<_Tp>& Point_<_Tp>::operator = (const Point_& pt)
        -: 1185:{
        -: 1186:    x = pt.x; y = pt.y;
        -: 1187:    return *this;
        -: 1188:}
        -: 1189:
        -: 1190:template<typename _Tp> inline
        -: 1191:Point_<_Tp>& Point_<_Tp>::operator = (Point_&& pt) CV_NOEXCEPT
        -: 1192:{
        -: 1193:    x = std::move(pt.x); y = std::move(pt.y);
        -: 1194:    return *this;
        -: 1195:}
        -: 1196:
        -: 1197:template<typename _Tp> template<typename _Tp2> inline
        -: 1198:Point_<_Tp>::operator Point_<_Tp2>() const
        -: 1199:{
        -: 1200:    return Point_<_Tp2>(saturate_cast<_Tp2>(x), saturate_cast<_Tp2>(y));
        -: 1201:}
        -: 1202:
        -: 1203:template<typename _Tp> inline
        -: 1204:Point_<_Tp>::operator Vec<_Tp, 2>() const
        -: 1205:{
        -: 1206:    return Vec<_Tp, 2>(x, y);
        -: 1207:}
        -: 1208:
        -: 1209:template<typename _Tp> inline
        -: 1210:_Tp Point_<_Tp>::dot(const Point_& pt) const
        -: 1211:{
        -: 1212:    return saturate_cast<_Tp>(x*pt.x + y*pt.y);
        -: 1213:}
        -: 1214:
        -: 1215:template<typename _Tp> inline
        -: 1216:double Point_<_Tp>::ddot(const Point_& pt) const
        -: 1217:{
        -: 1218:    return (double)x*(double)(pt.x) + (double)y*(double)(pt.y);
        -: 1219:}
        -: 1220:
        -: 1221:template<typename _Tp> inline
        -: 1222:double Point_<_Tp>::cross(const Point_& pt) const
        -: 1223:{
        -: 1224:    return (double)x*pt.y - (double)y*pt.x;
        -: 1225:}
        -: 1226:
        -: 1227:template<typename _Tp> inline bool
        -: 1228:Point_<_Tp>::inside( const Rect_<_Tp>& r ) const
        -: 1229:{
        -: 1230:    return r.contains(*this);
        -: 1231:}
        -: 1232:
        -: 1233:
        -: 1234:template<typename _Tp> static inline
        -: 1235:Point_<_Tp>& operator += (Point_<_Tp>& a, const Point_<_Tp>& b)
        -: 1236:{
        -: 1237:    a.x += b.x;
        -: 1238:    a.y += b.y;
        -: 1239:    return a;
        -: 1240:}
        -: 1241:
        -: 1242:template<typename _Tp> static inline
        -: 1243:Point_<_Tp>& operator -= (Point_<_Tp>& a, const Point_<_Tp>& b)
        -: 1244:{
        -: 1245:    a.x -= b.x;
        -: 1246:    a.y -= b.y;
        -: 1247:    return a;
        -: 1248:}
        -: 1249:
        -: 1250:template<typename _Tp> static inline
        -: 1251:Point_<_Tp>& operator *= (Point_<_Tp>& a, int b)
        -: 1252:{
        -: 1253:    a.x = saturate_cast<_Tp>(a.x * b);
        -: 1254:    a.y = saturate_cast<_Tp>(a.y * b);
        -: 1255:    return a;
        -: 1256:}
        -: 1257:
        -: 1258:template<typename _Tp> static inline
        -: 1259:Point_<_Tp>& operator *= (Point_<_Tp>& a, float b)
        -: 1260:{
        -: 1261:    a.x = saturate_cast<_Tp>(a.x * b);
        -: 1262:    a.y = saturate_cast<_Tp>(a.y * b);
        -: 1263:    return a;
        -: 1264:}
        -: 1265:
        -: 1266:template<typename _Tp> static inline
        -: 1267:Point_<_Tp>& operator *= (Point_<_Tp>& a, double b)
        -: 1268:{
        -: 1269:    a.x = saturate_cast<_Tp>(a.x * b);
        -: 1270:    a.y = saturate_cast<_Tp>(a.y * b);
        -: 1271:    return a;
        -: 1272:}
        -: 1273:
        -: 1274:template<typename _Tp> static inline
        -: 1275:Point_<_Tp>& operator /= (Point_<_Tp>& a, int b)
        -: 1276:{
        -: 1277:    a.x = saturate_cast<_Tp>(a.x / b);
        -: 1278:    a.y = saturate_cast<_Tp>(a.y / b);
        -: 1279:    return a;
        -: 1280:}
        -: 1281:
        -: 1282:template<typename _Tp> static inline
        -: 1283:Point_<_Tp>& operator /= (Point_<_Tp>& a, float b)
        -: 1284:{
        -: 1285:    a.x = saturate_cast<_Tp>(a.x / b);
        -: 1286:    a.y = saturate_cast<_Tp>(a.y / b);
        -: 1287:    return a;
        -: 1288:}
        -: 1289:
        -: 1290:template<typename _Tp> static inline
        -: 1291:Point_<_Tp>& operator /= (Point_<_Tp>& a, double b)
        -: 1292:{
        -: 1293:    a.x = saturate_cast<_Tp>(a.x / b);
        -: 1294:    a.y = saturate_cast<_Tp>(a.y / b);
        -: 1295:    return a;
        -: 1296:}
        -: 1297:
        -: 1298:template<typename _Tp> static inline
        -: 1299:double norm(const Point_<_Tp>& pt)
        -: 1300:{
        -: 1301:    return std::sqrt((double)pt.x*pt.x + (double)pt.y*pt.y);
        -: 1302:}
        -: 1303:
        -: 1304:template<typename _Tp> static inline
        -: 1305:bool operator == (const Point_<_Tp>& a, const Point_<_Tp>& b)
        -: 1306:{
        -: 1307:    return a.x == b.x && a.y == b.y;
        -: 1308:}
        -: 1309:
        -: 1310:template<typename _Tp> static inline
        -: 1311:bool operator != (const Point_<_Tp>& a, const Point_<_Tp>& b)
        -: 1312:{
        -: 1313:    return a.x != b.x || a.y != b.y;
        -: 1314:}
        -: 1315:
        -: 1316:template<typename _Tp> static inline
        -: 1317:Point_<_Tp> operator + (const Point_<_Tp>& a, const Point_<_Tp>& b)
        -: 1318:{
        -: 1319:    return Point_<_Tp>( saturate_cast<_Tp>(a.x + b.x), saturate_cast<_Tp>(a.y + b.y) );
        -: 1320:}
        -: 1321:
        -: 1322:template<typename _Tp> static inline
        -: 1323:Point_<_Tp> operator - (const Point_<_Tp>& a, const Point_<_Tp>& b)
        -: 1324:{
        -: 1325:    return Point_<_Tp>( saturate_cast<_Tp>(a.x - b.x), saturate_cast<_Tp>(a.y - b.y) );
        -: 1326:}
        -: 1327:
        -: 1328:template<typename _Tp> static inline
        -: 1329:Point_<_Tp> operator - (const Point_<_Tp>& a)
        -: 1330:{
        -: 1331:    return Point_<_Tp>( saturate_cast<_Tp>(-a.x), saturate_cast<_Tp>(-a.y) );
        -: 1332:}
        -: 1333:
        -: 1334:template<typename _Tp> static inline
        -: 1335:Point_<_Tp> operator * (const Point_<_Tp>& a, int b)
        -: 1336:{
        -: 1337:    return Point_<_Tp>( saturate_cast<_Tp>(a.x*b), saturate_cast<_Tp>(a.y*b) );
        -: 1338:}
        -: 1339:
        -: 1340:template<typename _Tp> static inline
        -: 1341:Point_<_Tp> operator * (int a, const Point_<_Tp>& b)
        -: 1342:{
        -: 1343:    return Point_<_Tp>( saturate_cast<_Tp>(b.x*a), saturate_cast<_Tp>(b.y*a) );
        -: 1344:}
        -: 1345:
        -: 1346:template<typename _Tp> static inline
        -: 1347:Point_<_Tp> operator * (const Point_<_Tp>& a, float b)
        -: 1348:{
        -: 1349:    return Point_<_Tp>( saturate_cast<_Tp>(a.x*b), saturate_cast<_Tp>(a.y*b) );
        -: 1350:}
        -: 1351:
        -: 1352:template<typename _Tp> static inline
        -: 1353:Point_<_Tp> operator * (float a, const Point_<_Tp>& b)
        -: 1354:{
        -: 1355:    return Point_<_Tp>( saturate_cast<_Tp>(b.x*a), saturate_cast<_Tp>(b.y*a) );
        -: 1356:}
        -: 1357:
        -: 1358:template<typename _Tp> static inline
        -: 1359:Point_<_Tp> operator * (const Point_<_Tp>& a, double b)
        -: 1360:{
        -: 1361:    return Point_<_Tp>( saturate_cast<_Tp>(a.x*b), saturate_cast<_Tp>(a.y*b) );
        -: 1362:}
        -: 1363:
        -: 1364:template<typename _Tp> static inline
        -: 1365:Point_<_Tp> operator * (double a, const Point_<_Tp>& b)
        -: 1366:{
        -: 1367:    return Point_<_Tp>( saturate_cast<_Tp>(b.x*a), saturate_cast<_Tp>(b.y*a) );
        -: 1368:}
        -: 1369:
        -: 1370:template<typename _Tp> static inline
        -: 1371:Point_<_Tp> operator * (const Matx<_Tp, 2, 2>& a, const Point_<_Tp>& b)
        -: 1372:{
        -: 1373:    Matx<_Tp, 2, 1> tmp = a * Vec<_Tp,2>(b.x, b.y);
        -: 1374:    return Point_<_Tp>(tmp.val[0], tmp.val[1]);
        -: 1375:}
        -: 1376:
        -: 1377:template<typename _Tp> static inline
        -: 1378:Point3_<_Tp> operator * (const Matx<_Tp, 3, 3>& a, const Point_<_Tp>& b)
        -: 1379:{
        -: 1380:    Matx<_Tp, 3, 1> tmp = a * Vec<_Tp,3>(b.x, b.y, 1);
        -: 1381:    return Point3_<_Tp>(tmp.val[0], tmp.val[1], tmp.val[2]);
        -: 1382:}
        -: 1383:
        -: 1384:template<typename _Tp> static inline
        -: 1385:Point_<_Tp> operator / (const Point_<_Tp>& a, int b)
        -: 1386:{
        -: 1387:    Point_<_Tp> tmp(a);
        -: 1388:    tmp /= b;
        -: 1389:    return tmp;
        -: 1390:}
        -: 1391:
        -: 1392:template<typename _Tp> static inline
        -: 1393:Point_<_Tp> operator / (const Point_<_Tp>& a, float b)
        -: 1394:{
        -: 1395:    Point_<_Tp> tmp(a);
        -: 1396:    tmp /= b;
        -: 1397:    return tmp;
        -: 1398:}
        -: 1399:
        -: 1400:template<typename _Tp> static inline
        -: 1401:Point_<_Tp> operator / (const Point_<_Tp>& a, double b)
        -: 1402:{
        -: 1403:    Point_<_Tp> tmp(a);
        -: 1404:    tmp /= b;
        -: 1405:    return tmp;
        -: 1406:}
        -: 1407:
        -: 1408:
        -: 1409:template<typename _AccTp> static inline _AccTp normL2Sqr(const Point_<int>& pt);
        -: 1410:template<typename _AccTp> static inline _AccTp normL2Sqr(const Point_<int64>& pt);
        -: 1411:template<typename _AccTp> static inline _AccTp normL2Sqr(const Point_<float>& pt);
        -: 1412:template<typename _AccTp> static inline _AccTp normL2Sqr(const Point_<double>& pt);
        -: 1413:
        -: 1414:template<> inline int normL2Sqr<int>(const Point_<int>& pt) { return pt.dot(pt); }
        -: 1415:template<> inline int64 normL2Sqr<int64>(const Point_<int64>& pt) { return pt.dot(pt); }
        -: 1416:template<> inline float normL2Sqr<float>(const Point_<float>& pt) { return pt.dot(pt); }
        -: 1417:template<> inline double normL2Sqr<double>(const Point_<int>& pt) { return pt.dot(pt); }
        -: 1418:
        -: 1419:template<> inline double normL2Sqr<double>(const Point_<float>& pt) { return pt.ddot(pt); }
        -: 1420:template<> inline double normL2Sqr<double>(const Point_<double>& pt) { return pt.ddot(pt); }
        -: 1421:
        -: 1422:
        -: 1423:
        -: 1424://////////////////////////////// 3D Point ///////////////////////////////
        -: 1425:
        -: 1426:template<typename _Tp> inline
        -: 1427:Point3_<_Tp>::Point3_()
        -: 1428:    : x(0), y(0), z(0) {}
        -: 1429:
        -: 1430:template<typename _Tp> inline
        -: 1431:Point3_<_Tp>::Point3_(_Tp _x, _Tp _y, _Tp _z)
        -: 1432:    : x(_x), y(_y), z(_z) {}
        -: 1433:
        -: 1434:template<typename _Tp> inline
        -: 1435:Point3_<_Tp>::Point3_(const Point3_& pt)
        -: 1436:    : x(pt.x), y(pt.y), z(pt.z) {}
        -: 1437:
        -: 1438:template<typename _Tp> inline
        -: 1439:Point3_<_Tp>::Point3_(Point3_&& pt) CV_NOEXCEPT
        -: 1440:    : x(std::move(pt.x)), y(std::move(pt.y)), z(std::move(pt.z)) {}
        -: 1441:
        -: 1442:template<typename _Tp> inline
        -: 1443:Point3_<_Tp>::Point3_(const Point_<_Tp>& pt)
        -: 1444:    : x(pt.x), y(pt.y), z(_Tp()) {}
        -: 1445:
        -: 1446:template<typename _Tp> inline
        -: 1447:Point3_<_Tp>::Point3_(const Vec<_Tp, 3>& v)
        -: 1448:    : x(v[0]), y(v[1]), z(v[2]) {}
        -: 1449:
        -: 1450:template<typename _Tp> template<typename _Tp2> inline
        -: 1451:Point3_<_Tp>::operator Point3_<_Tp2>() const
        -: 1452:{
        -: 1453:    return Point3_<_Tp2>(saturate_cast<_Tp2>(x), saturate_cast<_Tp2>(y), saturate_cast<_Tp2>(z));
        -: 1454:}
        -: 1455:
        -: 1456:template<typename _Tp> inline
        -: 1457:Point3_<_Tp>::operator Vec<_Tp, 3>() const
        -: 1458:{
        -: 1459:    return Vec<_Tp, 3>(x, y, z);
        -: 1460:}
        -: 1461:
        -: 1462:template<typename _Tp> inline
        -: 1463:Point3_<_Tp>& Point3_<_Tp>::operator = (const Point3_& pt)
        -: 1464:{
        -: 1465:    x = pt.x; y = pt.y; z = pt.z;
        -: 1466:    return *this;
        -: 1467:}
        -: 1468:
        -: 1469:template<typename _Tp> inline
        -: 1470:Point3_<_Tp>& Point3_<_Tp>::operator = (Point3_&& pt) CV_NOEXCEPT
        -: 1471:{
        -: 1472:    x = std::move(pt.x); y = std::move(pt.y); z = std::move(pt.z);
        -: 1473:    return *this;
        -: 1474:}
        -: 1475:
        -: 1476:template<typename _Tp> inline
        -: 1477:_Tp Point3_<_Tp>::dot(const Point3_& pt) const
        -: 1478:{
        -: 1479:    return saturate_cast<_Tp>(x*pt.x + y*pt.y + z*pt.z);
        -: 1480:}
        -: 1481:
        -: 1482:template<typename _Tp> inline
        -: 1483:double Point3_<_Tp>::ddot(const Point3_& pt) const
        -: 1484:{
        -: 1485:    return (double)x*pt.x + (double)y*pt.y + (double)z*pt.z;
        -: 1486:}
        -: 1487:
        -: 1488:template<typename _Tp> inline
        -: 1489:Point3_<_Tp> Point3_<_Tp>::cross(const Point3_<_Tp>& pt) const
        -: 1490:{
        -: 1491:    return Point3_<_Tp>(y*pt.z - z*pt.y, z*pt.x - x*pt.z, x*pt.y - y*pt.x);
        -: 1492:}
        -: 1493:
        -: 1494:
        -: 1495:template<typename _Tp> static inline
        -: 1496:Point3_<_Tp>& operator += (Point3_<_Tp>& a, const Point3_<_Tp>& b)
        -: 1497:{
        -: 1498:    a.x += b.x;
        -: 1499:    a.y += b.y;
        -: 1500:    a.z += b.z;
        -: 1501:    return a;
        -: 1502:}
        -: 1503:
        -: 1504:template<typename _Tp> static inline
        -: 1505:Point3_<_Tp>& operator -= (Point3_<_Tp>& a, const Point3_<_Tp>& b)
        -: 1506:{
        -: 1507:    a.x -= b.x;
        -: 1508:    a.y -= b.y;
        -: 1509:    a.z -= b.z;
        -: 1510:    return a;
        -: 1511:}
        -: 1512:
        -: 1513:template<typename _Tp> static inline
        -: 1514:Point3_<_Tp>& operator *= (Point3_<_Tp>& a, int b)
        -: 1515:{
        -: 1516:    a.x = saturate_cast<_Tp>(a.x * b);
        -: 1517:    a.y = saturate_cast<_Tp>(a.y * b);
        -: 1518:    a.z = saturate_cast<_Tp>(a.z * b);
        -: 1519:    return a;
        -: 1520:}
        -: 1521:
        -: 1522:template<typename _Tp> static inline
        -: 1523:Point3_<_Tp>& operator *= (Point3_<_Tp>& a, float b)
        -: 1524:{
        -: 1525:    a.x = saturate_cast<_Tp>(a.x * b);
        -: 1526:    a.y = saturate_cast<_Tp>(a.y * b);
        -: 1527:    a.z = saturate_cast<_Tp>(a.z * b);
        -: 1528:    return a;
        -: 1529:}
        -: 1530:
        -: 1531:template<typename _Tp> static inline
        -: 1532:Point3_<_Tp>& operator *= (Point3_<_Tp>& a, double b)
        -: 1533:{
        -: 1534:    a.x = saturate_cast<_Tp>(a.x * b);
        -: 1535:    a.y = saturate_cast<_Tp>(a.y * b);
        -: 1536:    a.z = saturate_cast<_Tp>(a.z * b);
        -: 1537:    return a;
        -: 1538:}
        -: 1539:
        -: 1540:template<typename _Tp> static inline
        -: 1541:Point3_<_Tp>& operator /= (Point3_<_Tp>& a, int b)
        -: 1542:{
        -: 1543:    a.x = saturate_cast<_Tp>(a.x / b);
        -: 1544:    a.y = saturate_cast<_Tp>(a.y / b);
        -: 1545:    a.z = saturate_cast<_Tp>(a.z / b);
        -: 1546:    return a;
        -: 1547:}
        -: 1548:
        -: 1549:template<typename _Tp> static inline
        -: 1550:Point3_<_Tp>& operator /= (Point3_<_Tp>& a, float b)
        -: 1551:{
        -: 1552:    a.x = saturate_cast<_Tp>(a.x / b);
        -: 1553:    a.y = saturate_cast<_Tp>(a.y / b);
        -: 1554:    a.z = saturate_cast<_Tp>(a.z / b);
        -: 1555:    return a;
        -: 1556:}
        -: 1557:
        -: 1558:template<typename _Tp> static inline
        -: 1559:Point3_<_Tp>& operator /= (Point3_<_Tp>& a, double b)
        -: 1560:{
        -: 1561:    a.x = saturate_cast<_Tp>(a.x / b);
        -: 1562:    a.y = saturate_cast<_Tp>(a.y / b);
        -: 1563:    a.z = saturate_cast<_Tp>(a.z / b);
        -: 1564:    return a;
        -: 1565:}
        -: 1566:
        -: 1567:template<typename _Tp> static inline
        -: 1568:double norm(const Point3_<_Tp>& pt)
        -: 1569:{
        -: 1570:    return std::sqrt((double)pt.x*pt.x + (double)pt.y*pt.y + (double)pt.z*pt.z);
        -: 1571:}
        -: 1572:
        -: 1573:template<typename _Tp> static inline
        -: 1574:bool operator == (const Point3_<_Tp>& a, const Point3_<_Tp>& b)
        -: 1575:{
        -: 1576:    return a.x == b.x && a.y == b.y && a.z == b.z;
        -: 1577:}
        -: 1578:
        -: 1579:template<typename _Tp> static inline
        -: 1580:bool operator != (const Point3_<_Tp>& a, const Point3_<_Tp>& b)
        -: 1581:{
        -: 1582:    return a.x != b.x || a.y != b.y || a.z != b.z;
        -: 1583:}
        -: 1584:
        -: 1585:template<typename _Tp> static inline
        -: 1586:Point3_<_Tp> operator + (const Point3_<_Tp>& a, const Point3_<_Tp>& b)
        -: 1587:{
        -: 1588:    return Point3_<_Tp>( saturate_cast<_Tp>(a.x + b.x), saturate_cast<_Tp>(a.y + b.y), saturate_cast<_Tp>(a.z + b.z));
        -: 1589:}
        -: 1590:
        -: 1591:template<typename _Tp> static inline
        -: 1592:Point3_<_Tp> operator - (const Point3_<_Tp>& a, const Point3_<_Tp>& b)
        -: 1593:{
        -: 1594:    return Point3_<_Tp>( saturate_cast<_Tp>(a.x - b.x), saturate_cast<_Tp>(a.y - b.y), saturate_cast<_Tp>(a.z - b.z));
        -: 1595:}
        -: 1596:
        -: 1597:template<typename _Tp> static inline
        -: 1598:Point3_<_Tp> operator - (const Point3_<_Tp>& a)
        -: 1599:{
        -: 1600:    return Point3_<_Tp>( saturate_cast<_Tp>(-a.x), saturate_cast<_Tp>(-a.y), saturate_cast<_Tp>(-a.z) );
        -: 1601:}
        -: 1602:
        -: 1603:template<typename _Tp> static inline
        -: 1604:Point3_<_Tp> operator * (const Point3_<_Tp>& a, int b)
        -: 1605:{
        -: 1606:    return Point3_<_Tp>( saturate_cast<_Tp>(a.x*b), saturate_cast<_Tp>(a.y*b), saturate_cast<_Tp>(a.z*b) );
        -: 1607:}
        -: 1608:
        -: 1609:template<typename _Tp> static inline
        -: 1610:Point3_<_Tp> operator * (int a, const Point3_<_Tp>& b)
        -: 1611:{
        -: 1612:    return Point3_<_Tp>( saturate_cast<_Tp>(b.x * a), saturate_cast<_Tp>(b.y * a), saturate_cast<_Tp>(b.z * a) );
        -: 1613:}
        -: 1614:
        -: 1615:template<typename _Tp> static inline
        -: 1616:Point3_<_Tp> operator * (const Point3_<_Tp>& a, float b)
        -: 1617:{
        -: 1618:    return Point3_<_Tp>( saturate_cast<_Tp>(a.x * b), saturate_cast<_Tp>(a.y * b), saturate_cast<_Tp>(a.z * b) );
        -: 1619:}
        -: 1620:
        -: 1621:template<typename _Tp> static inline
        -: 1622:Point3_<_Tp> operator * (float a, const Point3_<_Tp>& b)
        -: 1623:{
        -: 1624:    return Point3_<_Tp>( saturate_cast<_Tp>(b.x * a), saturate_cast<_Tp>(b.y * a), saturate_cast<_Tp>(b.z * a) );
        -: 1625:}
        -: 1626:
        -: 1627:template<typename _Tp> static inline
        -: 1628:Point3_<_Tp> operator * (const Point3_<_Tp>& a, double b)
        -: 1629:{
        -: 1630:    return Point3_<_Tp>( saturate_cast<_Tp>(a.x * b), saturate_cast<_Tp>(a.y * b), saturate_cast<_Tp>(a.z * b) );
        -: 1631:}
        -: 1632:
        -: 1633:template<typename _Tp> static inline
        -: 1634:Point3_<_Tp> operator * (double a, const Point3_<_Tp>& b)
        -: 1635:{
        -: 1636:    return Point3_<_Tp>( saturate_cast<_Tp>(b.x * a), saturate_cast<_Tp>(b.y * a), saturate_cast<_Tp>(b.z * a) );
        -: 1637:}
        -: 1638:
        -: 1639:template<typename _Tp> static inline
        -: 1640:Point3_<_Tp> operator * (const Matx<_Tp, 3, 3>& a, const Point3_<_Tp>& b)
        -: 1641:{
        -: 1642:    Matx<_Tp, 3, 1> tmp = a * Vec<_Tp,3>(b.x, b.y, b.z);
        -: 1643:    return Point3_<_Tp>(tmp.val[0], tmp.val[1], tmp.val[2]);
        -: 1644:}
        -: 1645:
        -: 1646:template<typename _Tp> static inline
        -: 1647:Matx<_Tp, 4, 1> operator * (const Matx<_Tp, 4, 4>& a, const Point3_<_Tp>& b)
        -: 1648:{
        -: 1649:    return a * Matx<_Tp, 4, 1>(b.x, b.y, b.z, 1);
        -: 1650:}
        -: 1651:
        -: 1652:template<typename _Tp> static inline
        -: 1653:Point3_<_Tp> operator / (const Point3_<_Tp>& a, int b)
        -: 1654:{
        -: 1655:    Point3_<_Tp> tmp(a);
        -: 1656:    tmp /= b;
        -: 1657:    return tmp;
        -: 1658:}
        -: 1659:
        -: 1660:template<typename _Tp> static inline
        -: 1661:Point3_<_Tp> operator / (const Point3_<_Tp>& a, float b)
        -: 1662:{
        -: 1663:    Point3_<_Tp> tmp(a);
        -: 1664:    tmp /= b;
        -: 1665:    return tmp;
        -: 1666:}
        -: 1667:
        -: 1668:template<typename _Tp> static inline
        -: 1669:Point3_<_Tp> operator / (const Point3_<_Tp>& a, double b)
        -: 1670:{
        -: 1671:    Point3_<_Tp> tmp(a);
        -: 1672:    tmp /= b;
        -: 1673:    return tmp;
        -: 1674:}
        -: 1675:
        -: 1676:
        -: 1677:
        -: 1678:////////////////////////////////// Size /////////////////////////////////
        -: 1679:
        -: 1680:template<typename _Tp> inline
        -: 1681:Size_<_Tp>::Size_()
        -: 1682:    : width(0), height(0) {}
        -: 1683:
        -: 1684:template<typename _Tp> inline
        2: 1685:Size_<_Tp>::Size_(_Tp _width, _Tp _height)
        1: 1685-block  0
        1: 1685-block  1
        2: 1686:    : width(_width), height(_height) {}
        1: 1686-block  0
        1: 1686-block  1
        -: 1687:
        -: 1688:template<typename _Tp> inline
        -: 1689:Size_<_Tp>::Size_(const Size_& sz)
        -: 1690:    : width(sz.width), height(sz.height) {}
        -: 1691:
        -: 1692:template<typename _Tp> inline
        -: 1693:Size_<_Tp>::Size_(Size_&& sz) CV_NOEXCEPT
        -: 1694:    : width(std::move(sz.width)), height(std::move(sz.height)) {}
        -: 1695:
        -: 1696:template<typename _Tp> inline
        -: 1697:Size_<_Tp>::Size_(const Point_<_Tp>& pt)
        -: 1698:    : width(pt.x), height(pt.y) {}
        -: 1699:
        -: 1700:template<typename _Tp> template<typename _Tp2> inline
        -: 1701:Size_<_Tp>::operator Size_<_Tp2>() const
        -: 1702:{
        -: 1703:    return Size_<_Tp2>(saturate_cast<_Tp2>(width), saturate_cast<_Tp2>(height));
        -: 1704:}
        -: 1705:
        -: 1706:template<typename _Tp> inline
        -: 1707:Size_<_Tp>& Size_<_Tp>::operator = (const Size_<_Tp>& sz)
        -: 1708:{
        -: 1709:    width = sz.width; height = sz.height;
        -: 1710:    return *this;
        -: 1711:}
        -: 1712:
        -: 1713:template<typename _Tp> inline
        -: 1714:Size_<_Tp>& Size_<_Tp>::operator = (Size_<_Tp>&& sz) CV_NOEXCEPT
        -: 1715:{
        -: 1716:    width = std::move(sz.width); height = std::move(sz.height);
        -: 1717:    return *this;
        -: 1718:}
        -: 1719:
        -: 1720:template<typename _Tp> inline
        -: 1721:_Tp Size_<_Tp>::area() const
        -: 1722:{
        -: 1723:    const _Tp result = width * height;
        -: 1724:    CV_DbgAssert(!std::numeric_limits<_Tp>::is_integer
        -: 1725:        || width == 0 || result / width == height); // make sure the result fits in the return value
        -: 1726:    return result;
        -: 1727:}
        -: 1728:
        -: 1729:template<typename _Tp> inline
        -: 1730:double Size_<_Tp>::aspectRatio() const
        -: 1731:{
        -: 1732:    return width / static_cast<double>(height);
        -: 1733:}
        -: 1734:
        -: 1735:template<typename _Tp> inline
        -: 1736:bool Size_<_Tp>::empty() const
        -: 1737:{
        -: 1738:    return width <= 0 || height <= 0;
        -: 1739:}
        -: 1740:
        -: 1741:
        -: 1742:template<typename _Tp> static inline
        -: 1743:Size_<_Tp>& operator *= (Size_<_Tp>& a, _Tp b)
        -: 1744:{
        -: 1745:    a.width *= b;
        -: 1746:    a.height *= b;
        -: 1747:    return a;
        -: 1748:}
        -: 1749:
        -: 1750:template<typename _Tp> static inline
        -: 1751:Size_<_Tp> operator * (const Size_<_Tp>& a, _Tp b)
        -: 1752:{
        -: 1753:    Size_<_Tp> tmp(a);
        -: 1754:    tmp *= b;
        -: 1755:    return tmp;
        -: 1756:}
        -: 1757:
        -: 1758:template<typename _Tp> static inline
        -: 1759:Size_<_Tp>& operator /= (Size_<_Tp>& a, _Tp b)
        -: 1760:{
        -: 1761:    a.width /= b;
        -: 1762:    a.height /= b;
        -: 1763:    return a;
        -: 1764:}
        -: 1765:
        -: 1766:template<typename _Tp> static inline
        -: 1767:Size_<_Tp> operator / (const Size_<_Tp>& a, _Tp b)
        -: 1768:{
        -: 1769:    Size_<_Tp> tmp(a);
        -: 1770:    tmp /= b;
        -: 1771:    return tmp;
        -: 1772:}
        -: 1773:
        -: 1774:template<typename _Tp> static inline
        -: 1775:Size_<_Tp>& operator += (Size_<_Tp>& a, const Size_<_Tp>& b)
        -: 1776:{
        -: 1777:    a.width += b.width;
        -: 1778:    a.height += b.height;
        -: 1779:    return a;
        -: 1780:}
        -: 1781:
        -: 1782:template<typename _Tp> static inline
        -: 1783:Size_<_Tp> operator + (const Size_<_Tp>& a, const Size_<_Tp>& b)
        -: 1784:{
        -: 1785:    Size_<_Tp> tmp(a);
        -: 1786:    tmp += b;
        -: 1787:    return tmp;
        -: 1788:}
        -: 1789:
        -: 1790:template<typename _Tp> static inline
        -: 1791:Size_<_Tp>& operator -= (Size_<_Tp>& a, const Size_<_Tp>& b)
        -: 1792:{
        -: 1793:    a.width -= b.width;
        -: 1794:    a.height -= b.height;
        -: 1795:    return a;
        -: 1796:}
        -: 1797:
        -: 1798:template<typename _Tp> static inline
        -: 1799:Size_<_Tp> operator - (const Size_<_Tp>& a, const Size_<_Tp>& b)
        -: 1800:{
        -: 1801:    Size_<_Tp> tmp(a);
        -: 1802:    tmp -= b;
        -: 1803:    return tmp;
        -: 1804:}
        -: 1805:
        -: 1806:template<typename _Tp> static inline
        -: 1807:bool operator == (const Size_<_Tp>& a, const Size_<_Tp>& b)
        -: 1808:{
        -: 1809:    return a.width == b.width && a.height == b.height;
        -: 1810:}
        -: 1811:
        -: 1812:template<typename _Tp> static inline
        -: 1813:bool operator != (const Size_<_Tp>& a, const Size_<_Tp>& b)
        -: 1814:{
        -: 1815:    return !(a == b);
        -: 1816:}
        -: 1817:
        -: 1818:
        -: 1819:
        -: 1820:////////////////////////////////// Rect /////////////////////////////////
        -: 1821:
        -: 1822:template<typename _Tp> inline
        -: 1823:Rect_<_Tp>::Rect_()
        -: 1824:    : x(0), y(0), width(0), height(0) {}
        -: 1825:
        -: 1826:template<typename _Tp> inline
        -: 1827:Rect_<_Tp>::Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height)
        -: 1828:    : x(_x), y(_y), width(_width), height(_height) {}
        -: 1829:
        -: 1830:template<typename _Tp> inline
        -: 1831:Rect_<_Tp>::Rect_(const Rect_<_Tp>& r)
        -: 1832:    : x(r.x), y(r.y), width(r.width), height(r.height) {}
        -: 1833:
        -: 1834:template<typename _Tp> inline
        -: 1835:Rect_<_Tp>::Rect_(Rect_<_Tp>&& r) CV_NOEXCEPT
        -: 1836:    : x(std::move(r.x)), y(std::move(r.y)), width(std::move(r.width)), height(std::move(r.height)) {}
        -: 1837:
        -: 1838:template<typename _Tp> inline
        -: 1839:Rect_<_Tp>::Rect_(const Point_<_Tp>& org, const Size_<_Tp>& sz)
        -: 1840:    : x(org.x), y(org.y), width(sz.width), height(sz.height) {}
        -: 1841:
        -: 1842:template<typename _Tp> inline
        -: 1843:Rect_<_Tp>::Rect_(const Point_<_Tp>& pt1, const Point_<_Tp>& pt2)
        -: 1844:{
        -: 1845:    x = std::min(pt1.x, pt2.x);
        -: 1846:    y = std::min(pt1.y, pt2.y);
        -: 1847:    width = std::max(pt1.x, pt2.x) - x;
        -: 1848:    height = std::max(pt1.y, pt2.y) - y;
        -: 1849:}
        -: 1850:
        -: 1851:template<typename _Tp> inline
        -: 1852:Rect_<_Tp>& Rect_<_Tp>::operator = ( const Rect_<_Tp>& r )
        -: 1853:{
        -: 1854:    x = r.x;
        -: 1855:    y = r.y;
        -: 1856:    width = r.width;
        -: 1857:    height = r.height;
        -: 1858:    return *this;
        -: 1859:}
        -: 1860:
        -: 1861:template<typename _Tp> inline
        -: 1862:Rect_<_Tp>& Rect_<_Tp>::operator = ( Rect_<_Tp>&& r ) CV_NOEXCEPT
        -: 1863:{
        -: 1864:    x = std::move(r.x);
        -: 1865:    y = std::move(r.y);
        -: 1866:    width = std::move(r.width);
        -: 1867:    height = std::move(r.height);
        -: 1868:    return *this;
        -: 1869:}
        -: 1870:
        -: 1871:template<typename _Tp> inline
        -: 1872:Point_<_Tp> Rect_<_Tp>::tl() const
        -: 1873:{
        -: 1874:    return Point_<_Tp>(x,y);
        -: 1875:}
        -: 1876:
        -: 1877:template<typename _Tp> inline
        -: 1878:Point_<_Tp> Rect_<_Tp>::br() const
        -: 1879:{
        -: 1880:    return Point_<_Tp>(x + width, y + height);
        -: 1881:}
        -: 1882:
        -: 1883:template<typename _Tp> inline
        -: 1884:Size_<_Tp> Rect_<_Tp>::size() const
        -: 1885:{
        -: 1886:    return Size_<_Tp>(width, height);
        -: 1887:}
        -: 1888:
        -: 1889:template<typename _Tp> inline
        -: 1890:_Tp Rect_<_Tp>::area() const
        -: 1891:{
        -: 1892:    const _Tp result = width * height;
        -: 1893:    CV_DbgAssert(!std::numeric_limits<_Tp>::is_integer
        -: 1894:        || width == 0 || result / width == height); // make sure the result fits in the return value
        -: 1895:    return result;
        -: 1896:}
        -: 1897:
        -: 1898:template<typename _Tp> inline
        -: 1899:bool Rect_<_Tp>::empty() const
        -: 1900:{
        -: 1901:    return width <= 0 || height <= 0;
        -: 1902:}
        -: 1903:
        -: 1904:template<typename _Tp> template<typename _Tp2> inline
        -: 1905:Rect_<_Tp>::operator Rect_<_Tp2>() const
        -: 1906:{
        -: 1907:    return Rect_<_Tp2>(saturate_cast<_Tp2>(x), saturate_cast<_Tp2>(y), saturate_cast<_Tp2>(width), saturate_cast<_Tp2>(height));
        -: 1908:}
        -: 1909:
        -: 1910:template<typename _Tp> inline
        -: 1911:bool Rect_<_Tp>::contains(const Point_<_Tp>& pt) const
        -: 1912:{
        -: 1913:    return x <= pt.x && pt.x < x + width && y <= pt.y && pt.y < y + height;
        -: 1914:}
        -: 1915:
        -: 1916:
        -: 1917:template<typename _Tp> static inline
        -: 1918:Rect_<_Tp>& operator += ( Rect_<_Tp>& a, const Point_<_Tp>& b )
        -: 1919:{
        -: 1920:    a.x += b.x;
        -: 1921:    a.y += b.y;
        -: 1922:    return a;
        -: 1923:}
        -: 1924:
        -: 1925:template<typename _Tp> static inline
        -: 1926:Rect_<_Tp>& operator -= ( Rect_<_Tp>& a, const Point_<_Tp>& b )
        -: 1927:{
        -: 1928:    a.x -= b.x;
        -: 1929:    a.y -= b.y;
        -: 1930:    return a;
        -: 1931:}
        -: 1932:
        -: 1933:template<typename _Tp> static inline
        -: 1934:Rect_<_Tp>& operator += ( Rect_<_Tp>& a, const Size_<_Tp>& b )
        -: 1935:{
        -: 1936:    a.width += b.width;
        -: 1937:    a.height += b.height;
        -: 1938:    return a;
        -: 1939:}
        -: 1940:
        -: 1941:template<typename _Tp> static inline
        -: 1942:Rect_<_Tp>& operator -= ( Rect_<_Tp>& a, const Size_<_Tp>& b )
        -: 1943:{
        -: 1944:    const _Tp width = a.width - b.width;
        -: 1945:    const _Tp height = a.height - b.height;
        -: 1946:    CV_DbgAssert(width >= 0 && height >= 0);
        -: 1947:    a.width = width;
        -: 1948:    a.height = height;
        -: 1949:    return a;
        -: 1950:}
        -: 1951:
        -: 1952:template<typename _Tp> static inline
        -: 1953:Rect_<_Tp>& operator &= ( Rect_<_Tp>& a, const Rect_<_Tp>& b )
        -: 1954:{
        -: 1955:    _Tp x1 = std::max(a.x, b.x);
        -: 1956:    _Tp y1 = std::max(a.y, b.y);
        -: 1957:    a.width = std::min(a.x + a.width, b.x + b.width) - x1;
        -: 1958:    a.height = std::min(a.y + a.height, b.y + b.height) - y1;
        -: 1959:    a.x = x1;
        -: 1960:    a.y = y1;
        -: 1961:    if( a.width <= 0 || a.height <= 0 )
        -: 1962:        a = Rect();
        -: 1963:    return a;
        -: 1964:}
        -: 1965:
        -: 1966:template<typename _Tp> static inline
        -: 1967:Rect_<_Tp>& operator |= ( Rect_<_Tp>& a, const Rect_<_Tp>& b )
        -: 1968:{
        -: 1969:    if (a.empty()) {
        -: 1970:        a = b;
        -: 1971:    }
        -: 1972:    else if (!b.empty()) {
        -: 1973:        _Tp x1 = std::min(a.x, b.x);
        -: 1974:        _Tp y1 = std::min(a.y, b.y);
        -: 1975:        a.width = std::max(a.x + a.width, b.x + b.width) - x1;
        -: 1976:        a.height = std::max(a.y + a.height, b.y + b.height) - y1;
        -: 1977:        a.x = x1;
        -: 1978:        a.y = y1;
        -: 1979:    }
        -: 1980:    return a;
        -: 1981:}
        -: 1982:
        -: 1983:template<typename _Tp> static inline
        -: 1984:bool operator == (const Rect_<_Tp>& a, const Rect_<_Tp>& b)
        -: 1985:{
        -: 1986:    return a.x == b.x && a.y == b.y && a.width == b.width && a.height == b.height;
        -: 1987:}
        -: 1988:
        -: 1989:template<typename _Tp> static inline
        -: 1990:bool operator != (const Rect_<_Tp>& a, const Rect_<_Tp>& b)
        -: 1991:{
        -: 1992:    return a.x != b.x || a.y != b.y || a.width != b.width || a.height != b.height;
        -: 1993:}
        -: 1994:
        -: 1995:template<typename _Tp> static inline
        -: 1996:Rect_<_Tp> operator + (const Rect_<_Tp>& a, const Point_<_Tp>& b)
        -: 1997:{
        -: 1998:    return Rect_<_Tp>( a.x + b.x, a.y + b.y, a.width, a.height );
        -: 1999:}
        -: 2000:
        -: 2001:template<typename _Tp> static inline
        -: 2002:Rect_<_Tp> operator - (const Rect_<_Tp>& a, const Point_<_Tp>& b)
        -: 2003:{
        -: 2004:    return Rect_<_Tp>( a.x - b.x, a.y - b.y, a.width, a.height );
        -: 2005:}
        -: 2006:
        -: 2007:template<typename _Tp> static inline
        -: 2008:Rect_<_Tp> operator + (const Rect_<_Tp>& a, const Size_<_Tp>& b)
        -: 2009:{
        -: 2010:    return Rect_<_Tp>( a.x, a.y, a.width + b.width, a.height + b.height );
        -: 2011:}
        -: 2012:
        -: 2013:template<typename _Tp> static inline
        -: 2014:Rect_<_Tp> operator - (const Rect_<_Tp>& a, const Size_<_Tp>& b)
        -: 2015:{
        -: 2016:    const _Tp width = a.width - b.width;
        -: 2017:    const _Tp height = a.height - b.height;
        -: 2018:    CV_DbgAssert(width >= 0 && height >= 0);
        -: 2019:    return Rect_<_Tp>( a.x, a.y, width, height );
        -: 2020:}
        -: 2021:
        -: 2022:template<typename _Tp> static inline
        -: 2023:Rect_<_Tp> operator & (const Rect_<_Tp>& a, const Rect_<_Tp>& b)
        -: 2024:{
        -: 2025:    Rect_<_Tp> c = a;
        -: 2026:    return c &= b;
        -: 2027:}
        -: 2028:
        -: 2029:template<typename _Tp> static inline
        -: 2030:Rect_<_Tp> operator | (const Rect_<_Tp>& a, const Rect_<_Tp>& b)
        -: 2031:{
        -: 2032:    Rect_<_Tp> c = a;
        -: 2033:    return c |= b;
        -: 2034:}
        -: 2035:
        -: 2036:/**
        -: 2037: * @brief measure dissimilarity between two sample sets
        -: 2038: *
        -: 2039: * computes the complement of the Jaccard Index as described in <https://en.wikipedia.org/wiki/Jaccard_index>.
        -: 2040: * For rectangles this reduces to computing the intersection over the union.
        -: 2041: */
        -: 2042:template<typename _Tp> static inline
        -: 2043:double jaccardDistance(const Rect_<_Tp>& a, const Rect_<_Tp>& b) {
        -: 2044:    _Tp Aa = a.area();
        -: 2045:    _Tp Ab = b.area();
        -: 2046:
        -: 2047:    if ((Aa + Ab) <= std::numeric_limits<_Tp>::epsilon()) {
        -: 2048:        // jaccard_index = 1 -> distance = 0
        -: 2049:        return 0.0;
        -: 2050:    }
        -: 2051:
        -: 2052:    double Aab = (a & b).area();
        -: 2053:    // distance = 1 - jaccard_index
        -: 2054:    return 1.0 - Aab / (Aa + Ab - Aab);
        -: 2055:}
        -: 2056:
        -: 2057:////////////////////////////// RotatedRect //////////////////////////////
        -: 2058:
        -: 2059:inline
        -: 2060:RotatedRect::RotatedRect()
        -: 2061:    : center(), size(), angle(0) {}
        -: 2062:
        -: 2063:inline
        -: 2064:RotatedRect::RotatedRect(const Point2f& _center, const Size2f& _size, float _angle)
        -: 2065:    : center(_center), size(_size), angle(_angle) {}
        -: 2066:
        -: 2067:///////////////////////////////// Range /////////////////////////////////
        -: 2068:
        -: 2069:inline
        -: 2070:Range::Range()
        -: 2071:    : start(0), end(0) {}
        -: 2072:
        -: 2073:inline
        -: 2074:Range::Range(int _start, int _end)
        -: 2075:    : start(_start), end(_end) {}
        -: 2076:
        -: 2077:inline
        -: 2078:int Range::size() const
        -: 2079:{
        -: 2080:    return end - start;
        -: 2081:}
        -: 2082:
        -: 2083:inline
        -: 2084:bool Range::empty() const
        -: 2085:{
        -: 2086:    return start == end;
        -: 2087:}
        -: 2088:
        -: 2089:inline
        -: 2090:Range Range::all()
        -: 2091:{
        -: 2092:    return Range(INT_MIN, INT_MAX);
        -: 2093:}
        -: 2094:
        -: 2095:
        -: 2096:static inline
        -: 2097:bool operator == (const Range& r1, const Range& r2)
        -: 2098:{
        -: 2099:    return r1.start == r2.start && r1.end == r2.end;
        -: 2100:}
        -: 2101:
        -: 2102:static inline
        -: 2103:bool operator != (const Range& r1, const Range& r2)
        -: 2104:{
        -: 2105:    return !(r1 == r2);
        -: 2106:}
        -: 2107:
        -: 2108:static inline
        -: 2109:bool operator !(const Range& r)
        -: 2110:{
        -: 2111:    return r.start == r.end;
        -: 2112:}
        -: 2113:
        -: 2114:static inline
        -: 2115:Range operator & (const Range& r1, const Range& r2)
        -: 2116:{
        -: 2117:    Range r(std::max(r1.start, r2.start), std::min(r1.end, r2.end));
        -: 2118:    r.end = std::max(r.end, r.start);
        -: 2119:    return r;
        -: 2120:}
        -: 2121:
        -: 2122:static inline
        -: 2123:Range& operator &= (Range& r1, const Range& r2)
        -: 2124:{
        -: 2125:    r1 = r1 & r2;
        -: 2126:    return r1;
        -: 2127:}
        -: 2128:
        -: 2129:static inline
        -: 2130:Range operator + (const Range& r1, int delta)
        -: 2131:{
        -: 2132:    return Range(r1.start + delta, r1.end + delta);
        -: 2133:}
        -: 2134:
        -: 2135:static inline
        -: 2136:Range operator + (int delta, const Range& r1)
        -: 2137:{
        -: 2138:    return Range(r1.start + delta, r1.end + delta);
        -: 2139:}
        -: 2140:
        -: 2141:static inline
        -: 2142:Range operator - (const Range& r1, int delta)
        -: 2143:{
        -: 2144:    return r1 + (-delta);
        -: 2145:}
        -: 2146:
        -: 2147:
        -: 2148:
        -: 2149:///////////////////////////////// Scalar ////////////////////////////////
        -: 2150:
        -: 2151:template<typename _Tp> inline
        -: 2152:Scalar_<_Tp>::Scalar_()
        -: 2153:{
        -: 2154:    this->val[0] = this->val[1] = this->val[2] = this->val[3] = 0;
        -: 2155:}
        -: 2156:
        -: 2157:template<typename _Tp> inline
        -: 2158:Scalar_<_Tp>::Scalar_(_Tp v0, _Tp v1, _Tp v2, _Tp v3)
        -: 2159:{
        -: 2160:    this->val[0] = v0;
        -: 2161:    this->val[1] = v1;
        -: 2162:    this->val[2] = v2;
        -: 2163:    this->val[3] = v3;
        -: 2164:}
        -: 2165:
        -: 2166:template<typename _Tp> inline
        -: 2167:Scalar_<_Tp>::Scalar_(const Scalar_<_Tp>& s) : Vec<_Tp, 4>(s) {
        -: 2168:}
        -: 2169:
        -: 2170:template<typename _Tp> inline
        -: 2171:Scalar_<_Tp>::Scalar_(Scalar_<_Tp>&& s) CV_NOEXCEPT {
        -: 2172:    this->val[0] = std::move(s.val[0]);
        -: 2173:    this->val[1] = std::move(s.val[1]);
        -: 2174:    this->val[2] = std::move(s.val[2]);
        -: 2175:    this->val[3] = std::move(s.val[3]);
        -: 2176:}
        -: 2177:
        -: 2178:template<typename _Tp> inline
        -: 2179:Scalar_<_Tp>& Scalar_<_Tp>::operator=(const Scalar_<_Tp>& s) {
        -: 2180:    this->val[0] = s.val[0];
        -: 2181:    this->val[1] = s.val[1];
        -: 2182:    this->val[2] = s.val[2];
        -: 2183:    this->val[3] = s.val[3];
        -: 2184:    return *this;
        -: 2185:}
        -: 2186:
        -: 2187:template<typename _Tp> inline
        -: 2188:Scalar_<_Tp>& Scalar_<_Tp>::operator=(Scalar_<_Tp>&& s) CV_NOEXCEPT {
        -: 2189:    this->val[0] = std::move(s.val[0]);
        -: 2190:    this->val[1] = std::move(s.val[1]);
        -: 2191:    this->val[2] = std::move(s.val[2]);
        -: 2192:    this->val[3] = std::move(s.val[3]);
        -: 2193:    return *this;
        -: 2194:}
        -: 2195:
        -: 2196:template<typename _Tp> template<typename _Tp2, int cn> inline
        -: 2197:Scalar_<_Tp>::Scalar_(const Vec<_Tp2, cn>& v)
        -: 2198:{
        -: 2199:    int i;
        -: 2200:    for( i = 0; i < (cn < 4 ? cn : 4); i++ )
        -: 2201:        this->val[i] = cv::saturate_cast<_Tp>(v.val[i]);
        -: 2202:    for( ; i < 4; i++ )
        -: 2203:        this->val[i] = 0;
        -: 2204:}
        -: 2205:
        -: 2206:template<typename _Tp> inline
        -: 2207:Scalar_<_Tp>::Scalar_(_Tp v0)
        -: 2208:{
        -: 2209:    this->val[0] = v0;
        -: 2210:    this->val[1] = this->val[2] = this->val[3] = 0;
        -: 2211:}
        -: 2212:
        -: 2213:template<typename _Tp> inline
        -: 2214:Scalar_<_Tp> Scalar_<_Tp>::all(_Tp v0)
        -: 2215:{
        -: 2216:    return Scalar_<_Tp>(v0, v0, v0, v0);
        -: 2217:}
        -: 2218:
        -: 2219:
        -: 2220:template<typename _Tp> inline
        -: 2221:Scalar_<_Tp> Scalar_<_Tp>::mul(const Scalar_<_Tp>& a, double scale ) const
        -: 2222:{
        -: 2223:    return Scalar_<_Tp>(saturate_cast<_Tp>(this->val[0] * a.val[0] * scale),
        -: 2224:                        saturate_cast<_Tp>(this->val[1] * a.val[1] * scale),
        -: 2225:                        saturate_cast<_Tp>(this->val[2] * a.val[2] * scale),
        -: 2226:                        saturate_cast<_Tp>(this->val[3] * a.val[3] * scale));
        -: 2227:}
        -: 2228:
        -: 2229:template<typename _Tp> inline
        -: 2230:Scalar_<_Tp> Scalar_<_Tp>::conj() const
        -: 2231:{
        -: 2232:    return Scalar_<_Tp>(saturate_cast<_Tp>( this->val[0]),
        -: 2233:                        saturate_cast<_Tp>(-this->val[1]),
        -: 2234:                        saturate_cast<_Tp>(-this->val[2]),
        -: 2235:                        saturate_cast<_Tp>(-this->val[3]));
        -: 2236:}
        -: 2237:
        -: 2238:template<typename _Tp> inline
        -: 2239:bool Scalar_<_Tp>::isReal() const
        -: 2240:{
        -: 2241:    return this->val[1] == 0 && this->val[2] == 0 && this->val[3] == 0;
        -: 2242:}
        -: 2243:
        -: 2244:
        -: 2245:template<typename _Tp> template<typename T2> inline
        -: 2246:Scalar_<_Tp>::operator Scalar_<T2>() const
        -: 2247:{
        -: 2248:    return Scalar_<T2>(saturate_cast<T2>(this->val[0]),
        -: 2249:                       saturate_cast<T2>(this->val[1]),
        -: 2250:                       saturate_cast<T2>(this->val[2]),
        -: 2251:                       saturate_cast<T2>(this->val[3]));
        -: 2252:}
        -: 2253:
        -: 2254:
        -: 2255:template<typename _Tp> static inline
        -: 2256:Scalar_<_Tp>& operator += (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
        -: 2257:{
        -: 2258:    a.val[0] += b.val[0];
        -: 2259:    a.val[1] += b.val[1];
        -: 2260:    a.val[2] += b.val[2];
        -: 2261:    a.val[3] += b.val[3];
        -: 2262:    return a;
        -: 2263:}
        -: 2264:
        -: 2265:template<typename _Tp> static inline
        -: 2266:Scalar_<_Tp>& operator -= (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
        -: 2267:{
        -: 2268:    a.val[0] -= b.val[0];
        -: 2269:    a.val[1] -= b.val[1];
        -: 2270:    a.val[2] -= b.val[2];
        -: 2271:    a.val[3] -= b.val[3];
        -: 2272:    return a;
        -: 2273:}
        -: 2274:
        -: 2275:template<typename _Tp> static inline
        -: 2276:Scalar_<_Tp>& operator *= ( Scalar_<_Tp>& a, _Tp v )
        -: 2277:{
        -: 2278:    a.val[0] *= v;
        -: 2279:    a.val[1] *= v;
        -: 2280:    a.val[2] *= v;
        -: 2281:    a.val[3] *= v;
        -: 2282:    return a;
        -: 2283:}
        -: 2284:
        -: 2285:template<typename _Tp> static inline
        -: 2286:bool operator == ( const Scalar_<_Tp>& a, const Scalar_<_Tp>& b )
        -: 2287:{
        -: 2288:    return a.val[0] == b.val[0] && a.val[1] == b.val[1] &&
        -: 2289:           a.val[2] == b.val[2] && a.val[3] == b.val[3];
        -: 2290:}
        -: 2291:
        -: 2292:template<typename _Tp> static inline
        -: 2293:bool operator != ( const Scalar_<_Tp>& a, const Scalar_<_Tp>& b )
        -: 2294:{
        -: 2295:    return a.val[0] != b.val[0] || a.val[1] != b.val[1] ||
        -: 2296:           a.val[2] != b.val[2] || a.val[3] != b.val[3];
        -: 2297:}
        -: 2298:
        -: 2299:template<typename _Tp> static inline
        -: 2300:Scalar_<_Tp> operator + (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
        -: 2301:{
        -: 2302:    return Scalar_<_Tp>(a.val[0] + b.val[0],
        -: 2303:                        a.val[1] + b.val[1],
        -: 2304:                        a.val[2] + b.val[2],
        -: 2305:                        a.val[3] + b.val[3]);
        -: 2306:}
        -: 2307:
        -: 2308:template<typename _Tp> static inline
        -: 2309:Scalar_<_Tp> operator - (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
        -: 2310:{
        -: 2311:    return Scalar_<_Tp>(saturate_cast<_Tp>(a.val[0] - b.val[0]),
        -: 2312:                        saturate_cast<_Tp>(a.val[1] - b.val[1]),
        -: 2313:                        saturate_cast<_Tp>(a.val[2] - b.val[2]),
        -: 2314:                        saturate_cast<_Tp>(a.val[3] - b.val[3]));
        -: 2315:}
        -: 2316:
        -: 2317:template<typename _Tp> static inline
        -: 2318:Scalar_<_Tp> operator * (const Scalar_<_Tp>& a, _Tp alpha)
        -: 2319:{
        -: 2320:    return Scalar_<_Tp>(a.val[0] * alpha,
        -: 2321:                        a.val[1] * alpha,
        -: 2322:                        a.val[2] * alpha,
        -: 2323:                        a.val[3] * alpha);
        -: 2324:}
        -: 2325:
        -: 2326:template<typename _Tp> static inline
        -: 2327:Scalar_<_Tp> operator * (_Tp alpha, const Scalar_<_Tp>& a)
        -: 2328:{
        -: 2329:    return a*alpha;
        -: 2330:}
        -: 2331:
        -: 2332:template<typename _Tp> static inline
        -: 2333:Scalar_<_Tp> operator - (const Scalar_<_Tp>& a)
        -: 2334:{
        -: 2335:    return Scalar_<_Tp>(saturate_cast<_Tp>(-a.val[0]),
        -: 2336:                        saturate_cast<_Tp>(-a.val[1]),
        -: 2337:                        saturate_cast<_Tp>(-a.val[2]),
        -: 2338:                        saturate_cast<_Tp>(-a.val[3]));
        -: 2339:}
        -: 2340:
        -: 2341:
        -: 2342:template<typename _Tp> static inline
        -: 2343:Scalar_<_Tp> operator * (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
        -: 2344:{
        -: 2345:    return Scalar_<_Tp>(saturate_cast<_Tp>(a[0]*b[0] - a[1]*b[1] - a[2]*b[2] - a[3]*b[3]),
        -: 2346:                        saturate_cast<_Tp>(a[0]*b[1] + a[1]*b[0] + a[2]*b[3] - a[3]*b[2]),
        -: 2347:                        saturate_cast<_Tp>(a[0]*b[2] - a[1]*b[3] + a[2]*b[0] + a[3]*b[1]),
        -: 2348:                        saturate_cast<_Tp>(a[0]*b[3] + a[1]*b[2] - a[2]*b[1] + a[3]*b[0]));
        -: 2349:}
        -: 2350:
        -: 2351:template<typename _Tp> static inline
        -: 2352:Scalar_<_Tp>& operator *= (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
        -: 2353:{
        -: 2354:    a = a * b;
        -: 2355:    return a;
        -: 2356:}
        -: 2357:
        -: 2358:template<typename _Tp> static inline
        -: 2359:Scalar_<_Tp> operator / (const Scalar_<_Tp>& a, _Tp alpha)
        -: 2360:{
        -: 2361:    return Scalar_<_Tp>(a.val[0] / alpha,
        -: 2362:                        a.val[1] / alpha,
        -: 2363:                        a.val[2] / alpha,
        -: 2364:                        a.val[3] / alpha);
        -: 2365:}
        -: 2366:
        -: 2367:template<typename _Tp> static inline
        -: 2368:Scalar_<float> operator / (const Scalar_<float>& a, float alpha)
        -: 2369:{
        -: 2370:    float s = 1 / alpha;
        -: 2371:    return Scalar_<float>(a.val[0] * s, a.val[1] * s, a.val[2] * s, a.val[3] * s);
        -: 2372:}
        -: 2373:
        -: 2374:template<typename _Tp> static inline
        -: 2375:Scalar_<double> operator / (const Scalar_<double>& a, double alpha)
        -: 2376:{
        -: 2377:    double s = 1 / alpha;
        -: 2378:    return Scalar_<double>(a.val[0] * s, a.val[1] * s, a.val[2] * s, a.val[3] * s);
        -: 2379:}
        -: 2380:
        -: 2381:template<typename _Tp> static inline
        -: 2382:Scalar_<_Tp>& operator /= (Scalar_<_Tp>& a, _Tp alpha)
        -: 2383:{
        -: 2384:    a = a / alpha;
        -: 2385:    return a;
        -: 2386:}
        -: 2387:
        -: 2388:template<typename _Tp> static inline
        -: 2389:Scalar_<_Tp> operator / (_Tp a, const Scalar_<_Tp>& b)
        -: 2390:{
        -: 2391:    _Tp s = a / (b[0]*b[0] + b[1]*b[1] + b[2]*b[2] + b[3]*b[3]);
        -: 2392:    return b.conj() * s;
        -: 2393:}
        -: 2394:
        -: 2395:template<typename _Tp> static inline
        -: 2396:Scalar_<_Tp> operator / (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
        -: 2397:{
        -: 2398:    return a * ((_Tp)1 / b);
        -: 2399:}
        -: 2400:
        -: 2401:template<typename _Tp> static inline
        -: 2402:Scalar_<_Tp>& operator /= (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
        -: 2403:{
        -: 2404:    a = a / b;
        -: 2405:    return a;
        -: 2406:}
        -: 2407:
        -: 2408:template<typename _Tp> static inline
        -: 2409:Scalar operator * (const Matx<_Tp, 4, 4>& a, const Scalar& b)
        -: 2410:{
        -: 2411:    Matx<double, 4, 1> c((Matx<double, 4, 4>)a, b, Matx_MatMulOp());
        -: 2412:    return reinterpret_cast<const Scalar&>(c);
        -: 2413:}
        -: 2414:
        -: 2415:template<> inline
        -: 2416:Scalar operator * (const Matx<double, 4, 4>& a, const Scalar& b)
        -: 2417:{
        -: 2418:    Matx<double, 4, 1> c(a, b, Matx_MatMulOp());
        -: 2419:    return reinterpret_cast<const Scalar&>(c);
        -: 2420:}
        -: 2421:
        -: 2422:
        -: 2423:
        -: 2424://////////////////////////////// KeyPoint ///////////////////////////////
        -: 2425:
        -: 2426:inline
        -: 2427:KeyPoint::KeyPoint()
        -: 2428:    : pt(0,0), size(0), angle(-1), response(0), octave(0), class_id(-1) {}
        -: 2429:
        -: 2430:inline
        -: 2431:KeyPoint::KeyPoint(Point2f _pt, float _size, float _angle, float _response, int _octave, int _class_id)
        -: 2432:    : pt(_pt), size(_size), angle(_angle), response(_response), octave(_octave), class_id(_class_id) {}
        -: 2433:
        -: 2434:inline
        -: 2435:KeyPoint::KeyPoint(float x, float y, float _size, float _angle, float _response, int _octave, int _class_id)
        -: 2436:    : pt(x, y), size(_size), angle(_angle), response(_response), octave(_octave), class_id(_class_id) {}
        -: 2437:
        -: 2438:
        -: 2439:
        -: 2440:///////////////////////////////// DMatch ////////////////////////////////
        -: 2441:
        -: 2442:inline
        -: 2443:DMatch::DMatch()
        -: 2444:    : queryIdx(-1), trainIdx(-1), imgIdx(-1), distance(FLT_MAX) {}
        -: 2445:
        -: 2446:inline
        -: 2447:DMatch::DMatch(int _queryIdx, int _trainIdx, float _distance)
        -: 2448:    : queryIdx(_queryIdx), trainIdx(_trainIdx), imgIdx(-1), distance(_distance) {}
        -: 2449:
        -: 2450:inline
        -: 2451:DMatch::DMatch(int _queryIdx, int _trainIdx, int _imgIdx, float _distance)
        -: 2452:    : queryIdx(_queryIdx), trainIdx(_trainIdx), imgIdx(_imgIdx), distance(_distance) {}
        -: 2453:
        -: 2454:inline
        -: 2455:bool DMatch::operator < (const DMatch &m) const
        -: 2456:{
        -: 2457:    return distance < m.distance;
        -: 2458:}
        -: 2459:
        -: 2460:
        -: 2461:
        -: 2462:////////////////////////////// TermCriteria /////////////////////////////
        -: 2463:
        -: 2464:inline
        -: 2465:TermCriteria::TermCriteria()
        -: 2466:    : type(0), maxCount(0), epsilon(0) {}
        -: 2467:
        -: 2468:inline
        -: 2469:TermCriteria::TermCriteria(int _type, int _maxCount, double _epsilon)
        -: 2470:    : type(_type), maxCount(_maxCount), epsilon(_epsilon) {}
        -: 2471:
        -: 2472://! @endcond
        -: 2473:
        -: 2474:} // cv
        -: 2475:
        -: 2476:#endif //OPENCV_CORE_TYPES_HPP
