        -:    0:Source:/Users/bytedance/CLionProjects/C-projcet/googletest/googletest/include/gtest/gtest-printers.h
        -:    0:Graph:/Users/bytedance/CLionProjects/C-projcet/cmake-build-debug/CMakeFiles/cppProject.dir/code/main.cpp.gcno
        -:    0:Data:/Users/bytedance/CLionProjects/C-projcet/cmake-build-debug/CMakeFiles/cppProject.dir/code/main.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// Copyright 2007, Google Inc.
        -:    2:// All rights reserved.
        -:    3://
        -:    4:// Redistribution and use in source and binary forms, with or without
        -:    5:// modification, are permitted provided that the following conditions are
        -:    6:// met:
        -:    7://
        -:    8://     * Redistributions of source code must retain the above copyright
        -:    9:// notice, this list of conditions and the following disclaimer.
        -:   10://     * Redistributions in binary form must reproduce the above
        -:   11:// copyright notice, this list of conditions and the following disclaimer
        -:   12:// in the documentation and/or other materials provided with the
        -:   13:// distribution.
        -:   14://     * Neither the name of Google Inc. nor the names of its
        -:   15:// contributors may be used to endorse or promote products derived from
        -:   16:// this software without specific prior written permission.
        -:   17://
        -:   18:// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
        -:   19:// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
        -:   20:// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
        -:   21:// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
        -:   22:// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
        -:   23:// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
        -:   24:// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
        -:   25:// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
        -:   26:// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   27:// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
        -:   28:// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   29:
        -:   30:
        -:   31:// Google Test - The Google C++ Testing and Mocking Framework
        -:   32://
        -:   33:// This file implements a universal value printer that can print a
        -:   34:// value of any type T:
        -:   35://
        -:   36://   void ::testing::internal::UniversalPrinter<T>::Print(value, ostream_ptr);
        -:   37://
        -:   38:// A user can teach this function how to print a class type T by
        -:   39:// defining either operator<<() or PrintTo() in the namespace that
        -:   40:// defines T.  More specifically, the FIRST defined function in the
        -:   41:// following list will be used (assuming T is defined in namespace
        -:   42:// foo):
        -:   43://
        -:   44://   1. foo::PrintTo(const T&, ostream*)
        -:   45://   2. operator<<(ostream&, const T&) defined in either foo or the
        -:   46://      global namespace.
        -:   47://
        -:   48:// However if T is an STL-style container then it is printed element-wise
        -:   49:// unless foo::PrintTo(const T&, ostream*) is defined. Note that
        -:   50:// operator<<() is ignored for container types.
        -:   51://
        -:   52:// If none of the above is defined, it will print the debug string of
        -:   53:// the value if it is a protocol buffer, or print the raw bytes in the
        -:   54:// value otherwise.
        -:   55://
        -:   56:// To aid debugging: when T is a reference type, the address of the
        -:   57:// value is also printed; when T is a (const) char pointer, both the
        -:   58:// pointer value and the NUL-terminated string it points to are
        -:   59:// printed.
        -:   60://
        -:   61:// We also provide some convenient wrappers:
        -:   62://
        -:   63://   // Prints a value to a string.  For a (const or not) char
        -:   64://   // pointer, the NUL-terminated string (but not the pointer) is
        -:   65://   // printed.
        -:   66://   std::string ::testing::PrintToString(const T& value);
        -:   67://
        -:   68://   // Prints a value tersely: for a reference type, the referenced
        -:   69://   // value (but not the address) is printed; for a (const or not) char
        -:   70://   // pointer, the NUL-terminated string (but not the pointer) is
        -:   71://   // printed.
        -:   72://   void ::testing::internal::UniversalTersePrint(const T& value, ostream*);
        -:   73://
        -:   74://   // Prints value using the type inferred by the compiler.  The difference
        -:   75://   // from UniversalTersePrint() is that this function prints both the
        -:   76://   // pointer and the NUL-terminated string for a (const or not) char pointer.
        -:   77://   void ::testing::internal::UniversalPrint(const T& value, ostream*);
        -:   78://
        -:   79://   // Prints the fields of a tuple tersely to a string vector, one
        -:   80://   // element for each field. Tuple support must be enabled in
        -:   81://   // gtest-port.h.
        -:   82://   std::vector<string> UniversalTersePrintTupleFieldsToStrings(
        -:   83://       const Tuple& value);
        -:   84://
        -:   85:// Known limitation:
        -:   86://
        -:   87:// The print primitives print the elements of an STL-style container
        -:   88:// using the compiler-inferred type of *iter where iter is a
        -:   89:// const_iterator of the container.  When const_iterator is an input
        -:   90:// iterator but not a forward iterator, this inferred type may not
        -:   91:// match value_type, and the print output may be incorrect.  In
        -:   92:// practice, this is rarely a problem as for most containers
        -:   93:// const_iterator is a forward iterator.  We'll fix this if there's an
        -:   94:// actual need for it.  Note that this fix cannot rely on value_type
        -:   95:// being defined as many user-defined container types don't have
        -:   96:// value_type.
        -:   97:
        -:   98:// GOOGLETEST_CM0001 DO NOT DELETE
        -:   99:
        -:  100:#ifndef GTEST_INCLUDE_GTEST_GTEST_PRINTERS_H_
        -:  101:#define GTEST_INCLUDE_GTEST_GTEST_PRINTERS_H_
        -:  102:
        -:  103:#include <functional>
        -:  104:#include <ostream>  // NOLINT
        -:  105:#include <sstream>
        -:  106:#include <string>
        -:  107:#include <tuple>
        -:  108:#include <type_traits>
        -:  109:#include <utility>
        -:  110:#include <vector>
        -:  111:#include "gtest/internal/gtest-internal.h"
        -:  112:#include "gtest/internal/gtest-port.h"
        -:  113:
        -:  114:#if GTEST_HAS_ABSL
        -:  115:#include "absl/strings/string_view.h"
        -:  116:#include "absl/types/optional.h"
        -:  117:#include "absl/types/variant.h"
        -:  118:#endif  // GTEST_HAS_ABSL
        -:  119:
        -:  120:namespace testing {
        -:  121:
        -:  122:// Definitions in the internal* namespaces are subject to change without notice.
        -:  123:// DO NOT USE THEM IN USER CODE!
        -:  124:    namespace internal {
        -:  125:
        -:  126:        template<typename T>
        -:  127:        void UniversalPrint(const T &value, ::std::ostream *os);
        -:  128:
        -:  129:// Used to print an STL-style container when the user doesn't define
        -:  130:// a PrintTo() for it.
        -:  131:        struct ContainerPrinter {
        -:  132:            template<typename T,
        -:  133:                    typename = typename std::enable_if<
        -:  134:                            (sizeof(IsContainerTest<T>(0)) == sizeof(IsContainer)) &&
        -:  135:                            !IsRecursiveContainer<T>::value>::type>
        -:  136:            static void PrintValue(const T &container, std::ostream *os) {
        -:  137:                const size_t kMaxCount = 32;  // The maximum number of elements to print.
        -:  138:                *os << '{';
        -:  139:                size_t count = 0;
        -:  140:                for (auto &&elem : container) {
        -:  141:                    if (count > 0) {
        -:  142:                        *os << ',';
        -:  143:                        if (count == kMaxCount) {  // Enough has been printed.
        -:  144:                            *os << " ...";
        -:  145:                            break;
        -:  146:                        }
        -:  147:                    }
        -:  148:                    *os << ' ';
        -:  149:                    // We cannot call PrintTo(elem, os) here as PrintTo() doesn't
        -:  150:                    // handle `elem` being a native array.
        -:  151:                    internal::UniversalPrint(elem, os);
        -:  152:                    ++count;
        -:  153:                }
        -:  154:
        -:  155:                if (count > 0) {
        -:  156:                    *os << ' ';
        -:  157:                }
        -:  158:                *os << '}';
        -:  159:            }
        -:  160:        };
        -:  161:
        -:  162:// Used to print a pointer that is neither a char pointer nor a member
        -:  163:// pointer, when the user doesn't define PrintTo() for it.  (A member
        -:  164:// variable pointer or member function pointer doesn't really point to
        -:  165:// a location in the address space.  Their representation is
        -:  166:// implementation-defined.  Therefore they will be printed as raw
        -:  167:// bytes.)
        -:  168:        struct FunctionPointerPrinter {
        -:  169:            template<typename T, typename = typename std::enable_if<
        -:  170:                    std::is_function<T>::value>::type>
        -:  171:            static void PrintValue(T *p, ::std::ostream *os) {
        -:  172:                if (p == nullptr) {
        -:  173:                    *os << "NULL";
        -:  174:                } else {
        -:  175:                    // T is a function type, so '*os << p' doesn't do what we want
        -:  176:                    // (it just prints p as bool).  We want to print p as a const
        -:  177:                    // void*.
        -:  178:                    *os << reinterpret_cast<const void *>(p);
        -:  179:                }
        -:  180:            }
        -:  181:        };
        -:  182:
        -:  183:        struct PointerPrinter {
        -:  184:            template<typename T>
        -:  185:            static void PrintValue(T *p, ::std::ostream *os) {
        -:  186:                if (p == nullptr) {
        -:  187:                    *os << "NULL";
        -:  188:                } else {
        -:  189:                    // T is not a function type.  We just call << to print p,
        -:  190:                    // relying on ADL to pick up user-defined << for their pointer
        -:  191:                    // types, if any.
        -:  192:                    *os << p;
        -:  193:                }
        -:  194:            }
        -:  195:        };
        -:  196:
        -:  197:        namespace internal_stream {
        -:  198:
        -:  199:            struct Sentinel;
        -:  200:
        -:  201:            template<typename Char, typename CharTraits, typename T>
        -:  202:            Sentinel *operator<<(::std::basic_ostream<Char, CharTraits> &os, const T &x);
        -:  203:
        -:  204:// Check if the user has a user-defined operator<< for their type.
        -:  205://
        -:  206:// We put this in its own namespace to inject a custom operator<< that allows us
        -:  207:// to probe the type's operator.
        -:  208://
        -:  209:// Note that this operator<< takes a generic std::basic_ostream<Char,
        -:  210:// CharTraits> type instead of the more restricted std::ostream.  If
        -:  211:// we define it to take an std::ostream instead, we'll get an
        -:  212:// "ambiguous overloads" compiler error when trying to print a type
        -:  213:// Foo that supports streaming to std::basic_ostream<Char,
        -:  214:// CharTraits>, as the compiler cannot tell whether
        -:  215:// operator<<(std::ostream&, const T&) or
        -:  216:// operator<<(std::basic_stream<Char, CharTraits>, const Foo&) is more
        -:  217:// specific.
        -:  218:            template<typename T>
        -:  219:            constexpr bool UseStreamOperator() {
        -:  220:                return !std::is_same<decltype(std::declval<std::ostream &>()
        -:  221:                        << std::declval<const T &>()),
        -:  222:                        Sentinel *>::value;
        -:  223:            }
        -:  224:
        -:  225:        }  // namespace internal_stream
        -:  226:
        -:  227:        struct StreamPrinter {
        -:  228:            template<typename T, typename = typename std::enable_if<
        -:  229:                    internal_stream::UseStreamOperator<T>()>::type>
    #####:  230:            static void PrintValue(const T &value, ::std::ostream *os) {
    $$$$$:  230-block  0
    $$$$$:  230-block  1
    #####:  231:                *os << value;
    #####:  232:            }
    $$$$$:  232-block  0
    $$$$$:  232-block  1
        -:  233:        };
        -:  234:
        -:  235:        struct ProtobufPrinter {
        -:  236:            // We print a protobuf using its ShortDebugString() when the string
        -:  237:            // doesn't exceed this many characters; otherwise we print it using
        -:  238:            // DebugString() for better readability.
        -:  239:            static const size_t kProtobufOneLinerMaxLength = 50;
        -:  240:
        -:  241:            template<typename T, typename = typename std::enable_if<
        -:  242:                    internal::IsAProtocolMessage<T>::value>::type>
        -:  243:            static void PrintValue(const T &value, ::std::ostream *os) {
        -:  244:                std::string pretty_str = value.ShortDebugString();
        -:  245:                if (pretty_str.length() > kProtobufOneLinerMaxLength) {
        -:  246:                    pretty_str = "\n" + value.DebugString();
        -:  247:                }
        -:  248:                *os << ("<" + pretty_str + ">");
        -:  249:            }
        -:  250:        };
        -:  251:
        -:  252:        struct ConvertibleToIntegerPrinter {
        -:  253:            // Since T has no << operator or PrintTo() but can be implicitly
        -:  254:            // converted to BiggestInt, we print it as a BiggestInt.
        -:  255:            //
        -:  256:            // Most likely T is an enum type (either named or unnamed), in which
        -:  257:            // case printing it as an integer is the desired behavior.  In case
        -:  258:            // T is not an enum, printing it as an integer is the best we can do
        -:  259:            // given that it has no user-defined printer.
        -:  260:            static void PrintValue(internal::BiggestInt value, ::std::ostream *os) {
        -:  261:                *os << value;
        -:  262:            }
        -:  263:        };
        -:  264:
        -:  265:        struct ConvertibleToStringViewPrinter {
        -:  266:#if GTEST_INTERNAL_HAS_STRING_VIEW
        -:  267:            static void PrintValue(internal::StringView value, ::std::ostream* os) {
        -:  268:              internal::UniversalPrint(value, os);
        -:  269:            }
        -:  270:#endif
        -:  271:        };
        -:  272:
        -:  273:
        -:  274:// Prints the given number of bytes in the given object to the given
        -:  275:// ostream.
        -:  276:        GTEST_API_ void PrintBytesInObjectTo(const unsigned char *obj_bytes,
        -:  277:                                             size_t count,
        -:  278:                                             ::std::ostream *os);
        -:  279:
        -:  280:        struct FallbackPrinter {
        -:  281:            template<typename T>
        -:  282:            static void PrintValue(const T &value, ::std::ostream *os) {
        -:  283:                PrintBytesInObjectTo(
        -:  284:                        static_cast<const unsigned char *>(
        -:  285:                                reinterpret_cast<const void *>(std::addressof(value))),
        -:  286:                        sizeof(value), os);
        -:  287:            }
        -:  288:        };
        -:  289:
        -:  290:// Try every printer in order and return the first one that works.
        -:  291:        template<typename T, typename E, typename Printer, typename... Printers>
        -:  292:        struct FindFirstPrinter : FindFirstPrinter<T, E, Printers...> {
        -:  293:        };
        -:  294:
        -:  295:        template<typename T, typename Printer, typename... Printers>
        -:  296:        struct FindFirstPrinter<
        -:  297:                T, decltype(Printer::PrintValue(std::declval<const T &>(), nullptr)),
        -:  298:                Printer, Printers...> {
        -:  299:            using type = Printer;
        -:  300:        };
        -:  301:
        -:  302:// Select the best printer in the following order:
        -:  303://  - Print containers (they have begin/end/etc).
        -:  304://  - Print function pointers.
        -:  305://  - Print object pointers.
        -:  306://  - Use the stream operator, if available.
        -:  307://  - Print protocol buffers.
        -:  308://  - Print types convertible to BiggestInt.
        -:  309://  - Print types convertible to StringView, if available.
        -:  310://  - Fallback to printing the raw bytes of the object.
        -:  311:        template<typename T>
    #####:  312:        void PrintWithFallback(const T &value, ::std::ostream *os) {
    $$$$$:  312-block  0
    $$$$$:  312-block  1
        -:  313:            using Printer = typename FindFirstPrinter<
        -:  314:                    T, void, ContainerPrinter, FunctionPointerPrinter, PointerPrinter,
        -:  315:                    StreamPrinter, ProtobufPrinter, ConvertibleToIntegerPrinter,
        -:  316:                    ConvertibleToStringViewPrinter, FallbackPrinter>::type;
    #####:  317:            Printer::PrintValue(value, os);
    #####:  318:        }
    $$$$$:  318-block  0
    $$$$$:  318-block  1
        -:  319:
        -:  320:// FormatForComparison<ToPrint, OtherOperand>::Format(value) formats a
        -:  321:// value of type ToPrint that is an operand of a comparison assertion
        -:  322:// (e.g. ASSERT_EQ).  OtherOperand is the type of the other operand in
        -:  323:// the comparison, and is used to help determine the best way to
        -:  324:// format the value.  In particular, when the value is a C string
        -:  325:// (char pointer) and the other operand is an STL string object, we
        -:  326:// want to format the C string as a string, since we know it is
        -:  327:// compared by value with the string object.  If the value is a char
        -:  328:// pointer but the other operand is not an STL string object, we don't
        -:  329:// know whether the pointer is supposed to point to a NUL-terminated
        -:  330:// string, and thus want to print it as a pointer to be safe.
        -:  331://
        -:  332:// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.
        -:  333:
        -:  334:// The default case.
        -:  335:        template<typename ToPrint, typename OtherOperand>
        -:  336:        class FormatForComparison {
        -:  337:        public:
    #####:  338:            static ::std::string Format(const ToPrint &value) {
    $$$$$:  338-block  0
    $$$$$:  338-block  1
    $$$$$:  338-block  2
    #####:  339:                return ::testing::PrintToString(value);
    $$$$$:  339-block  0
    $$$$$:  339-block  1
    $$$$$:  339-block  2
        -:  340:            }
        -:  341:        };
        -:  342:
        -:  343:// Array.
        -:  344:        template<typename ToPrint, size_t N, typename OtherOperand>
        -:  345:        class FormatForComparison<ToPrint[N], OtherOperand> {
        -:  346:        public:
        -:  347:            static ::std::string Format(const ToPrint *value) {
        -:  348:                return FormatForComparison<const ToPrint *, OtherOperand>::Format(value);
        -:  349:            }
        -:  350:        };
        -:  351:
        -:  352:// By default, print C string as pointers to be safe, as we don't know
        -:  353:// whether they actually point to a NUL-terminated string.
        -:  354:
        -:  355:#define GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_(CharType)                \
        -:  356:  template <typename OtherOperand>                                      \
        -:  357:  class FormatForComparison<CharType*, OtherOperand> {                  \
        -:  358:   public:                                                              \
        -:  359:    static ::std::string Format(CharType* value) {                      \
        -:  360:      return ::testing::PrintToString(static_cast<const void*>(value)); \
        -:  361:    }                                                                   \
        -:  362:  }
        -:  363:
        -:  364:        GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_(char);
        -:  365:
        -:  366:        GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_(const char);
        -:  367:
        -:  368:        GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_(wchar_t);
        -:  369:
        -:  370:        GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_(const wchar_t);
        -:  371:
        -:  372:#undef GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_
        -:  373:
        -:  374:// If a C string is compared with an STL string object, we know it's meant
        -:  375:// to point to a NUL-terminated string, and thus can print it as a string.
        -:  376:
        -:  377:#define GTEST_IMPL_FORMAT_C_STRING_AS_STRING_(CharType, OtherStringType) \
        -:  378:  template <>                                                           \
        -:  379:  class FormatForComparison<CharType*, OtherStringType> {               \
        -:  380:   public:                                                              \
        -:  381:    static ::std::string Format(CharType* value) {                      \
        -:  382:      return ::testing::PrintToString(value);                           \
        -:  383:    }                                                                   \
        -:  384:  }
        -:  385:
        -:  386:        GTEST_IMPL_FORMAT_C_STRING_AS_STRING_(char, ::std::string);
        -:  387:
        -:  388:        GTEST_IMPL_FORMAT_C_STRING_AS_STRING_(const char, ::std::string);
        -:  389:
        -:  390:#if GTEST_HAS_STD_WSTRING
        -:  391:        GTEST_IMPL_FORMAT_C_STRING_AS_STRING_(wchar_t, ::std::wstring);
        -:  392:        GTEST_IMPL_FORMAT_C_STRING_AS_STRING_(const wchar_t, ::std::wstring);
        -:  393:#endif
        -:  394:
        -:  395:#undef GTEST_IMPL_FORMAT_C_STRING_AS_STRING_
        -:  396:
        -:  397:// Formats a comparison assertion (e.g. ASSERT_EQ, EXPECT_LT, and etc)
        -:  398:// operand to be used in a failure message.  The type (but not value)
        -:  399:// of the other operand may affect the format.  This allows us to
        -:  400:// print a char* as a raw pointer when it is compared against another
        -:  401:// char* or void*, and print it as a C string when it is compared
        -:  402:// against an std::string object, for example.
        -:  403://
        -:  404:// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.
        -:  405:        template<typename T1, typename T2>
    #####:  406:        std::string FormatForComparisonFailureMessage(
    $$$$$:  406-block  0
    $$$$$:  406-block  1
    $$$$$:  406-block  2
        -:  407:                const T1 &value, const T2 & /* other_operand */) {
    #####:  408:            return FormatForComparison<T1, T2>::Format(value);
    $$$$$:  408-block  0
    $$$$$:  408-block  1
    $$$$$:  408-block  2
        -:  409:        }
        -:  410:
        -:  411:// UniversalPrinter<T>::Print(value, ostream_ptr) prints the given
        -:  412:// value to the given ostream.  The caller must ensure that
        -:  413:// 'ostream_ptr' is not NULL, or the behavior is undefined.
        -:  414://
        -:  415:// We define UniversalPrinter as a class template (as opposed to a
        -:  416:// function template), as we need to partially specialize it for
        -:  417:// reference types, which cannot be done with function templates.
        -:  418:        template<typename T>
        -:  419:        class UniversalPrinter;
        -:  420:
        -:  421:// Prints the given value using the << operator if it has one;
        -:  422:// otherwise prints the bytes in it.  This is what
        -:  423:// UniversalPrinter<T>::Print() does when PrintTo() is not specialized
        -:  424:// or overloaded for type T.
        -:  425://
        -:  426:// A user can override this behavior for a class type Foo by defining
        -:  427:// an overload of PrintTo() in the namespace where Foo is defined.  We
        -:  428:// give the user this option as sometimes defining a << operator for
        -:  429:// Foo is not desirable (e.g. the coding style may prevent doing it,
        -:  430:// or there is already a << operator but it doesn't do what the user
        -:  431:// wants).
        -:  432:        template<typename T>
    #####:  433:        void PrintTo(const T &value, ::std::ostream *os) {
    $$$$$:  433-block  0
    $$$$$:  433-block  1
    #####:  434:            internal::PrintWithFallback(value, os);
    #####:  435:        }
    $$$$$:  435-block  0
    $$$$$:  435-block  1
        -:  436:
        -:  437:// The following list of PrintTo() overloads tells
        -:  438:// UniversalPrinter<T>::Print() how to print standard types (built-in
        -:  439:// types, strings, plain arrays, and pointers).
        -:  440:
        -:  441:// Overloads for various char types.
        -:  442:        GTEST_API_ void PrintTo(unsigned char c, ::std::ostream *os);
        -:  443:
        -:  444:        GTEST_API_ void PrintTo(signed char c, ::std::ostream *os);
        -:  445:
        -:  446:        inline void PrintTo(char c, ::std::ostream *os) {
        -:  447:            // When printing a plain char, we always treat it as unsigned.  This
        -:  448:            // way, the output won't be affected by whether the compiler thinks
        -:  449:            // char is signed or not.
        -:  450:            PrintTo(static_cast<unsigned char>(c), os);
        -:  451:        }
        -:  452:
        -:  453:// Overloads for other simple built-in types.
        -:  454:        inline void PrintTo(bool x, ::std::ostream *os) {
        -:  455:            *os << (x ? "true" : "false");
        -:  456:        }
        -:  457:
        -:  458:// Overload for wchar_t type.
        -:  459:// Prints a wchar_t as a symbol if it is printable or as its internal
        -:  460:// code otherwise and also as its decimal code (except for L'\0').
        -:  461:// The L'\0' char is printed as "L'\\0'". The decimal code is printed
        -:  462:// as signed integer when wchar_t is implemented by the compiler
        -:  463:// as a signed type and is printed as an unsigned integer when wchar_t
        -:  464:// is implemented as an unsigned type.
        -:  465:        GTEST_API_ void PrintTo(wchar_t wc, ::std::ostream *os);
        -:  466:
        -:  467:// Overloads for C strings.
        -:  468:        GTEST_API_ void PrintTo(const char *s, ::std::ostream *os);
        -:  469:
        -:  470:        inline void PrintTo(char *s, ::std::ostream *os) {
        -:  471:            PrintTo(ImplicitCast_<const char *>(s), os);
        -:  472:        }
        -:  473:
        -:  474:// signed/unsigned char is often used for representing binary data, so
        -:  475:// we print pointers to it as void* to be safe.
        -:  476:        inline void PrintTo(const signed char *s, ::std::ostream *os) {
        -:  477:            PrintTo(ImplicitCast_<const void *>(s), os);
        -:  478:        }
        -:  479:
        -:  480:        inline void PrintTo(signed char *s, ::std::ostream *os) {
        -:  481:            PrintTo(ImplicitCast_<const void *>(s), os);
        -:  482:        }
        -:  483:
        -:  484:        inline void PrintTo(const unsigned char *s, ::std::ostream *os) {
        -:  485:            PrintTo(ImplicitCast_<const void *>(s), os);
        -:  486:        }
        -:  487:
        -:  488:        inline void PrintTo(unsigned char *s, ::std::ostream *os) {
        -:  489:            PrintTo(ImplicitCast_<const void *>(s), os);
        -:  490:        }
        -:  491:
        -:  492:// MSVC can be configured to define wchar_t as a typedef of unsigned
        -:  493:// short.  It defines _NATIVE_WCHAR_T_DEFINED when wchar_t is a native
        -:  494:// type.  When wchar_t is a typedef, defining an overload for const
        -:  495:// wchar_t* would cause unsigned short* be printed as a wide string,
        -:  496:// possibly causing invalid memory accesses.
        -:  497:#if !defined(_MSC_VER) || defined(_NATIVE_WCHAR_T_DEFINED)
        -:  498:// Overloads for wide C strings
        -:  499:        GTEST_API_ void PrintTo(const wchar_t *s, ::std::ostream *os);
        -:  500:
        -:  501:        inline void PrintTo(wchar_t *s, ::std::ostream *os) {
        -:  502:            PrintTo(ImplicitCast_<const wchar_t *>(s), os);
        -:  503:        }
        -:  504:
        -:  505:#endif
        -:  506:
        -:  507:// Overload for C arrays.  Multi-dimensional arrays are printed
        -:  508:// properly.
        -:  509:
        -:  510:// Prints the given number of elements in an array, without printing
        -:  511:// the curly braces.
        -:  512:        template<typename T>
        -:  513:        void PrintRawArrayTo(const T a[], size_t count, ::std::ostream *os) {
        -:  514:            UniversalPrint(a[0], os);
        -:  515:            for (size_t i = 1; i != count; i++) {
        -:  516:                *os << ", ";
        -:  517:                UniversalPrint(a[i], os);
        -:  518:            }
        -:  519:        }
        -:  520:
        -:  521:// Overloads for ::std::string.
        -:  522:        GTEST_API_ void PrintStringTo(const ::std::string &s, ::std::ostream *os);
        -:  523:
        -:  524:        inline void PrintTo(const ::std::string &s, ::std::ostream *os) {
        -:  525:            PrintStringTo(s, os);
        -:  526:        }
        -:  527:
        -:  528:// Overloads for ::std::wstring.
        -:  529:#if GTEST_HAS_STD_WSTRING
        -:  530:        GTEST_API_ void PrintWideStringTo(const ::std::wstring&s, ::std::ostream* os);
        -:  531:        inline void PrintTo(const ::std::wstring& s, ::std::ostream* os) {
        -:  532:          PrintWideStringTo(s, os);
        -:  533:        }
        -:  534:#endif  // GTEST_HAS_STD_WSTRING
        -:  535:
        -:  536:#if GTEST_INTERNAL_HAS_STRING_VIEW
        -:  537:        // Overload for internal::StringView.
        -:  538:        inline void PrintTo(internal::StringView sp, ::std::ostream* os) {
        -:  539:          PrintTo(::std::string(sp), os);
        -:  540:        }
        -:  541:#endif  // GTEST_INTERNAL_HAS_STRING_VIEW
        -:  542:
        -:  543:        inline void PrintTo(std::nullptr_t, ::std::ostream *os) { *os << "(nullptr)"; }
        -:  544:
        -:  545:        template<typename T>
        -:  546:        void PrintTo(std::reference_wrapper<T> ref, ::std::ostream *os) {
        -:  547:            UniversalPrinter<T &>::Print(ref.get(), os);
        -:  548:        }
        -:  549:
        -:  550:// Helper function for printing a tuple.  T must be instantiated with
        -:  551:// a tuple type.
        -:  552:        template<typename T>
        -:  553:        void PrintTupleTo(const T &, std::integral_constant<size_t, 0>,
        -:  554:                          ::std::ostream *) {}
        -:  555:
        -:  556:        template<typename T, size_t I>
        -:  557:        void PrintTupleTo(const T &t, std::integral_constant<size_t, I>,
        -:  558:                          ::std::ostream *os) {
        -:  559:            PrintTupleTo(t, std::integral_constant<size_t, I - 1>(), os);
        -:  560:            GTEST_INTENTIONAL_CONST_COND_PUSH_()
        -:  561:            if (I > 1) {
        -:  562:                GTEST_INTENTIONAL_CONST_COND_POP_()
        -:  563:                *os << ", ";
        -:  564:            }
        -:  565:            UniversalPrinter<typename std::tuple_element<I - 1, T>::type>::Print(
        -:  566:                    std::get<I - 1>(t), os);
        -:  567:        }
        -:  568:
        -:  569:        template<typename... Types>
        -:  570:        void PrintTo(const ::std::tuple<Types...> &t, ::std::ostream *os) {
        -:  571:            *os << "(";
        -:  572:            PrintTupleTo(t, std::integral_constant<size_t, sizeof...(Types)>(), os);
        -:  573:            *os << ")";
        -:  574:        }
        -:  575:
        -:  576:// Overload for std::pair.
        -:  577:        template<typename T1, typename T2>
        -:  578:        void PrintTo(const ::std::pair<T1, T2> &value, ::std::ostream *os) {
        -:  579:            *os << '(';
        -:  580:            // We cannot use UniversalPrint(value.first, os) here, as T1 may be
        -:  581:            // a reference type.  The same for printing value.second.
        -:  582:            UniversalPrinter<T1>::Print(value.first, os);
        -:  583:            *os << ", ";
        -:  584:            UniversalPrinter<T2>::Print(value.second, os);
        -:  585:            *os << ')';
        -:  586:        }
        -:  587:
        -:  588:// Implements printing a non-reference type T by letting the compiler
        -:  589:// pick the right overload of PrintTo() for T.
        -:  590:        template<typename T>
        -:  591:        class UniversalPrinter {
        -:  592:        public:
        -:  593:            // MSVC warns about adding const to a function type, so we want to
        -:  594:            // disable the warning.
        -:  595:            GTEST_DISABLE_MSC_WARNINGS_PUSH_(4180)
        -:  596:
        -:  597:            // Note: we deliberately don't call this PrintTo(), as that name
        -:  598:            // conflicts with ::testing::internal::PrintTo in the body of the
        -:  599:            // function.
    #####:  600:            static void Print(const T &value, ::std::ostream *os) {
    $$$$$:  600-block  0
    $$$$$:  600-block  1
        -:  601:                // By default, ::testing::internal::PrintTo() is used for printing
        -:  602:                // the value.
        -:  603:                //
        -:  604:                // Thanks to Koenig look-up, if T is a class and has its own
        -:  605:                // PrintTo() function defined in its namespace, that function will
        -:  606:                // be visible here.  Since it is more specific than the generic ones
        -:  607:                // in ::testing::internal, it will be picked by the compiler in the
        -:  608:                // following statement - exactly what we want.
    #####:  609:                PrintTo(value, os);
    #####:  610:            }
    $$$$$:  610-block  0
    $$$$$:  610-block  1
        -:  611:
        -:  612:            GTEST_DISABLE_MSC_WARNINGS_POP_()
        -:  613:        };
        -:  614:
        -:  615:#if GTEST_HAS_ABSL
        -:  616:
        -:  617:        // Printer for absl::optional
        -:  618:
        -:  619:        template <typename T>
        -:  620:        class UniversalPrinter<::absl::optional<T>> {
        -:  621:         public:
        -:  622:          static void Print(const ::absl::optional<T>& value, ::std::ostream* os) {
        -:  623:            *os << '(';
        -:  624:            if (!value) {
        -:  625:              *os << "nullopt";
        -:  626:            } else {
        -:  627:              UniversalPrint(*value, os);
        -:  628:            }
        -:  629:            *os << ')';
        -:  630:          }
        -:  631:        };
        -:  632:
        -:  633:        // Printer for absl::variant
        -:  634:
        -:  635:        template <typename... T>
        -:  636:        class UniversalPrinter<::absl::variant<T...>> {
        -:  637:         public:
        -:  638:          static void Print(const ::absl::variant<T...>& value, ::std::ostream* os) {
        -:  639:            *os << '(';
        -:  640:            absl::visit(Visitor{os}, value);
        -:  641:            *os << ')';
        -:  642:          }
        -:  643:
        -:  644:         private:
        -:  645:          struct Visitor {
        -:  646:            template <typename U>
        -:  647:            void operator()(const U& u) const {
        -:  648:              *os << "'" << GetTypeName<U>() << "' with value ";
        -:  649:              UniversalPrint(u, os);
        -:  650:            }
        -:  651:            ::std::ostream* os;
        -:  652:          };
        -:  653:        };
        -:  654:
        -:  655:#endif  // GTEST_HAS_ABSL
        -:  656:
        -:  657:// UniversalPrintArray(begin, len, os) prints an array of 'len'
        -:  658:// elements, starting at address 'begin'.
        -:  659:        template<typename T>
        -:  660:        void UniversalPrintArray(const T *begin, size_t len, ::std::ostream *os) {
        -:  661:            if (len == 0) {
        -:  662:                *os << "{}";
        -:  663:            } else {
        -:  664:                *os << "{ ";
        -:  665:                const size_t kThreshold = 18;
        -:  666:                const size_t kChunkSize = 8;
        -:  667:                // If the array has more than kThreshold elements, we'll have to
        -:  668:                // omit some details by printing only the first and the last
        -:  669:                // kChunkSize elements.
        -:  670:                if (len <= kThreshold) {
        -:  671:                    PrintRawArrayTo(begin, len, os);
        -:  672:                } else {
        -:  673:                    PrintRawArrayTo(begin, kChunkSize, os);
        -:  674:                    *os << ", ..., ";
        -:  675:                    PrintRawArrayTo(begin + len - kChunkSize, kChunkSize, os);
        -:  676:                }
        -:  677:                *os << " }";
        -:  678:            }
        -:  679:        }
        -:  680:// This overload prints a (const) char array compactly.
        -:  681:        GTEST_API_ void UniversalPrintArray(
        -:  682:                const char *begin, size_t len, ::std::ostream *os);
        -:  683:
        -:  684:// This overload prints a (const) wchar_t array compactly.
        -:  685:        GTEST_API_ void UniversalPrintArray(
        -:  686:                const wchar_t *begin, size_t len, ::std::ostream *os);
        -:  687:
        -:  688:// Implements printing an array type T[N].
        -:  689:        template<typename T, size_t N>
        -:  690:        class UniversalPrinter<T[N]> {
        -:  691:        public:
        -:  692:            // Prints the given array, omitting some elements when there are too
        -:  693:            // many.
        -:  694:            static void Print(const T (&a)[N], ::std::ostream *os) {
        -:  695:                UniversalPrintArray(a, N, os);
        -:  696:            }
        -:  697:        };
        -:  698:
        -:  699:// Implements printing a reference type T&.
        -:  700:        template<typename T>
        -:  701:        class UniversalPrinter<T &> {
        -:  702:        public:
        -:  703:            // MSVC warns about adding const to a function type, so we want to
        -:  704:            // disable the warning.
        -:  705:            GTEST_DISABLE_MSC_WARNINGS_PUSH_(4180)
        -:  706:
        -:  707:            static void Print(const T &value, ::std::ostream *os) {
        -:  708:                // Prints the address of the value.  We use reinterpret_cast here
        -:  709:                // as static_cast doesn't compile when T is a function type.
        -:  710:                *os << "@" << reinterpret_cast<const void *>(&value) << " ";
        -:  711:
        -:  712:                // Then prints the value itself.
        -:  713:                UniversalPrint(value, os);
        -:  714:            }
        -:  715:
        -:  716:            GTEST_DISABLE_MSC_WARNINGS_POP_()
        -:  717:        };
        -:  718:
        -:  719:// Prints a value tersely: for a reference type, the referenced value
        -:  720:// (but not the address) is printed; for a (const) char pointer, the
        -:  721:// NUL-terminated string (but not the pointer) is printed.
        -:  722:
        -:  723:        template<typename T>
        -:  724:        class UniversalTersePrinter {
        -:  725:        public:
    #####:  726:            static void Print(const T &value, ::std::ostream *os) {
    $$$$$:  726-block  0
    $$$$$:  726-block  1
    #####:  727:                UniversalPrint(value, os);
    #####:  728:            }
    $$$$$:  728-block  0
    $$$$$:  728-block  1
        -:  729:        };
        -:  730:
        -:  731:        template<typename T>
        -:  732:        class UniversalTersePrinter<T &> {
        -:  733:        public:
        -:  734:            static void Print(const T &value, ::std::ostream *os) {
        -:  735:                UniversalPrint(value, os);
        -:  736:            }
        -:  737:        };
        -:  738:
        -:  739:        template<typename T, size_t N>
        -:  740:        class UniversalTersePrinter<T[N]> {
        -:  741:        public:
        -:  742:            static void Print(const T (&value)[N], ::std::ostream *os) {
        -:  743:                UniversalPrinter<T[N]>::Print(value, os);
        -:  744:            }
        -:  745:        };
        -:  746:
        -:  747:        template<>
        -:  748:        class UniversalTersePrinter<const char *> {
        -:  749:        public:
        -:  750:            static void Print(const char *str, ::std::ostream *os) {
        -:  751:                if (str == nullptr) {
        -:  752:                    *os << "NULL";
        -:  753:                } else {
        -:  754:                    UniversalPrint(std::string(str), os);
        -:  755:                }
        -:  756:            }
        -:  757:        };
        -:  758:
        -:  759:        template<>
        -:  760:        class UniversalTersePrinter<char *> {
        -:  761:        public:
        -:  762:            static void Print(char *str, ::std::ostream *os) {
        -:  763:                UniversalTersePrinter<const char *>::Print(str, os);
        -:  764:            }
        -:  765:        };
        -:  766:
        -:  767:#if GTEST_HAS_STD_WSTRING
        -:  768:        template <>
        -:  769:        class UniversalTersePrinter<const wchar_t*> {
        -:  770:         public:
        -:  771:          static void Print(const wchar_t* str, ::std::ostream* os) {
        -:  772:            if (str == nullptr) {
        -:  773:              *os << "NULL";
        -:  774:            } else {
        -:  775:              UniversalPrint(::std::wstring(str), os);
        -:  776:            }
        -:  777:          }
        -:  778:        };
        -:  779:#endif
        -:  780:
        -:  781:        template<>
        -:  782:        class UniversalTersePrinter<wchar_t *> {
        -:  783:        public:
        -:  784:            static void Print(wchar_t *str, ::std::ostream *os) {
        -:  785:                UniversalTersePrinter<const wchar_t *>::Print(str, os);
        -:  786:            }
        -:  787:        };
        -:  788:
        -:  789:        template<typename T>
        -:  790:        void UniversalTersePrint(const T &value, ::std::ostream *os) {
        -:  791:            UniversalTersePrinter<T>::Print(value, os);
        -:  792:        }
        -:  793:
        -:  794:// Prints a value using the type inferred by the compiler.  The
        -:  795:// difference between this and UniversalTersePrint() is that for a
        -:  796:// (const) char pointer, this prints both the pointer and the
        -:  797:// NUL-terminated string.
        -:  798:        template<typename T>
    #####:  799:        void UniversalPrint(const T &value, ::std::ostream *os) {
    $$$$$:  799-block  0
    $$$$$:  799-block  1
        -:  800:            // A workarond for the bug in VC++ 7.1 that prevents us from instantiating
        -:  801:            // UniversalPrinter with T directly.
        -:  802:            typedef T T1;
    #####:  803:            UniversalPrinter<T1>::Print(value, os);
    #####:  804:        }
    $$$$$:  804-block  0
    $$$$$:  804-block  1
        -:  805:
        -:  806:        typedef ::std::vector<::std::string> Strings;
        -:  807:
        -:  808:        // Tersely prints the first N fields of a tuple to a string vector,
        -:  809:        // one element for each field.
        -:  810:        template<typename Tuple>
        -:  811:        void TersePrintPrefixToStrings(const Tuple &, std::integral_constant<size_t, 0>,
        -:  812:                                       Strings *) {}
        -:  813:
        -:  814:        template<typename Tuple, size_t I>
        -:  815:        void TersePrintPrefixToStrings(const Tuple &t,
        -:  816:                                       std::integral_constant<size_t, I>,
        -:  817:                                       Strings *strings) {
        -:  818:            TersePrintPrefixToStrings(t, std::integral_constant<size_t, I - 1>(),
        -:  819:                                      strings);
        -:  820:            ::std::stringstream ss;
        -:  821:            UniversalTersePrint(std::get<I - 1>(t), &ss);
        -:  822:            strings->push_back(ss.str());
        -:  823:        }
        -:  824:
        -:  825:// Prints the fields of a tuple tersely to a string vector, one
        -:  826:// element for each field.  See the comment before
        -:  827:// UniversalTersePrint() for how we define "tersely".
        -:  828:        template<typename Tuple>
        -:  829:        Strings UniversalTersePrintTupleFieldsToStrings(const Tuple &value) {
        -:  830:            Strings result;
        -:  831:            TersePrintPrefixToStrings(
        -:  832:                    value, std::integral_constant<size_t, std::tuple_size<Tuple>::value>(),
        -:  833:                    &result);
        -:  834:            return result;
        -:  835:        }
        -:  836:
        -:  837:    }  // namespace internal
        -:  838:
        -:  839:    template<typename T>
    #####:  840:    ::std::string PrintToString(const T &value) {
    $$$$$:  840-block  0
    $$$$$:  840-block  1
    #####:  841:        ::std::stringstream ss;
    #####:  842:        internal::UniversalTersePrinter<T>::Print(value, &ss);
    $$$$$:  842-block  0
    $$$$$:  842-block  1
    $$$$$:  842-block  2
    $$$$$:  842-block  3
    $$$$$:  842-block  4
    $$$$$:  842-block  5
    #####:  843:        return ss.str();
    $$$$$:  843-block  0
    $$$$$:  843-block  1
    #####:  844:    }
    $$$$$:  844-block  0
    $$$$$:  844-block  1
    $$$$$:  844-block  2
    $$$$$:  844-block  3
    $$$$$:  844-block  4
    $$$$$:  844-block  5
        -:  845:
        -:  846:}  // namespace testing
        -:  847:
        -:  848:// Include any custom printer added by the local installation.
        -:  849:// We must include this header at the end to make sure it can use the
        -:  850:// declarations from this file.
        -:  851:#include "gtest/internal/custom/gtest-printers.h"
        -:  852:
        -:  853:#endif  // GTEST_INCLUDE_GTEST_GTEST_PRINTERS_H_
